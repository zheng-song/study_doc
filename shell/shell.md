# shell脚本编程大全

## 1. shell 的父子关系

​	用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell,是一个父shell。本书到目前为止都是父shell提供CLI提示符,然后等待命令输入。在CLI提示符后输入 /bin/bash 命令或其他等效的 bash命令时,会创建一个新的shell程序。这个shell程序被称为子shell(child shell)。子shell也拥有CLI提示符,同样会等待命令输入。当输入 bash 、生成子shell的时候,你是看不到任何相关的信息的,因此需要另一条命令帮助我们理清这一切。第4章中讲过的 ps 命令能够派上用场,在生成子shell的前后配合选项 -f 来使用。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af54abaafd908?w=621&h=266&f=png&s=22105)

### 1.1 进程列表

​	你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号(;)即可。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5c6e6e6216b?w=504&h=186&f=png&s=15593)

​	在上面的例子中,所有的命令依次执行,不存在任何问题。不过这并不是进程列表。命令列表要想成为进程列表,这些命令必须包含在括号里。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5d28177f4fd?w=504&h=185&f=png&s=16069)

​	尽管多出来的括号看起来没有什么太大的不同,但起到的效果确是非同寻常。括号的加入使
命令列表变成了进程列表,==生成了一个子shell来执行对应的命令。==

>进程列表是一种命令分组(command grouping)。另一种命令分组是将命令放入花括号中,并在命令列表尾部加上分号(;)。语法为 { command; } 。使用花括号进行命令分组并不会像进程列表那样创建出子shell。

​	要想知道是否生成了子shell,得借助一个使用了环境变量的命令。这个命令就是 `echo $BASH_SUBSHELL` 。如果该命令返回 0 ,就表明没有子shell。如果返回1 或者其他更大的数字,就表明存在子shell。下面的例子中使用了一个命令列表,列表尾部是 `echo $BASH_SUBSHELL `。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5fb76de66a6?w=647&h=189&f=png&s=22146)

![](https://user-gold-cdn.xitu.io/2018/4/10/162af610bc82bc34?w=346&h=132&f=png&s=11176)

​	注意,在第一个进程列表中,数字 1 表明了一个子shell,这个结果和预期的一样。但是在第二个进程列表中,在命令 echo $BASH_SUBSHELL 外面又多出了一对括号。这对括号在子shell中产生了另一个子shell来执行命令。因此数字 2 表明的就是这个子shell。在shell脚本中,经常使用子shell进行多进程处理。但是采用子shell的成本不菲,会明显拖慢处理速度。在交互式的CLI shell会话中,子shell同样存在问题。它并非真正的多进程处理,因为终端控制着子shell的I/O。

### 1.2 别出心裁的子shell用法

​	在交互式的shell CLI中,还有很多更富有成效的子shell用法。==进程列表、协程和管道都利用了子shell==，它们都可以有效地在交互式shell中使用。在交互式shell中,一个高效的子shell用法就是使用后台模式。

#### 1.2.1 将进程置入后台模式

​	例如：`(sleep 10 ; echo $BASH_SUBSHELL ; sleep 10)&`

​	在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中进行繁重的处理工作,同时也不会让子shell的I/O受制于终端。将进程列表置入后台模式并不是子shell在CLI中仅有的创造性用法。协程就是另一种方法。

#### 1.2.2 协程

​	协程可以同时做两件事。它在后台生成一个子shell,并在这个子shell中执行命令。要进行协程处理,得使用coproc 命令,还有要在子shell中执行的命令。如：`coproc sleep 10` 。除了会创建子shell之外,协程基本上就是将命令置入后台模式。当输入 coproc 命令及其参数之后,你会发现启用了一个后台作业。屏幕上会显示出后台作业号以及进程ID。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71147cdaf38?w=557&h=69&f=png&s=5012)

在上面的例子中可以看到在子shell中执行的后台命令是 coproc COPROC sleep 10 。 COPROC是 coproc 命令给进程起的名字。你可以使用命令的扩展语法自己设置这个名字。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71b6fc3cf10?w=623&h=134&f=png&s=10229)

通过使用扩展语法,协程的名字被设置成 My_Job 。这里要注意的是,扩展语法写起来有点麻烦。必须确保在第一个花括号( { )和命令名之间有一个空格。还必须保证命令以分号(;)结尾。另外,分号和闭花括号( } )之间也得有一个空格。

> 协程能够让你尽情发挥想象力,发送或接收来自子shell中进程的信息。只有在拥有多个协程的时候才需要对协程进行命名,因为你得和它们进行通信。否则的话,让 coproc 命令将其设置成默认的名字 COPROC 就行了。

你可以发挥才智,将协程与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,然后把命令 coproc 放在前面就行了。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af738bbfa2aa1?w=587&h=249&f=png&s=20079)

记住,生成子shell的成本不低,而且速度还慢。创建嵌套子shell更是火上浇油!在命令行中使用子shell能够获得灵活性和便利。要想获得这些优势,重要的是理解子shell的行为方式。对于命令也是如此。在下一节中,我们将研究内建命令与外部命令之间的行为差异。

### 1.3 理解shell的内建命令

#### 1.3.1 外部命令

​	外部命令,有时候也被称为文件系统命令,是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。

​	ps就是一个外部命令。你可以使用 which 和 type 命令找到它。

​	当外部命令执行时,会创建出一个子进程。这种操作被称为衍生(forking)。外部命令 ps 很
方便显示出它的父进程以及自己所对应的衍生子进程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af775f152bfba?w=574&h=105&f=png&s=11174)

作为外部命令，ps命令执行的时候会创建出一个子进程。在这里, ps 命令的PID是 2801 ,父PID是 2743 。作为父进程的bash shell的PID是 2743 。图5-3展示了外部命令执行时的衍生过程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af792be0760de?w=425&h=223&f=png&s=11987)

当进程必须执行衍生操作时,它需要花费时间和精力来设置新子进程的环境。所以说,外部命令多少还是有代价的。

> 就算衍生出子进程或是创建了子shell,你仍然可以通过发送信号与其沟通,这一点无论是在命令行还是在脚本编写中都是极其有用的。发送信号(signaling)使得进程间可以通过信号进行通信。

#### 1.3.2 内建命令

​	内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体,作为shell工具的组成部分存在。不需要借助外部程序文件来运行。
​	cd 和 exit 命令都内建于bash shell。可以利用 type 命令来了解某个命令是否是内建的。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7b6fa3d9a61?w=284&h=124&f=png&s=7115)

要注意,有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现,使用 type 命令的 -a 选项。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7c5ffb5bcf7?w=293&h=300&f=png&s=14978)

命令 type -a 显示出了每个命令的两种实现。注意, which 命令只显示出了外部命令文件。

> 对于有多种实现的命令,如果想要使用其外部命令实现,直接指明对应的文件就可以了。例如,要使用外部命令 pwd ,可以输入 /bin/pwd 。

----



## 2. 使用Linux环境变量

​	Linux环境变量能够帮助你提升Linux shell的体验很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量,了解去哪里设置相应的环境变量很重要。

​	在bash shell中，环境变量分为两种：

- 全局变量
- 局部变量

> 尽管bash shell使用一致的专有环境变量，但是不同的但不同的Linux发行版经常会添加其自有的环境变量。你在本章中看到的环境变量的例子可能会跟你安装的发行版中看到的结果略微不同。如果遇到本书未讲到的环境变量,可以查看你的Linux发行版上的文档。

### 2.1 全局环境变量

​	全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的
shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。

​	Linux系统会在你开始bash会话时就设置一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别普通用户的环境变量。要查看全局变量可以使用`env`或`printenv`命令。

​	要显示个别的环境变量的值，可以使用`printenv`命令，但是不要使用`env`命令。如：`printenv HOME`。也可以使用`echo`命令来显示，但此时必须要在环境变量前加一个美元符($)。



### 2.2 局部环境变量

​	局部环境变量只能在定义它们的进程中可见。尽管它们是局部的,但是和全局环境变量一样重要。事实上,Linux系统也默认定义了标准的局部环境变量。不过你也可以定义自己的局部变量,如你所想,这些变量被称为用户定义局部变量。

​	查看局部环境变量的列表有点复杂。在Linux中并没有一个只显示局部环境变量的命令。`set`命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。

> 命令 env 、 printenv 和 set 之间的差异很细微。 set 命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env 和 printenv 命令同 set命令的区别在于前两个命令不会对变量排序,也不会输出局部变量和用户定义变量。在这种情况下, env 和 printenv 的输出是重复的。不过 env 命令有一个 printenv 没有的功能,这使得它要更有用一些。



### 2.3 在shell脚本中设置用户自定义变量

​	可以在bash shell中直接设置自己的变量。本节将介绍怎样在交互式shell或shell脚本程序中创建自己的变量并引用它们。

#### 2.3.1 设置局部用户定义变量

​	可以通过等号给环境变量赋值,值可以是数值或字符串。如：`myVar=HELLO`。若要赋的值为一个含有空格的字符串，那么需要用单引号来界定字符串的首尾。如：`myVar='HELLO WORLD'`。

==注意，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，bash shell就会把它当成是一个单独的命令。==

#### 2.3.2 设置全局环境变量

​	在设定全局环境变量的进程所创建的子进程中,该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量,然后再把它导出到全局环境中。**这个过程通过 export 命令来完成,变量名前面不需要加 $ 。**如：

```powershell
$ myVar=‘I am a good people’
$ export myVar
```

**如果你在当前的shell下生成一个子shell，修改这个子shell中的全局变量并不会影响到父shell中该变量的值。即使你在子shell当中使用export将此环境变量导出为全局变量也无法改变其父shell中该环境变量的值。但是能够影响其子shell的值**

![](https://user-gold-cdn.xitu.io/2018/4/11/162b3c683e2ad1ea?w=365&h=237&f=png&s=20651)



### 2.4 删除环境变量

​	既然可以创建新的环境变量，自然也能删除已经存在的环境变量可以用 unset 命令完成这个操作。**在 unset 命令中引用环境变量时,记住不要使用 $ **。

​	在处理全局环境变量时，有一些需要注意的地方。如果你在子进程中删除了一个全局环境变量，这只对子进程有效，该全局环境变量在父进程当中依然可用。和修改变量一样，在子shell中删除的全局变量是无法反映到父shell中的，但是能够反应到其子shell中。



### 2.5 默认的shell环境变量

​	默认情况下,bash shell会用一些特定的环境变量来定义系统环境。这些变量在你的Linux系
统上都已经设置好了,你只需要放心使用即可。下表列出了一些bash shell提供的与Unix Bourne shell兼容的环境变量。

| 变量             | 描述                                       |
| -------------- | ---------------------------------------- |
| CDPATH         | 冒号分隔的目录列表,作为 cd 命令的搜索路径                  |
| HOME           | 当前用户的主目录                                 |
| IFS            | shell用来将文本字符串分割成字段的一系列字符                 |
| MAIL           | 当前用户收件箱的文件名(bash shell会检查这个文件,看看有没有新邮件)  |
| MAILPATH       | 冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件,看看有没有新邮件) |
| OPTARG         | getopts 命令处理的最后一个选项参数值                   |
| OPTION         | getopts 命令处理的最后一个选项参数的索引号                |
| PATH           | shell查找命令的目录列表,由冒号分隔                     |
| PS1            | shell命令行界面的主提示符                          |
| PS2            | shell命令行界面的次提示符                          |
| FUNCNEST       | 当设置成非零值时,表示所允许的最大函数嵌套级数(一旦超出,当前命令即被终止)   |
| GLOBIGNORE     | 冒号分隔的模式列表,定义了在进行文件名扩展时可以忽略的一组文件名         |
| GROUPS         | 含有当前用户属组列表的数组变量                          |
| histchars      | 控制历史记录扩展,最多可有3个字符                        |
| HISTCMD        | 当前命令在历史记录中的编号                            |
| HISTCONTROL    | 控制哪些命令留在历史记录列表中                          |
| HISTFILE       | 保存shell历史记录列表的文件名(默认是.bash_history)      |
| HISTFILESIZE   | 最多在历史文件中存多少行                             |
| HISTTIMEFORMAT | 如果设置了且非空,就用作格式化字符串,以显示bash历史中每条命令的时间戳    |



### 2.6 设置PATH环境变量

​	当你在shell命令行界面中输入一个外部命令时,shell必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。若你的可执行程序的目录不在PATH环境变量当中，那么你就必须使用绝对路径来执行程序。或者你需要将其加入到PATH中。==如果你希望子shell也能够找到你的程序的位置，一定要记得把修改后的PATH环境变量导出。==

​	对PATH变量的修改只能够持续到退出或者是重启系统，这种效果并不能够持续。若要永久保持环境变量的修改效果。则可以修改`/etc/profile`文件或者是`.bashrc`文件。



### 2.7 定位系统环境变量

​	环境变量在Linux系统中的用途很多。你现在已经知道如何修改系统环境变量,也知道了如何创建自己的环境变量。接下来的问题是怎样让环境变量的作用持久化。在你登入Linux系统启动一个bash shell时,默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash shell的方式。启动bash shell有3种方式:

- 登录时作为默认登录shell
- 作为非登录shell的交互式shell
- 作为运行脚本的非交互式shell

#### 2.7.1 登录shell

​	当你登录Linux系统时,bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里读取命令:

- **/etc/profile :** 是bash shell默认的的主启动文件。只要你登录了Linux系统,bash就会执行/etc/profile 启动文件中的命令。不同的Linux发行版在这个文件里放了不同的命令。
- **$HOME/.bash_profile:**
- **$HOME/.bashrc:**
- **$HOME/.bash_login:**
- **$HOME/.profile:**

> 要 留 意 的 是 有 些 Linux 发 行 版 使 用 了 可 拆 卸 式 认 证 模 块 ( Pluggable Authentication Modules ,PAM)。在这种情况下,PAM文件会在bash shell启动之前处理,这些文件中可能会包含环境变量。PAM文件包括 /etc/environment 文件和$HOME/.pam_environment 文件。PAM更多的相关信息可以在http://linux-pam.org中找到。

1. /etc/profile文件

/etc/profile文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行这个启动文件。只要你登录了Linux系统,bash就会执行/etc/profile 启动文件中的命令。

2. $HOME目录下的启动文件

剩下的启动文件都起着同一个作用:提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个。

shell会按照按照下列顺序,运行第一个被找到的文件,余下的则被忽略:

- $HOME/.bash_profile
- $HOME/.bash_login
- $HOME/.profile

注意,这个列表中并没有$HOME/.bashrc文件。这是因为该文件通常通过其他文件运行的。

#### 2.7.2 交互式shell进程

​	如果你的bash shell不是登录系统时启动的(比如是在命令行提示符下敲入 bash 时启动),那么你启动的shell叫作交互式shell。交互式shell不会像登录shell一样运行,但它依然提供了命令行提示符来输入命令。如果bash是作为交互式shell启动的,它就不会访问/etc/profile文件,只会检查用户HOME目录中的.bashrc文件。

#### 2.7.3 非交互式shell

​	最后一种shell是非交互式shell。系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。但是当你在系统上运行脚本时,也许希望能够运行一些特定启动的命令。

> 脚本能以不同的方式执行。只有其中的某一些方式能够启动子shell。你会在之后的内容中中学习到shell不同的执行方式。

为了处理这种情况,bash shell提供了 BASH_ENV 环境变量。当shell启动一个非交互式shell进程时,它会检查这个环境变量来查看要执行的启动文件。如果有指定的文件,shell会执行该文件里的命令,这通常包括shell脚本变量设置。



​	若 BASH_ENV 变量没有设置,那么shell脚本到哪里去获得它们的环境变量呢?别忘了有些shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。举例来说,如果父shell是登录shell在/etc/profile、 /etc/profile.d/ * .sh和$HOME/.bashrc文件中设置并导出了变量,用于执行脚本的子shell就能够继承这些变量。

要记住,由父shell设置但并未导出的变量都是局部变量。子shell无法继承局部变量。

对于那些不启动子shell的脚本,变量已经存在于当前shell中了。所以就算没有设置BASH_ENV ,也可以使用当前shell的局部变量和全局变量。

#### 2.7.4 环境变量持久化

​	现在你已经了解了各种shell进程以及对应的环境文件,找出永久性环境变量就容易多了。也可以利用这些文件创建自己的永久性全局变量或局部变量。

​	对全局环境变量来说(Linux系统中所有用户都需要使用的变量),可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中,但这可不是什么好主意。如果你升级了所用的发行版,这个文件也会跟着更新,那你所有定制过的变量设置可就都没有了。
​	最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。
​	在大多数发行版中,存储个人用户永久性bash shell变量的地方是\$HOME/.bashrc文件。这一点适用于所有类型的shell进程。但如果设置了 BASH_ENV 变量,那么记住,除非它指向的是\$HOME/.bashrc,否则你应该将非交互式shell的用户变量放在别的地方。

> 图形化界面组成部分(如GUI客户端)的环境变量可能需要在另外一些配置文件中设置,这和设置bash shell环境变量的地方不一样。



### 2.8 数组变量

​	环境变量有一个很酷的特性就是,它们可作为数组使用。数组是能够存储多个值的变量。这些值可以单独引用,也可以作为整个数组来引用。

​	要给某个环境变量设置多个值,可以把值放在括号里,值与值之间用空格分隔。

```shell
// 要给某个环境变量设置多个值,可以把值放在括号里,值与值之间用空格分隔。
mytest=(one two three four five) 
//如果你想把数组像普通的环境变量那样显示,你会失望的。
echo $mytest  //输出为：one
echo ${mytest[2]} // 输出为：three
//要显示整个数组变量,可用星号作为通配符放在索引值的位置。
echo ${mytest[*]}
//也可以改变某个索引值位置的值。
mytest[2]=seven

// 甚至能用unset命令删除数组中的某个值,但是要小心,这可能会有点复杂。看下面的例子。
unset mytest[2]
/*这个例子用 unset 命令删除在索引值为 2 的位置上的值。显示整个数组时,看起来像是索引里面已经没这个索引了。但当专门显示索引值为 2 的位置上的值时,就能看到这个位置是空的。*/

//最后,可以在 unset 命令后跟上数组名来删除整个数组。
unset mytest
```

有时数组变量会让事情很麻烦,所以在shell脚本编程时并不常用。对其他shell而言,数组变量的可移植性并不好,如果需要在不同的shell环境下从事大量的脚本编写工作,这会带来很多不便。有些bash系统环境变量使用了数组(比如 BASH_VERSINFO ),但总体上不会太频繁用到。

----



## 3. 理解Linux文件权限

​	本章将介绍如何在必要时利用Linux文件安全系统保护和共享数据。

### 3.1 Linux 的安全性

​	Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。

​	用户权限是通过创建用户时分配的用户ID(User ID,通常缩写为UID)来跟踪的。UID是数值,每个用户都有唯一的UID,但在登录系统时用的不是UID,而是登录名。登录名是用户用来登录系统的最长八字符的字符串(字符可以是数字或字母),同时会关联一个对应的密码。

​	Linux系统使用特定的文件和工具来跟踪和管理系统上的用户账户。在我们讨论文件权限之前,先来看一下Linux是怎样处理用户账户的。本节会介绍管理用户账户需要的文件和工具,这样在处理文件权限问题时,你就知道如何使用它们了。

#### 3.1.1 /etc/passwd文件

​	Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是/etc/passwd文件,它包含了一些与用户有关的信息。

​	root用户账户是Linux系统的管理员,固定分配给它的UID是 0 。Linux系统会为各种各样的功能创建不同的用户账户,而这些账户并不是真的用户。这些账户叫作系统账户,是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。
​	在安全成为一个大问题之前,这些服务经常会用root账户登录。遗憾的是,如果有非授权的用户攻陷了这些服务中的一个,他立刻就能作为root用户进入系统。为了防止发生这种情况,现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话,即使有人攻入了某个服务,也无法访问整个系统。
​	Linux为系统账户预留了500以下的UID值。有些服务甚至要用特定的UID才能正常工作。为普通用户创建账户时,大多数Linux系统会从500开始,将第一个可用UID分配给这个账户(并非所有的Linux发行版都是这样)。

​	你可能已经注意到/etc/passwd文件中还有很多用户登录名和UID之外的信息。/etc/passwd文件的字段包含了如下信息:

-  登录用户名
-  用户密码
-  用户账户的UID(数字形式)
-  用户账户的组ID(GID)(数字形式)
-  用户账户的文本描述(称为备注字段)
- 用户HOME目录的位置
- 用户的默认shell

/etc/passwd文件中的密码字段都被设置成了x,这并不是说所有的用户账户都用相同的密码。在早期的Linux 上 , /etc/passwd文件里有加密后的用户密码。但鉴于很多程序都需要访问/etc/passwd文件获取用户信息,这就成了一个安全隐患。随着用来破解加密密码的工具的不断演进,用心不良的人开始忙于破解存储在/etc/passwd文件中的密码。于是Linux开发人员开始重新考虑这个策略。

​	==现在,绝大多数Linux系统都将用户密码保存在另一个单独的文件中(叫作shadow文件,位置在/etc/shadow)。只有特定的程序(比如登录程序)才能访问这个文件。==

​	/etc/passwd是一个标准的文本文件。你可以用任何文本编辑器在/etc/password文件里直接手动进行用户管理(比如添加、修改或删除用户账户)。但这样做极其危险。如果/etc/passwd文件出现损坏,系统就无法读取它的内容了,这样会导致用户无法正常登录(即便是root用户)。用标准的Linux用户管理工具去执行这些用户管理功能就会安全许多。

#### 3.1.2 /etc/shadow文件

​	/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件,这让它比起/etc/passwd安全许多。

​	/etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样:

```shell
rich:$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020:11627:0:99999:7:::
```

在/etc/shadow文件的每条记录中都有9个字段:

- 与/etc/passwd文件中的登录名字段对应的登录名
- 加密后的密码
- 自上次修改密码后过去的天数密码(自1970年1月1日开始计算)
- 多少天后才能更改密码
- 多少天后必须更改密码
- 密码过期前提前多少天提醒用户更改密码
- 密码过期后多少天禁用用户账户
- 用户账户被禁用的日期(用自1970年1月1日到当天的天数表示)
- 预留字段给将来使用

使用shadow密码系统后,Linux系统可以更好地控制用户密码。它可以控制用户多久更改一
次密码,以及什么时候禁用该用户账户,如果密码未更新的话。

#### 3.1.3 添加新用户

​	useradd这个命令可以一次性创建新用户账户及设置用户HOME目录结构。useradd 命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。可以使用加入-D选项的useradd命令查看所用Linux系统中的这些默认值。例如：

```shell
# /usr/sbin/useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes
#
```

> 一些Linux发行版会把Linux用户和组工具放在/usr/sbin目录下,这个目录可能不在 PATH 环境变量里。如果你的Linux系统是这样的话,可以将这个目录添加进 PATH 环境变量,或者用绝对文件路径名来使用这些工具。

在创建新用户时,如果你不在命令行中指定具体的值, useradd 命令就会使用 -D 选项所显示的那些默认值。这个例子列出的默认值如下:

- 新用户会被添加到GID为 100 的公共组;
- 新用户的HOME目录将会位于/home/loginname;
- 新用户账户密码在过期后不会被禁用;
- 新用户账户未被设置过期日期;
- 新用户账户将bash shell作为默认shell;
- 系统会将/etc/skel目录下的内容复制到用户的HOME目录下;
- 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。

倒数第二个值很有意思。 useradd 命令允许管理员创建一份默认的HOME目录配置,然后把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件。在Ubuntu Linux系统上,/etc/skel目录有下列文件:

![](https://user-gold-cdn.xitu.io/2018/4/12/162b99befdb77e5a?w=549&h=153&f=png&s=16949)

要想在创建用户时改变默认值或默认行为,可以使用命令行参数。具体的可以通过man查看。

