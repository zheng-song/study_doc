# shell脚本编程大全

## 1. shell 的父子关系

​	用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell,是一个父shell。本书到目前为止都是父shell提供CLI提示符,然后等待命令输入。在CLI提示符后输入 /bin/bash 命令或其他等效的 bash命令时,会创建一个新的shell程序。这个shell程序被称为子shell(child shell)。子shell也拥有CLI提示符,同样会等待命令输入。当输入 bash 、生成子shell的时候,你是看不到任何相关的信息的,因此需要另一条命令帮助我们理清这一切。第4章中讲过的 ps 命令能够派上用场,在生成子shell的前后配合选项 -f 来使用。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af54abaafd908?w=621&h=266&f=png&s=22105)

### 1.1 进程列表

​	你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号(;)即可。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5c6e6e6216b?w=504&h=186&f=png&s=15593)

​	在上面的例子中,所有的命令依次执行,不存在任何问题。不过这并不是进程列表。命令列表要想成为进程列表,这些命令必须包含在括号里。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5d28177f4fd?w=504&h=185&f=png&s=16069)

​	尽管多出来的括号看起来没有什么太大的不同,但起到的效果确是非同寻常。括号的加入使
命令列表变成了进程列表,==生成了一个子shell来执行对应的命令。==

>进程列表是一种命令分组(command grouping)。另一种命令分组是将命令放入花括号中,并在命令列表尾部加上分号(;)。语法为 { command; } 。使用花括号进行命令分组并不会像进程列表那样创建出子shell。

​	要想知道是否生成了子shell,得借助一个使用了环境变量的命令。这个命令就是 `echo $BASH_SUBSHELL` 。如果该命令返回 0 ,就表明没有子shell。如果返回1 或者其他更大的数字,就表明存在子shell。下面的例子中使用了一个命令列表,列表尾部是 `echo $BASH_SUBSHELL `。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5fb76de66a6?w=647&h=189&f=png&s=22146)

![](https://user-gold-cdn.xitu.io/2018/4/10/162af610bc82bc34?w=346&h=132&f=png&s=11176)

​	注意,在第一个进程列表中,数字 1 表明了一个子shell,这个结果和预期的一样。但是在第二个进程列表中,在命令 echo $BASH_SUBSHELL 外面又多出了一对括号。这对括号在子shell中产生了另一个子shell来执行命令。因此数字 2 表明的就是这个子shell。在shell脚本中,经常使用子shell进行多进程处理。但是采用子shell的成本不菲,会明显拖慢处理速度。在交互式的CLI shell会话中,子shell同样存在问题。它并非真正的多进程处理,因为终端控制着子shell的I/O。

### 1.2 别出心裁的子shell用法

​	在交互式的shell CLI中,还有很多更富有成效的子shell用法。==进程列表、协程和管道都利用了子shell==，它们都可以有效地在交互式shell中使用。在交互式shell中,一个高效的子shell用法就是使用后台模式。

#### 1.2.1 将进程置入后台模式

​	例如：`(sleep 10 ; echo $BASH_SUBSHELL ; sleep 10)&`

​	在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中进行繁重的处理工作,同时也不会让子shell的I/O受制于终端。将进程列表置入后台模式并不是子shell在CLI中仅有的创造性用法。协程就是另一种方法。

#### 1.2.2 协程

​	协程可以同时做两件事。它在后台生成一个子shell,并在这个子shell中执行命令。要进行协程处理,得使用coproc 命令,还有要在子shell中执行的命令。如：`coproc sleep 10` 。除了会创建子shell之外,协程基本上就是将命令置入后台模式。当输入 coproc 命令及其参数之后,你会发现启用了一个后台作业。屏幕上会显示出后台作业号以及进程ID。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71147cdaf38?w=557&h=69&f=png&s=5012)

在上面的例子中可以看到在子shell中执行的后台命令是 coproc COPROC sleep 10 。 COPROC是 coproc 命令给进程起的名字。你可以使用命令的扩展语法自己设置这个名字。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71b6fc3cf10?w=623&h=134&f=png&s=10229)

通过使用扩展语法,协程的名字被设置成 My_Job 。这里要注意的是,扩展语法写起来有点麻烦。必须确保在第一个花括号( { )和命令名之间有一个空格。还必须保证命令以分号(;)结尾。另外,分号和闭花括号( } )之间也得有一个空格。

> 协程能够让你尽情发挥想象力,发送或接收来自子shell中进程的信息。只有在拥有多个协程的时候才需要对协程进行命名,因为你得和它们进行通信。否则的话,让 coproc 命令将其设置成默认的名字 COPROC 就行了。

你可以发挥才智,将协程与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,然后把命令 coproc 放在前面就行了。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af738bbfa2aa1?w=587&h=249&f=png&s=20079)

记住,生成子shell的成本不低,而且速度还慢。创建嵌套子shell更是火上浇油!在命令行中使用子shell能够获得灵活性和便利。要想获得这些优势,重要的是理解子shell的行为方式。对于命令也是如此。在下一节中,我们将研究内建命令与外部命令之间的行为差异。

### 1.3 理解shell的内建命令

#### 1.3.1 外部命令

​	外部命令,有时候也被称为文件系统命令,是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。

​	ps就是一个外部命令。你可以使用 which 和 type 命令找到它。

​	当外部命令执行时,会创建出一个子进程。这种操作被称为衍生(forking)。外部命令 ps 很
方便显示出它的父进程以及自己所对应的衍生子进程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af775f152bfba?w=574&h=105&f=png&s=11174)

作为外部命令，ps命令执行的时候会创建出一个子进程。在这里, ps 命令的PID是 2801 ,父PID是 2743 。作为父进程的bash shell的PID是 2743 。图5-3展示了外部命令执行时的衍生过程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af792be0760de?w=425&h=223&f=png&s=11987)

当进程必须执行衍生操作时,它需要花费时间和精力来设置新子进程的环境。所以说,外部命令多少还是有代价的。

> 就算衍生出子进程或是创建了子shell,你仍然可以通过发送信号与其沟通,这一点无论是在命令行还是在脚本编写中都是极其有用的。发送信号(signaling)使得进程间可以通过信号进行通信。

#### 1.3.2 内建命令

​	内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体,作为shell工具的组成部分存在。不需要借助外部程序文件来运行。
​	cd 和 exit 命令都内建于bash shell。可以利用 type 命令来了解某个命令是否是内建的。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7b6fa3d9a61?w=284&h=124&f=png&s=7115)

要注意,有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现,使用 type 命令的 -a 选项。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7c5ffb5bcf7?w=293&h=300&f=png&s=14978)

命令 type -a 显示出了每个命令的两种实现。注意, which 命令只显示出了外部命令文件。

> 对于有多种实现的命令,如果想要使用其外部命令实现,直接指明对应的文件就可以了。例如,要使用外部命令 pwd ,可以输入 /bin/pwd 。

----



## 2. 使用Linux环境变量

​	Linux环境变量能够帮助你提升Linux shell的体验很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量,了解去哪里设置相应的环境变量很重要。

​	在bash shell中，环境变量分为两种：

- 全局变量
- 局部变量

> 尽管bash shell使用一致的专有环境变量，但是不同的但不同的Linux发行版经常会添加其自有的环境变量。你在本章中看到的环境变量的例子可能会跟你安装的发行版中看到的结果略微不同。如果遇到本书未讲到的环境变量,可以查看你的Linux发行版上的文档。

### 2.1 全局环境变量

​	全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的
shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。

​	Linux系统会在你开始bash会话时就设置一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别普通用户的环境变量。要查看全局变量可以使用`env`或`printenv`命令。

​	要显示个别的环境变量的值，可以使用`printenv`命令，但是不要使用`env`命令。如：`printenv HOME`。也可以使用`echo`命令来显示，但此时必须要在环境变量前加一个美元符($)。



### 2.2 局部环境变量

​	局部环境变量只能在定义它们的进程中可见。尽管它们是局部的,但是和全局环境变量一样重要。事实上,Linux系统也默认定义了标准的局部环境变量。不过你也可以定义自己的局部变量,如你所想,这些变量被称为用户定义局部变量。

​	查看局部环境变量的列表有点复杂。在Linux中并没有一个只显示局部环境变量的命令。`set`命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。

> 命令 env 、 printenv 和 set 之间的差异很细微。 set 命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env 和 printenv 命令同 set命令的区别在于前两个命令不会对变量排序,也不会输出局部变量和用户定义变量。在这种情况下, env 和 printenv 的输出是重复的。不过 env 命令有一个 printenv 没有的功能,这使得它要更有用一些。



### 2.3 在shell脚本中设置用户自定义变量

​	可以在bash shell中直接设置自己的变量。本节将介绍怎样在交互式shell或shell脚本程序中创建自己的变量并引用它们。

#### 2.3.1 设置局部用户定义变量

​	可以通过等号给环境变量赋值,值可以是数值或字符串。如：`myVar=HELLO`。若要赋的值为一个含有空格的字符串，那么需要用单引号来界定字符串的首尾。如：`myVar='HELLO WORLD'`。

==注意，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，bash shell就会把它当成是一个单独的命令。==

#### 2.3.2 设置全局环境变量

​	在设定全局环境变量的进程所创建的子进程中,该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量,然后再把它导出到全局环境中。**这个过程通过 export 命令来完成,变量名前面不需要加 $ 。**如：

```powershell
$ myVar=‘I am a good people’
$ export myVar
```

**如果你在当前的shell下生成一个子shell，修改这个子shell中的全局变量并不会影响到父shell中该变量的值。即使你在子shell当中使用export将此环境变量导出为全局变量也无法改变其父shell中该环境变量的值。但是能够影响其子shell的值**

![](https://user-gold-cdn.xitu.io/2018/4/11/162b3c683e2ad1ea?w=365&h=237&f=png&s=20651)



### 2.4 删除环境变量

​	既然可以创建新的环境变量，自然也能删除已经存在的环境变量可以用 unset 命令完成这个操作。**在 unset 命令中引用环境变量时,记住不要使用 $ **。

​	在处理全局环境变量时，有一些需要注意的地方。如果你在子进程中删除了一个全局环境变量，这只对子进程有效，该全局环境变量在父进程当中依然可用。和修改变量一样，在子shell中删除的全局变量是无法反映到父shell中的，但是能够反应到其子shell中。



### 2.5 默认的shell环境变量

​	默认情况下,bash shell会用一些特定的环境变量来定义系统环境。这些变量在你的Linux系
统上都已经设置好了,你只需要放心使用即可。下表列出了一些bash shell提供的与Unix Bourne shell兼容的环境变量。

| 变量             | 描述                                       |
| -------------- | ---------------------------------------- |
| CDPATH         | 冒号分隔的目录列表,作为 cd 命令的搜索路径                  |
| HOME           | 当前用户的主目录                                 |
| IFS            | shell用来将文本字符串分割成字段的一系列字符                 |
| MAIL           | 当前用户收件箱的文件名(bash shell会检查这个文件,看看有没有新邮件)  |
| MAILPATH       | 冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件,看看有没有新邮件) |
| OPTARG         | getopts 命令处理的最后一个选项参数值                   |
| OPTION         | getopts 命令处理的最后一个选项参数的索引号                |
| PATH           | shell查找命令的目录列表,由冒号分隔                     |
| PS1            | shell命令行界面的主提示符                          |
| PS2            | shell命令行界面的次提示符                          |
| FUNCNEST       | 当设置成非零值时,表示所允许的最大函数嵌套级数(一旦超出,当前命令即被终止)   |
| GLOBIGNORE     | 冒号分隔的模式列表,定义了在进行文件名扩展时可以忽略的一组文件名         |
| GROUPS         | 含有当前用户属组列表的数组变量                          |
| histchars      | 控制历史记录扩展,最多可有3个字符                        |
| HISTCMD        | 当前命令在历史记录中的编号                            |
| HISTCONTROL    | 控制哪些命令留在历史记录列表中                          |
| HISTFILE       | 保存shell历史记录列表的文件名(默认是.bash_history)      |
| HISTFILESIZE   | 最多在历史文件中存多少行                             |
| HISTTIMEFORMAT | 如果设置了且非空,就用作格式化字符串,以显示bash历史中每条命令的时间戳    |



### 2.6 设置PATH环境变量

​	当你在shell命令行界面中输入一个外部命令时,shell必须搜索系统来找到对应的程序。PATH 环境变量定义了用于进行命令和程序查找的目录。若你的可执行程序的目录不在PATH环境变量当中，那么你就必须使用绝对路径来执行程序。或者你需要将其加入到PATH中。==如果你希望子shell也能够找到你的程序的位置，一定要记得把修改后的PATH环境变量导出。==

​	对PATH变量的修改只能够持续到退出或者是重启系统，这种效果并不能够持续。若要永久保持环境变量的修改效果。则可以修改`/etc/profile`文件或者是`.bashrc`文件。



### 2.7 定位系统环境变量

​	环境变量在Linux系统中的用途很多。你现在已经知道如何修改系统环境变量,也知道了如何创建自己的环境变量。接下来的问题是怎样让环境变量的作用持久化。在你登入Linux系统启动一个bash shell时,默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash shell的方式。启动bash shell有3种方式:

- 登录时作为默认登录shell
- 作为非登录shell的交互式shell
- 作为运行脚本的非交互式shell

#### 2.7.1 登录shell

​	当你登录Linux系统时,bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里读取命令:

- **/etc/profile :** 是bash shell默认的的主启动文件。只要你登录了Linux系统,bash就会执行/etc/profile 启动文件中的命令。不同的Linux发行版在这个文件里放了不同的命令。
- **$HOME/.bash_profile:**
- **$HOME/.bashrc:**
- **$HOME/.bash_login:**
- **$HOME/.profile:**

/etc/profile文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行
这个启动文件。

> 要 留 意 的 是 有 些 Linux 发 行 版 使 用 了 可 拆 卸 式 认 证 模 块 ( Pluggable Authentication Modules ,PAM)。在这种情况下,PAM文件会在bash shell启动之前处理,这些文件中可能会包含环境变量。PAM文件包括 /etc/environment 文件和$HOME/.pam_environment 文件。PAM更多的相关信息可以在http://linux-pam.org中找到。