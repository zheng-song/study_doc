# shell脚本编程大全

## 1. shell 的父子关系

​	用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell,是一个父shell。本书到目前为止都是父shell提供CLI提示符,然后等待命令输入。在CLI提示符后输入 /bin/bash 命令或其他等效的 bash命令时,会创建一个新的shell程序。这个shell程序被称为子shell(child shell)。子shell也拥有CLI提示符,同样会等待命令输入。当输入 bash 、生成子shell的时候,你是看不到任何相关的信息的,因此需要另一条命令帮助我们理清这一切。第4章中讲过的 ps 命令能够派上用场,在生成子shell的前后配合选项 -f 来使用。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af54abaafd908?w=621&h=266&f=png&s=22105)

### 1.1 进程列表

​	你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号(;)即可。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5c6e6e6216b?w=504&h=186&f=png&s=15593)

​	在上面的例子中,所有的命令依次执行,不存在任何问题。不过这并不是进程列表。命令列表要想成为进程列表,这些命令必须包含在括号里。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5d28177f4fd?w=504&h=185&f=png&s=16069)

​	尽管多出来的括号看起来没有什么太大的不同,但起到的效果确是非同寻常。括号的加入使
命令列表变成了进程列表,==生成了一个子shell来执行对应的命令。==

>进程列表是一种命令分组(command grouping)。另一种命令分组是将命令放入花括号中,并在命令列表尾部加上分号(;)。语法为 { command; } 。使用花括号进行命令分组并不会像进程列表那样创建出子shell。

​	要想知道是否生成了子shell,得借助一个使用了环境变量的命令。这个命令就是 `echo $BASH_SUBSHELL` 。如果该命令返回 0 ,就表明没有子shell。如果返回1 或者其他更大的数字,就表明存在子shell。下面的例子中使用了一个命令列表,列表尾部是 `echo $BASH_SUBSHELL `。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af5fb76de66a6?w=647&h=189&f=png&s=22146)

![](https://user-gold-cdn.xitu.io/2018/4/10/162af610bc82bc34?w=346&h=132&f=png&s=11176)

​	注意,在第一个进程列表中,数字 1 表明了一个子shell,这个结果和预期的一样。但是在第二个进程列表中,在命令 echo $BASH_SUBSHELL 外面又多出了一对括号。这对括号在子shell中产生了另一个子shell来执行命令。因此数字 2 表明的就是这个子shell。在shell脚本中,经常使用子shell进行多进程处理。但是采用子shell的成本不菲,会明显拖慢处理速度。在交互式的CLI shell会话中,子shell同样存在问题。它并非真正的多进程处理,因为终端控制着子shell的I/O。

### 1.2 别出心裁的子shell用法

​	在交互式的shell CLI中,还有很多更富有成效的子shell用法。==进程列表、协程和管道都利用了子shell==，它们都可以有效地在交互式shell中使用。在交互式shell中,一个高效的子shell用法就是使用后台模式。

#### 1.2.1 将进程置入后台模式

​	例如：`(sleep 10 ; echo $BASH_SUBSHELL ; sleep 10)&`

​	在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中进行繁重的处理工作,同时也不会让子shell的I/O受制于终端。将进程列表置入后台模式并不是子shell在CLI中仅有的创造性用法。协程就是另一种方法。

#### 1.2.2 协程

​	协程可以同时做两件事。它在后台生成一个子shell,并在这个子shell中执行命令。要进行协程处理,得使用coproc 命令,还有要在子shell中执行的命令。如：`coproc sleep 10` 。除了会创建子shell之外,协程基本上就是将命令置入后台模式。当输入 coproc 命令及其参数之后,你会发现启用了一个后台作业。屏幕上会显示出后台作业号以及进程ID。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71147cdaf38?w=557&h=69&f=png&s=5012)

在上面的例子中可以看到在子shell中执行的后台命令是 coproc COPROC sleep 10 。 COPROC是 coproc 命令给进程起的名字。你可以使用命令的扩展语法自己设置这个名字。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af71b6fc3cf10?w=623&h=134&f=png&s=10229)

通过使用扩展语法,协程的名字被设置成 My_Job 。这里要注意的是,扩展语法写起来有点麻烦。必须确保在第一个花括号( { )和命令名之间有一个空格。还必须保证命令以分号(;)结尾。另外,分号和闭花括号( } )之间也得有一个空格。

> 协程能够让你尽情发挥想象力,发送或接收来自子shell中进程的信息。只有在拥有多个协程的时候才需要对协程进行命名,因为你得和它们进行通信。否则的话,让 coproc 命令将其设置成默认的名字 COPROC 就行了。

你可以发挥才智,将协程与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,然后把命令 coproc 放在前面就行了。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af738bbfa2aa1?w=587&h=249&f=png&s=20079)

记住,生成子shell的成本不低,而且速度还慢。创建嵌套子shell更是火上浇油!在命令行中使用子shell能够获得灵活性和便利。要想获得这些优势,重要的是理解子shell的行为方式。对于命令也是如此。在下一节中,我们将研究内建命令与外部命令之间的行为差异。

### 1.3 理解shell的内建命令

#### 1.3.1 外部命令

​	外部命令,有时候也被称为文件系统命令,是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。

​	ps就是一个外部命令。你可以使用 which 和 type 命令找到它。

​	当外部命令执行时,会创建出一个子进程。这种操作被称为衍生(forking)。外部命令 ps 很
方便显示出它的父进程以及自己所对应的衍生子进程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af775f152bfba?w=574&h=105&f=png&s=11174)

作为外部命令，ps命令执行的时候会创建出一个子进程。在这里, ps 命令的PID是 2801 ,父PID是 2743 。作为父进程的bash shell的PID是 2743 。图5-3展示了外部命令执行时的衍生过程。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af792be0760de?w=425&h=223&f=png&s=11987)

当进程必须执行衍生操作时,它需要花费时间和精力来设置新子进程的环境。所以说,外部命令多少还是有代价的。

> 就算衍生出子进程或是创建了子shell,你仍然可以通过发送信号与其沟通,这一点无论是在命令行还是在脚本编写中都是极其有用的。发送信号(signaling)使得进程间可以通过信号进行通信。

#### 1.3.2 内建命令

​	内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体,作为shell工具的组成部分存在。不需要借助外部程序文件来运行。
​	cd 和 exit 命令都内建于bash shell。可以利用 type 命令来了解某个命令是否是内建的。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7b6fa3d9a61?w=284&h=124&f=png&s=7115)

要注意,有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现,使用 type 命令的 -a 选项。

![](https://user-gold-cdn.xitu.io/2018/4/10/162af7c5ffb5bcf7?w=293&h=300&f=png&s=14978)

命令 type -a 显示出了每个命令的两种实现。注意, which 命令只显示出了外部命令文件。

> 对于有多种实现的命令,如果想要使用其外部命令实现,直接指明对应的文件就可以了。例如,要使用外部命令 pwd ,可以输入 /bin/pwd 。

----



## 2. 使用Linux环境变量







