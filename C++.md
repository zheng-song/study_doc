[TOC]

### 第八章 函数探幽

- 执行函数调用指令时,程序将会在函数调用之后立即存储该指令的内存地址,并将函数的参数复制到堆栈,跳到标记被调用的函数起点的内存单元,执行函数代码(也许还需要将返回值放入到寄存器或者堆栈中),然后跳回到地址被保存的指令处.这种函数调用是需要一定的开销的.
- C++ 内联:编译器会使用相应的函数代码替换函数调用(编译器不一定会满足内联要求,**编译器可能发现该函数过大,或者有递归调用,则会忽略内联请求;也有些编译器没有启用或实现这种特性.**).C++成为内联函数的方法有:

1. 在函数声明前加关键字inline.
2. 在函数定义前加关键字inline.

通常的做法是省略原型,将整个的定义放在本应提供原型的地方.



#### 引用变量(&)

引用变量的主要用途是用作函数的参数.引用必须要在声明的时候初始化.而不能像指针那样,先申明再赋值.**C++中允许按引用传递允许被调用的函数能够访问调用函数中的变量(即使该变量是局部变量).**引入引用的主要目的是用于**结构和类**的传递,而不是基本的内置类型.

- **将引用作为返回值:**通常返回值机制将返回值复制到临时存储单元中,然后该临时返回存储单元的内容将会被复制到接收返回值的变量当中.然而,返回引用意味着调用程序将会直接访问返回值,而不需要拷贝.***返回引用时最重要的一点是,应该避免返回当函数终止时不再存在的内存单元的引用.即:***

```C++
const Type &clone(Type &a)
{
	Type tmp;
	tmp = a;
	return tmp;  //不应该出现这样的代码,因为该函数运行完之后tmp的内存不再存在,虽然程序能够通过编译(会有警告),但是执行时会崩溃.所以此时应返回const Type类型(复制返回),而不是const Type &类型.
}
```

该函数返回一个指向临时变量tmp的引用,函数运行完毕以后,他将不再存在.

- **为何将const用于引用返回类型:**使用const并不意味着Type类型本身为const,而是意味着你不能够使用返回引用来直接修改它指向的结构.

> ***将C-风格的字符串用作string对象的引用参数***
>
> `function("abcdef"); void function(const string &str){...};` C++的string类定义了一种char * 到string的转换功能,这使得可以使用C-风格字符串来初始化string对象.同事,对于const类型的引用有一个属性,假设实参的类型与形参不符,但是该实参可以被转换为引用类型,程序将会创建一个正确类型的临时变量,使用转换后的实参值来初始化它,然后传递一个指向该临时变量的引用.所以上面可以将char * 类型或者是const char *类型传递给const string &类型.



**什么时候使用引用?什么时候使用指针?什么时候使用按值传递?一些指导原则如下:**

对于使用传递的值而不作修改的函数:

- 若数据对象很小,如内置数据类型或小型结构,则按值传递
- 若数据对象是数组,则使用指针,因为这是唯一的选择.并将指针声明为const.
- 若数据对象是较大的结构,则使用const指针或者const引用,以提高程序的效率.
- 若数据对象是类对象,则使用const引用.类设计的语义常常要求使用引用,这是C++新增这一项的主要原因,因此,传递类对象的标准方式是按引用传递.

对于要修改调用函数中的数据的函数:

- 若数据对象是内置类型,则使用指针.
- 若数据对象是数组,则只能使用指针.
- 若数据对象是结构,则使用引用或指针
- 若数据对象是类对象,则使用引用.



#### 默认参数

C++ 中设置函数的默认参数必须通过函数原型来实现.默认值必须从右向左添加,若要为某个参数设置默认值,则必须要为它右边的所有参数提供默认值.



#### 函数重载

函数多态是C++的新功能,默认的参数能让你使用不同数目的参数调用同一个函数,而函数的多态(重载)能够让你使用多个同名的函数.可以通过重载来设计一系列的函数----他们完成相同的工作,但是使用不同的参数列表.C++使用上下文来确定要使用的重载函数版本.

- 函数重载的关键是函数的参数列表----也称为函数的特征标(function signature). 类型的引用和类型本身会被视为是同一种特征标.通过函数的类型并不能重载函数(即只有类型不同,其他都相同不是函数重载,而是错误).

> ***什么是名称修饰***
>
> C++ 使用**名称修饰(name decoration)**或者是**名称矫正(name mangling)**来跟踪每一个重载函数,他会根据函数原型中指定的形参类型对每一个函数名进行"加密",如`long func(int,float);`编译器会将名称转换为不太好看的内部表示,如下`?func@@YAXH@Z`,这样对原始名称进行的修饰将会对参数的数目和类型进行编码,添加的一组符号会随着函数的特征标而异,而修饰时使用的约定随编译器而异. 



#### 函数模板

函数模板可以用来创建一个通用的函数，用以支持多种不同的形参，避免重载函数的函数体重复设计。它最大的特点是把函数使用的数据类型作为参数。声明形式为：

 ```C++
template<typename T>
T func(T x,int y)
{
  T x;
  //...
}
 ```

若主函数中有如下的调用语句

```C++
double b;
int a;
func(d,a);
```

那么系统将会使用实参d的数据类型double去替代函数模板中的T生成函数：

```C++
double func(double x, int y)
{
  double x;
  //...
}
```

函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况使用实参的数据类型来代替类型参数描述符之后，才能产生真正的函数。**关键字`typename`也可以使用关键字`class` ，这时数据类型参数标识符就可以使用所有的C++数据类型类型。**



##### 函数模板的生成

函数模板的数据类型参数标识符实际上是一个类型参数，在使用函数模板的时候，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板参数，用模板实参实例化的函数称为模板函数。模板函数的生成就是讲模板函数的类型参数实例化的过程。

**注意：**

1. 函数模板允许使用多个类型参数，但是在template定义部分的每一个形参前必须有关键字typename或class，即：`template<class 标识符1,...,class 标识符n>`
2. 在template语句和函数模板定义语句 <返回值类型> 之间不允许有别的语句。即template语句之后要紧跟函数模板定义。

```C++
template<class T>
  int i;             // 这样定义是错误的，不能在template和函数模板之间有其他的语句
T min(T x, T y)
{
  //...
}
```

3. 模板函数类似于重载函数，但是两者有很大的区别：函数重载时，每一个函数体内可以执行不同的动作，但是同一个函数模板实例化后的函数都必须执行相同的动作。



##### 函数模板的异常处理

函数模板中的模板参数可以实例化为各种类型，但是当实例化模板参数的各模板参数之间不完全一致时，就可能发生错误，如：

```C++
template<typename T>
void min (T &x, T &y){return (x<y)?x:y;}
void func(int i, char j)
{
  min(i,i);
  min(j,j);
  min(i,j);
  min(j,i);//后两个调用是错误的，出错的原因是，在调用的时候，编译器按照最先遇到的实参的类型隐式的生成一个函数模板，并使用它对所有的模板函数进行一致性检查。
}
```

`min(i,j);` 先遇到的实参`i`是整型的，编译器就将模板形参解释为整形，此后出现的模板实参`j` 不能被解释为整型而产生错误，**此时没有隐含的类型转换功能。** 解决此种异常的方法有两种：

1. 采用强制类型转换：如将`min(i,j)` 转换为 `min(i,(int)j)` 

2. 用非模板函数重载模板函数：有两种实现方法。

   - 借用函数模板的函数体：

   ```C++
   //此时只声明非模板函数的原型，他的函数体借用模板函数的函数体，改写如下
   template<typename T>
   void min(T &x, T &y){return (x<y)?x:y;}
   int min(int, int);
   void func(int i, char j)
   {
     min(i,j);
     min(j,i); //此时就不会出错
   }
   ```

  - - 重新定义函数体：就像一般的重载函数一样，重新定义一个完整的非模板函数，他可以带的参数可以随意。C++中，函数模板与同名的非模板函数重载时，应该遵循以下的原则：

    1. 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。
    2. 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。
    3. 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。
    4. 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用。





### 继承

- 继承的一个特性是,基类的引用可以可以指向派生类对象,而无需进行强制类型转换.这种特征的一个实际结果就是,可以定义一个接受基类引用作为参数的函数,调用该函数的时候,可以将基类对象作为参数,也可以将派生类对象作为参数.

