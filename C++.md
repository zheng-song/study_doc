[TOC]

# C++ primer plus

## 第八章 函数探幽

- 执行函数调用指令时,程序将会在函数调用之后立即存储该指令的内存地址,并将函数的参数复制到堆栈,跳到标记被调用的函数起点的内存单元,执行函数代码(也许还需要将返回值放入到寄存器或者堆栈中),然后跳回到地址被保存的指令处.这种函数调用是需要一定的开销的.
- C++ 内联:编译器会使用相应的函数代码替换函数调用(编译器不一定会满足内联要求,**编译器可能发现该函数过大,或者有递归调用,则会忽略内联请求;也有些编译器没有启用或实现这种特性.**).C++成为内联函数的方法有:

1. 在函数声明前加关键字inline.
2. 在函数定义前加关键字inline.

通常的做法是省略原型,将整个的定义放在本应提供原型的地方.



### 引用变量(&)

引用变量的主要用途是用作函数的参数.引用必须要在声明的时候初始化.而不能像指针那样,先申明再赋值.**C++中允许按引用传递允许被调用的函数能够访问调用函数中的变量(即使该变量是局部变量).**引入引用的主要目的是用于**结构和类**的传递,而不是基本的内置类型.

- **将引用作为返回值:**通常返回值机制将返回值复制到临时存储单元中,然后该临时返回存储单元的内容将会被复制到接收返回值的变量当中.然而,返回引用意味着调用程序将会直接访问返回值,而不需要拷贝.***返回引用时最重要的一点是,应该避免返回当函数终止时不再存在的内存单元的引用.即:***

```C++
const Type &clone(Type &a)
{
	Type tmp;
	tmp = a;
	return tmp;  //不应该出现这样的代码,因为该函数运行完之后tmp的内存不再存在,虽然程序能够通过编译(会有警告),但是执行时会崩溃.所以此时应返回const Type类型(复制返回),而不是const Type &类型.
}
```

该函数返回一个指向临时变量tmp的引用,函数运行完毕以后,他将不再存在.

- **为何将const用于引用返回类型:**使用const并不意味着Type类型本身为const,而是意味着你不能够使用返回引用来直接修改它指向的结构.

> ***将C-风格的字符串用作string对象的引用参数***
>
> `function("abcdef"); void function(const string &str){...};` C++的string类定义了一种char * 到string的转换功能,这使得可以使用C-风格字符串来初始化string对象.同事,对于const类型的引用有一个属性,假设实参的类型与形参不符,但是该实参可以被转换为引用类型,程序将会创建一个正确类型的临时变量,使用转换后的实参值来初始化它,然后传递一个指向该临时变量的引用.所以上面可以将char * 类型或者是const char *类型传递给const string &类型.



**什么时候使用引用?什么时候使用指针?什么时候使用按值传递?一些指导原则如下:**

对于使用传递的值而不作修改的函数:

- 若数据对象很小,如内置数据类型或小型结构,则按值传递
- 若数据对象是数组,则使用指针,因为这是唯一的选择.并将指针声明为const.
- 若数据对象是较大的结构,则使用const指针或者const引用,以提高程序的效率.
- 若数据对象是类对象,则使用const引用.类设计的语义常常要求使用引用,这是C++新增这一项的主要原因,因此,传递类对象的标准方式是按引用传递.

对于要修改调用函数中的数据的函数:

- 若数据对象是内置类型,则使用指针.
- 若数据对象是数组,则只能使用指针.
- 若数据对象是结构,则使用引用或指针
- 若数据对象是类对象,则使用引用.



### 默认参数

C++ 中设置函数的默认参数必须通过函数原型来实现.默认值必须从右向左添加,若要为某个参数设置默认值,则必须要为它右边的所有参数提供默认值.



### 函数重载

函数多态是C++的新功能,默认的参数能让你使用不同数目的参数调用同一个函数,而函数的多态(重载)能够让你使用多个同名的函数.可以通过重载来设计一系列的函数----他们完成相同的工作,但是使用不同的参数列表.C++使用上下文来确定要使用的重载函数版本.

- 函数重载的关键是函数的参数列表----也称为函数的特征标(function signature). 类型的引用和类型本身会被视为是同一种特征标.通过函数的类型并不能重载函数(即只有类型不同,其他都相同不是函数重载,而是错误).

> ***什么是名称修饰***
>
> C++ 使用**名称修饰(name decoration)**或者是**名称矫正(name mangling)**来跟踪每一个重载函数,他会根据函数原型中指定的形参类型对每一个函数名进行"加密",如`long func(int,float);`编译器会将名称转换为不太好看的内部表示,如下`?func@@YAXH@Z`,这样对原始名称进行的修饰将会对参数的数目和类型进行编码,添加的一组符号会随着函数的特征标而异,而修饰时使用的约定随编译器而异. 



### 函数模板

函数模板可以用来创建一个通用的函数，用以支持多种不同的形参，避免重载函数的函数体重复设计。它最大的特点是把函数使用的数据类型作为参数。声明形式为：

 ```C++
template<typename T>
T func(T x,int y)
{
  T x;
  //...
}
 ```

若主函数中有如下的调用语句

```C++
double b;
int a;
func(d,a);
```

那么系统将会使用实参d的数据类型double去替代函数模板中的T生成函数：

```c++
double func(double x, int y)
{
  double x;
  //...
}
```

函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况使用实参的数据类型来代替类型参数描述符之后，才能产生真正的函数。

> 关键字`typename`是后来才加入到C++中的,可以使用关键字`class`替代 ，这时数据类型参数标识符就可以使用所有的C++数据类型类型。typename关键字使得参数T表示类型这一点更为明显;如果需要将同一种算法用于不同类型的函数,请使用模板,如果不考虑向后兼容,则声明类型参数时,应该使用关键字typename而不是使用class.
>
> **注意:**模板函数并不能缩短可执行程序,使用模板最终生成的代码是由编译器帮你生成的,最终的代码不会包含有任何的模板,而只包含了程序生成的实际函数.使用模板的好处是,它使得生成多个函数的定义更为简单,可靠.



#### 函数模板的生成

函数模板的数据类型参数标识符实际上是一个类型参数，在使用函数模板的时候，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板参数，用模板实参实例化的函数称为模板函数。模板函数的生成就是讲模板函数的类型参数实例化的过程。

**注意：**

1. 函数模板允许使用多个类型参数，但是在template定义部分的每一个形参前必须有关键字typename或class，即：`template<class 标识符1,...,class 标识符n>`
2. 在template语句和函数模板定义语句 <返回值类型> 之间不允许有别的语句。即template语句之后要紧跟函数模板定义。
3. 如果C++编译器不是最新版本,则可能不支持模板.新版本可能支持用关键字typename代替class. 早期的g++版本要求将模板定义放在main()之前.

```C++
template<class T>
  int i;             // 这样定义是错误的，不能在template和函数模板之间有其他的语句
T min(T x, T y)
{
  //...
}
```

3. 模板函数类似于重载函数，但是两者有很大的区别：函数重载时，每一个函数体内可以执行不同的动作，但是同一个函数模板实例化后的函数都必须执行相同的动作。



#### 函数模板的异常处理

函数模板中的模板参数可以实例化为各种类型，但是当实例化模板参数的各模板参数之间不完全一致时，就可能发生错误，如：

```C++
template<typename T>
void min (T &x, T &y){return (x<y)?x:y;}
void func(int i, char j)
{
  min(i,i);
  min(j,j);
  min(i,j);
  min(j,i);//后两个调用是错误的，出错的原因是，在调用的时候，编译器按照最先遇到的实参的类型隐式的生成一个函数模板，并使用它对所有的模板函数进行一致性检查。
}
```

`min(i,j);` 先遇到的实参`i`是整型的，编译器就将模板形参解释为整形，此后出现的模板实参`j` 不能被解释为整型而产生错误，**此时没有隐含的类型转换功能。** 解决此种异常的方法有两种：

1. 采用强制类型转换：如将`min(i,j)` 转换为 `min(i,(int)j)` 

2. 用非模板函数重载模板函数：有两种实现方法。

   - 借用函数模板的函数体：

   ```C++
   //此时只声明非模板函数的原型，他的函数体借用模板函数的函数体，改写如下
   template<typename T>
   void min(T &x, T &y){return (x<y)?x:y;}
   int min(int, int);
   void func(int i, char j)
   {
     min(i,j);
     min(j,i); //此时就不会出错
   }
   ```

  - - 重新定义函数体：就像一般的重载函数一样，重新定义一个完整的非模板函数，他可以带的参数可以随意。C++中，函数模板与同名的非模板函数重载时，应该遵循以下的原则：

    1. 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。
    2. 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。
    3. 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。
    4. 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用。




#### 重载的模板

可以像重载常规函数定义一样重载模板定义, 和常规函数一样,被重载的模板的函数特征标必须不同.如:

```C++
template<typename T>
void Swap(T &a, T &b){
  //...
}

template<typename T>
void Swap(T &a, T &b,int c){
  //...
}
```






### 继承

- 继承的一个特性是,基类的引用可以可以指向派生类对象,而无需进行强制类型转换.这种特征的一个实际结果就是,可以定义一个接受基类引用作为参数的函数,调用该函数的时候,可以将基类对象作为参数,也可以将派生类对象作为参数.






## 第九章 内存模型和名称空间

> ***多个库的链接***
>
> C++ 允许每个编译器的设计人员以他认为合适的方式实现名称修饰,因此由不同的编译器创建的二进制模块很可能无法正常的链接.即----两个编译器将会为同一个函数生成不同的修饰名称.名称的不同将会使得连接器无法将编译器生成的函数调用与另外一个编译器生成的函数定义匹配.在链接编译模块的时候,要确保所有对象文件或者是库是由一个编译器生成的.如果有源代码,通常可以使用自己的编译器重新编译源代码来消除链接错误.

- 寄存器变量: 关键字register提醒编译器,用户希望它通过使用CPU寄存器,而不是堆栈来处理特定的变量,从而提供对变量的快速访问(CPU访问寄存器的速度比访问堆栈中的内存的速度快得多).但是编译器不一定会满足这种需求。现代编译器足够聪明，能够对程序自动的优化来使用或不使用寄存器变量。 如果变量被存储在寄存器中，则没有内存地址，因此不能够将地址操作符用于寄存器变量(即使编译器实际上并没有使用寄存器来存储变量)。
- volatile变量：即使程序的代码没有对内存单元进行修改，其值也有可能发生变化。
- mutable变量：即使结构(或类)变量为const，其某个成员也可以被修改，例如：

```C++
struct data{
  char name[30];
  mutable int accesses;
}

const data veep = {"hello",0};
strncpy(veep.name,"nihao",6); // 不允许
veep.accesses++; //允许 ，veep的const限定符禁止程序修改veep的数据，但是accesses成员的mutable修饰符使得其不受这种限制，而可以被修改。
```



- C++ 提供了作用于解析符(::),当放在变量或者是函数名称前时，表示使用的是变量或者函数的全局版本。



















颜色深度（Color Depth）用来度量图像中有多少颜色信息可用于显示或打印像素，其单位是“位（Bit）”，所以颜色深度有时也称为位深度。常用的颜色深度是1位、8位、24位和32位。1位有两个可能的数值：0或1。较大的颜色深度（每像素信息的位数更多）意味着数字图像具有较多的可用颜色和较精确的颜色表示。

因为一个1位的图像包含2种颜色，所以1位的图像最多可由两种颜色组成。在1位图像中，每个像素的颜色只能是黑或白；一个8位的图像包含256种颜色，或256级灰阶，每个像素可能是256种颜色中的任意一种；一个24位的图像包含1670万（2^24）种颜色；一个32位的图像包含2^32种颜色，但很少这样讲，这是因为32位的图像可能是一个具有Alpha通道的24位图像，也可能是CMYK色彩模式的图像，这两种情况下的图像都包含有4个8位的通道。图像色彩模式和色彩深度是相关联的（一个RGB图像和一个CMYK图像都可以是32位，但不总是这种情况）.