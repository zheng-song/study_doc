[TOC]

### 第八章 函数探幽

- 执行函数调用指令时,程序将会在函数调用之后立即存储该指令的内存地址,并将函数的参数复制到堆栈,跳到标记被调用的函数起点的内存单元,执行函数代码(也许还需要将返回值放入到寄存器或者堆栈中),然后跳回到地址被保存的指令处.这种函数调用是需要一定的开销的.
- C++ 内联:编译器会使用相应的函数代码替换函数调用(编译器不一定会满足内联要求,**编译器可能发现该函数过大,或者有递归调用,则会忽略内联请求;也有些编译器没有启用或实现这种特性.**).C++成为内联函数的方法有:

1. 在函数声明前加关键字inline.
2. 在函数定义前加关键字inline.

通常的做法是省略原型,将整个的定义放在本应提供原型的地方.



#### 引用变量(&)

引用变量的主要用途是用作函数的参数.引用必须要在声明的时候初始化.而不能像指针那样,先申明再赋值.**C++中允许按引用传递允许被调用的函数能够访问调用函数中的变量(即使该变量是局部变量).**引入引用的主要目的是用于**结构和类**的传递,而不是基本的内置类型.

- **将引用作为返回值:**通常返回值机制将返回值复制到临时存储单元中,然后该临时返回存储单元的内容将会被复制到接收返回值的变量当中.然而,返回引用意味着调用程序将会直接访问返回值,而不需要拷贝.***返回引用时最重要的一点是,应该避免返回当函数终止时不再存在的内存单元的引用.即:***

```C++
const Type &clone(Type &a)
{
	Type tmp;
	tmp = a;
	return tmp;  //不应该出现这样的代码,因为该函数运行完之后tmp的内存不再存在,虽然程序能够通过编译(会有警告),但是执行时会崩溃.所以此时应返回const Type类型(复制返回),而不是const Type &类型.
}
```

该函数返回一个指向临时变量tmp的引用,函数运行完毕以后,他将不再存在.

- **为何将const用于引用返回类型:**使用const并不意味着Type类型本身为const,而是意味着你不能够使用返回引用来直接修改它指向的结构.

> ***将C-风格的字符串用作string对象的引用参数***
>
> `function("abcdef"); void function(const string &str){...};` C++的string类定义了一种char * 到string的转换功能,这使得可以使用C-风格字符串来初始化string对象.同事,对于const类型的引用有一个属性,假设实参的类型与形参不符,但是该实参可以被转换为引用类型,程序将会创建一个正确类型的临时变量,使用转换后的实参值来初始化它,然后传递一个指向该临时变量的引用.所以上面可以将char * 类型或者是const char *类型传递给const string &类型.



**什么时候使用引用?什么时候使用指针?什么时候使用按值传递?一些指导原则如下:**

对于使用传递的值而不作修改的函数:

- 若数据对象很小,如内置数据类型或小型结构,则按值传递
- 若数据对象是数组,则使用指针,因为这是唯一的选择.并将指针声明为const.
- 若数据对象是较大的结构,则使用const指针或者const引用,以提高程序的效率.
- 若数据对象是类对象,则使用const引用.类设计的语义常常要求使用引用,这是C++新增这一项的主要原因,因此,传递类对象的标准方式是按引用传递.

对于要修改调用函数中的数据的函数:

- 若数据对象是内置类型,则使用指针.
- 若数据对象是数组,则只能使用指针.
- 若数据对象是结构,则使用引用或指针
- 若数据对象是类对象,则使用引用.



#### 默认参数

C++ 中设置函数的默认参数必须通过函数原型来实现.默认值必须从右向左添加,若要为某个参数设置默认值,则必须要为它右边的所有参数提供默认值.



#### 函数重载

函数多态是C++的新功能,默认的参数能让你使用不同数目的参数调用同一个函数,而函数的多态(重载)能够让你使用多个同名的函数.可以通过重载来设计一系列的函数----他们完成相同的工作,但是使用不同的参数列表.C++使用上下文来确定要使用的重载函数版本.

- 函数重载的关键是函数的参数列表----也称为函数的特征标(function signature). 类型的引用和类型本身会被视为是同一种特征标.通过函数的类型并不能重载函数(即只有类型不同,其他都相同不是函数重载,而是错误).

> ***什么是名称修饰***
>
> C++ 使用**名称修饰(name decoration)**或者是**名称矫正(name mangling)**来跟踪每一个重载函数,他会根据函数原型中指定的形参类型对每一个函数名进行"加密",如`long func(int,float);`编译器会将名称转换为不太好看的内部表示,如下`?func@@YAXH@Z`,这样对原始名称进行的修饰将会对参数的数目和类型进行编码,添加的一组符号会随着函数的特征标而异,而修饰时使用的约定随编译器而异. 



#### 函数模板





### 继承

- 继承的一个特性是,基类的引用可以可以指向派生类对象,而无需进行强制类型转换.这种特征的一个实际结果就是,可以定义一个接受基类引用作为参数的函数,调用该函数的时候,可以将基类对象作为参数,也可以将派生类对象作为参数.

