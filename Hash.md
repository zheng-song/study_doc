[TOC]

By Joe 2018/02/08

​	Hash: 用于将任意长度的输入(又叫预映射，pre-image)，通过散列算法，变换成固定长度的输出，该输出值就是散列值。这种转换是一种压缩映射，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一确定其输入。简单来说就是一种将任意长度的消息压缩到某一个固定长度的消息摘要的函数。

- 若结构中存在和 **关键字K** 相等的记录，则必定在 **f(K)** 的位置。对应关系 **f** 称为散列函数， 按这个事先建立的表称为散列表。
- 不同的关键字可能得到同一个散列地址，这种现象称为碰撞。具有相同的函数值的关键字对于该散列函数而言是 **同义词** .
- 若对于关键字集合中的任意一个关键字，经过 **散列函数** 映像到地址集合中任何一个地址的概率是相等的，那么称此类散列函数为 **均匀散列函数(Uniform Hash function)** 这就是使得关键字经过散列函数得到一个“随机的地址”，从而减少冲突。、

哈希算法的方式很多，在海量存储系统中主要是对文件名和路径进行哈希，决定数据的分布策略，主流使用的哈希算法有经典的[字符串哈希算法]()、[MD4]() 、[MD5]()、[SHA-1]()、[Davies-Meyer]()等。

​	

​	哈希映射的典型例子是[GHT](http://www3.cs.stonybrook.edu/~jgao/CSE370-spring07/ght-wsna2002.pdf)(Geographic hash table), 它采用基于属性的命名将感知数据属性集命名为 **事件** ，借助于对等系统的分布式哈希表思想，通过位置哈希函数GHT将 **事件** 名称映射为网络中的存放位置P，然后采用基于位置的路由协议将数据存储到位置P上。查询请求通过对查询 **事件** 进行哈希映射直接路由到相关的位置。具体过程如下：将 **事件** 作为键值K，通过哈希函数 **f(K)** 将键值映射为网络中心位置P，并且将数据对 **\<K,Data\>** 存储在邻近P的节点。同样，对于包含数据K的查询请求也路由到邻近P的节点去获取 **\<K,Data\>** 。为了避免节点故障造成数据丢失，可以采用结构化复制进行多点存储。其缺点是一种盲目的数据存取策略，如果数据产生的很频繁而查询请求稀少，则GHT的存储代价会很高。



​	构建索引是指在数据存储时建立索引，而查询访问可以通过索引获得数据，典型的代表是[DIM](https://cloudfront.escholarship.org/dist/prd/content/qt4x6723n2/qt4x6723n2.pdf)、[DIFS](https://cloudfront.escholarship.org/dist/prd/content/qt10k610k2/qt10k610k2.pdf)、[DIMENSIONS](https://classes.soe.ucsc.edu/cmpe259/Winter05/papers/ganesan-sensys03.pdf) . DIM不仅采用特殊性质的哈希函数来确定数据的存放位置，而且引入了数据库中的索引结构[k-d树](https://www.cnblogs.com/eyeszjwang/articles/2429382.html)来支持多维范围查询。DIFS采用位置哈希和层次索引，通过在各个节点当中建立特殊的类似于[四分树](https://baike.baidu.com/item/%E8%B1%A1%E9%99%90%E5%9B%9B%E5%88%86%E6%A0%91/9792199?fr=aladdin)的索引结构来支持高效的查询。DIMENSIONS利用数据压缩和索引技术，提供多分辨率的数据存储和访问。

> 数据和查询请求按照一定的规则路由是指数据不一定存储到某一些固定的节点，而是按照一定的路径来存储，而查询请求也按照一定的路径传播，只要这两条路径相交查询请求就能够得到反馈。这种思想最早起源于[Rumor](http://www8.cs.umu.se/kurser/5DV133/VT15/labbar/gruppuppgift/rumor_routing.pdf)路由协议，即生产者和消费者都在网络中随机游走，一旦两者的路径发生相交，就可以对路径进行修正和改进。

依据这种思想,一种最简单的策略是:生产者将数据沿着水平方向传播并且在经过的路径上保留副本,而消费者的查询请求沿着垂直方向传播,这样,在两条路径相交的节点上就能够获得相关数据.[Double  Ruling](http://www3.cs.stonybrook.edu/~jgao/paper/dbruling-journal.pdf)利用平面上点和球面上点存在一一映射以及球面上任意两个圆心为球心的球面大圆总会相交的性质来完成数据的存取，其中一个大圆代表生产者存储数据的轨迹，而另外一个大圆表示消费者传播查询请求的轨迹。





​	Hash函数的选择，针对字符串，整数，排列，具体有相应的hash方法。碰撞处理的方法，一种是open hashing，也称为拉链法；另外的一种就是closed hashing，也称为开地址法(opened addressing)。

	### 扩展

​	d-left hashing中的d是多个的意思。先了解一下2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算计算，得出两个地址`h1[key]`和`h2[key]`。这时需要检查T1中的`h1[key]`位置和T2中的`h2[key]`位置，哪一个位置已经存储的(有碰撞的)key更多，然后将新的key存储在负载较少的位置。如果两边一样多，比如两个位置都为空或者是都存储了相同的key个数，那么就把新的key存放在左边的T1子表当中，2-left即由此而来。在查找一个key时，必须要进行两次hash，同时查找两个位置。

​	以上的方法经常会用在**海量的数据处理当中**。



### 最快的Hash表算法[MPQ]

​	例：有一个庞大的字符串数组，然后给你一个单独的字符串，让你从这个字符串数组中查找是否有这个字符串。

1. 遍历: 可以实现，但是你交付这样的程序是会被辞退的。
2. 使用HashTable。

hash使得规模较小的数据类型(例如数字)能够指向其他较大的数据类型(通常是字符串)。在这种情况下，你可以在数组中先存储hash。然后在计算其他字符串的hash，并比计较他们的hash。通过字符串比较，若hash在数组内匹配到一个hash，则其存在。这就是所谓的索引查找，可以加快对于不同大小的数组和平均长度的字符串的搜索速度约100倍。

