一下内容摘自[基于USB通信设备类的虚拟串口研究与设计](http://xueshu.baidu.com/s?wd=paperuri%3A%289ffb3cb9136fb7c87979b108bc11fa0e%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http%3A%2F%2Fwenku.baidu.com%2Fview%2Fb625f3ca0c22590102029d2b.html&ie=utf-8&sc_us=4827041105237611123)

##												摘要

​	USB接口由于支持热插拔和标准统一等特点得到了广泛的应用，越来越多的电脑设备开始采用USB接口进行数据的传输，而如何在不改变现有应用软件的情况下，将设备移植到USB接口成为了人们研究的热点。

​	论文以USB通信设备类中的抽象控制模型为基础，研究了通信设备类以及实现虚拟设备的原理，设计并实现了基于通信设备类的虚拟串口驱动程序。

​	论文研究设计了基于通信设备类的虚拟串口驱动程序的结构和实现方案，程序主要由通信命令转换和数据传输两个部分组成，通信命令转换符合通信设备类中抽象控制模型的规范，数据传输部分对现有的虚拟串口的实现技术进行了改进。主要工作如下：

1. 研究了USB协议的请求和传输模式，分析了通信设备类实现虚拟设备的方案。
2. 给出了一种符合通信设备类中抽象控制模型的虚拟串口的实现方案。该方案提供了一种基于通信设备类开发虚拟设备的模板，对设计中的诸多问题进行了详细的说明，并改进了虚拟串口驱动程序中数据的处理流程。
3. 将改进后的数据处理流程应用于虚拟串口的实现当中，生成了一种机遇通信设备类的稳定、高速的虚拟串口。



## 第一章 绪论

​	本章首先介绍了在VxWorks进行USB转串口的研究背景及现实意义。然后在根据技术的实现方式分类介绍当前国内外对USB通信设备类以及虚拟串口的研究状况，最后介绍了项目的设计与实现的安排。具体分为三小节来组织。

### 1.1 论文的研究背景以及意义

​	USB[^1]  \(通用串行总线\)是用于电脑和外设进行数据交换的一种通用总线或接口,这种标准接口由于具有数据传输快、支持热插拔、通用性强、易于扩展、总线可给外设供电等特点，得到了广泛的应用。并且，这种标准的串口接口不仅仅在当前所有的接口当中都有使用，而且在嵌入式系统尤其是在移动设备中的应用也越来越广泛[^2]，在各种MP3/4、数码相机，手机和PSP等设备当中，USB接口也几乎成为了唯一的外部接口。信息产业部正式公布的“移动通信手持机充电器及接口技术要求和测试方法”通信行业标准明确了手机接口方面将参照USB的接口规范[^3]，目前市场上的手机多采用USB接口进行数据传输，USB接口已成为手机与数据传输的的“实际”标准。

​	然而越来越多的设备开始使用USB接口，对USB协议也是一个很大的挑战。一般在设计外设时，传输数据的接口与通讯协议是一一对应的，而由于接口的不同，不同外设使用的协议也不同。比如网线为RJ45接口，可传输基于TCP/IP等协议的数据；串口为RS232接口，可传输的数据遵循串口协议；打印机为并行接口，可传输符合打印机通信协议的数据。如果在不改变传输协议的情况下，将数据接口换为USB接口，必然不能正确的传输数据。而本文研究的USB通信设备类很好的解决了这个问题[^4]。

​	USB 通讯设备类协议CDC (Communication Devices Class Specification) 的技术可以将USB接口虚拟成不同的通讯设备接口。自从USB通信设备类规格发布以来，国外的软硬件公司都使用USB 通信设备类在USB上实现一些通讯接口的功能，如串口、ISDN[^5]、ATM[^6]和以太网[^7]等。比如，Microsoft 在WINDOWS XP版本上内置了基于通信设备类的RNDIS驱动，使得在WINXP下可以无缝的连接基于RNDIS的USB以太网接口设备。Linux在2.6以后的版本就缺省支持基于通信设备类的以太网接口(usbnet)与串口。本文研究了USB通信设备类，并给出了符合通信设备类中抽象控制模型规范的虚拟串口驱动程序的设计和实现。



### 1.2 国内外研究现状

​	USB和串口之间的转换实现，有硬件实现和软件实现两种。硬件实现一般需要设计专门的控制芯片。设备控制芯片分为通用设备控制器和专用设备控制器，通用设备控制器定位于某几类USB产品的编程应用；专用设备控制器，定位于某一个USB产品的应用。

​	国内外有很多商业上成熟的此类接口转换器，其重点都是放在虚拟串口设备的设计上，一个好的转接器需要设计一个能够列举出虚拟串口的驱动程序，在这种情况下，PC端的应用软件依然是针对RS-232串行端口进行编程的，外设也是以RS-232为数据通信通道，但是从PC到外设之间的物理连接却是使用的USB总线，其上的数据通信也是USB数据格式的。采用这种方式的好处在于:一方面可以保护原有的软件开发投入，并使得已有的针对RS-232外设的应用软件可以不加修改，便可以继续使用；另一方面就是USB总线的高传输速率和即插即用的特性得到了充分的利用。虚拟串口的用途最初都是用于串口转网络通信接口，也就是把对网口的操作映射为对串口的操作。由于原有的平台软件是哦通过电脑的串口收发数据，为了使得平台的软件不用改变工作方式，需要在电脑平台上安装虚拟串口驱动，通过虚拟串口驱动可以将硬件转换器从网络上传送来的数据重定向到一个虚拟串口上。这样，平台软件通过虚拟串口进行数据收发。

​	USB和串口之间的转换，还有一种实现是软件实现。这里的软件实现主要是指设计USB转串口的驱动程序。在USB中CDC子类成为规范之前，USB转串口驱动程序的实现各种各样，且基于特定的设备，通用性较差。USB中CDC子类抽象控制模型规范了虚拟串口实现的框架，增强了虚拟串口驱动程序的通用性。



### 1.3 论文的主要内容和组织结构

#### 1.3.1 研究目标

​	论文的目标是实现一个规范、高速、实用的虚拟串口驱动程序，具体如下：

1. 符合通信设备类当中的抽象控制模型的规范。只要USB设备的固件程序符合通信设备类规范，开发人员就可以使用本驱动程序或基于本驱动程序进行二次开发；
2. 速度高。**传输数据率接近USB设备的传输速度????**，时延小；
3. 使用方便。用户不需要重新开发应用程序，符合串口标准的应用程序均可以在本虚拟串口上进行数据传输。
4. 缩短开发时间。在开发基于通信设备类的驱动程序时，开发人员可以参考本驱动中的设计模型以及实现方法；
5. 给出通信设备类驱动程序的一般设计方法。基于本文中通信设备类驱动程序的设计模型，开发人员可以设计出模拟其他设备的虚拟接口。

#### 1.3.2 研究难点以及工作内容

​	USB通信设备类的研究目前尚未成熟，可以参考的资料文献和代码都比较少，更多的是依靠讨论得出方法，然后对该方法的可行度和可靠性进行试验。存在开发难度大，需要解决的问题多等困难。此外，驱动程序开发对操作系统的依赖性很高，需要对操作系统的相关细节了解透彻，但是微软的WindowsNT系列操作系统不开源，无法查证实现细节，这也加大了设计实现的难度。由于驱动程序运行在内核态，因此在用户态能用的很多标准函数都无法使用，需要重新查阅函数用法，驱动程序的开发不能像用户态程序一样方便地进行调试。程序设计的过程中还要非常注意内存的使用，如果发生内存使用错误，将导致BSOD（Blue Screen of Death，简称BSOD）发生，需在系统重启后分析出错时的内存核心镜像，根据错误码和相关参数来查找出错的原因。此外，设计虚拟串口驱动程序时需要考虑USB通信设备类中的诸多规范，这也使设计实现的过程中需要考虑的因素比较多，工作量较大。

​	论文工作的内容如下：

1. 阅读微软提供的驱动开发手册，查阅WindowsNT驱动开发相关的中英文书籍[^10][^11][^12][^13]，深入了解WindowsNT的内部运行机制，理解驱动程序开发的基于USB通信设备类的虚拟串口研究与设计原理，学习驱动开发的手段和步骤，对现有的驱动开发工具进行比较分析，选择适合的开发工具;
2. 分析并试用现有的通信设备类驱动程序，对各种通信设备类及虚拟串口的实现技术进行比较。针对现有虚拟串口驱动实现中的种种问题[^25]，采用通信设备类的抽象控制模型作为基础开发虚拟串口驱动框架； 
3. 研究通信设备类驱动程序设计需要解决的各种问题，分析比较了现有的解决方法，得出了与抽象控制模型更适合的解决方法；
4. 设计实现一个符合通信设备类中抽象控制模型的虚拟串口驱动程序，并将该驱动应用于某项目中。基于本驱动，实现手机端Microsoft ActiveSync软件同电脑端
5. ​

#### 1.3.3 论文的组织结构

论文首先介绍了国内外现有的虚拟串口实现技术的研究现状，并分析了各自的利弊。论述了基于通信设备类设计虚拟串口的优点，然后分析了WindowsNT系统驱动程序的层次结构。研究了驱动程序开发的理论知识，对驱动程序中的各种机制进行分析，设计了一套基于通信设备类中抽象控制模型的虚拟串口驱动程序实现方案。最后根据方案实现了该系统，并对其进行了测试。 

第一章，绪论。介绍了通信设备类和虚拟串口驱动程序的研究意义和国内外现状，给出了论文的工作内容以及创新点。 

第二章，USB通信设备类研究。分析了USB请求和传输模式，研究了通信设备类及抽象控制模型的规范和实现方法。 

第三章，Windows驱动程序架构。分析了Windows驱动程序中处理请求及传输数据的原理，研究了USB驱动程序的协议栈结构及虚拟串口驱动程序的特征。 

第四章，通信命令转换和数据高速传输的设计。设计了系统总体方案，针对各个模块给出了详细方案。 

第五章，通信命令转换和数据高速传输的实现。给出了虚拟串口驱动程序的加载及卸载模块、通行命令转换模块和数据高速传输模块的实现及其关键技术，并且对系统进行了测试。 

第六章，结束语。总结了论文所做的工作,阐述了论文后续研究的重点。

## 第二章 USB通信设备类的研究

​	本章对USB通信设备类进行了研究和分析。首先，总结了USB控制请求的种类，并分析了USB数据包及四种事务传输的方式；其次，重点研究了用于虚拟设备的USB通信设备类协议；最后，深入分析了抽象控制模型的消息和通知。

### 2.1 USB请求和传输模式

#### 2.1.1 USB控制请求

USB接口设备通过管道和HOST通信，在默认控制管道上接受并处理以下三种类型的请求[^14]： 

1. 标准请求。一共有11个标准请求，如得到设备描述、设置地址、得到配置描述等。所有USB设备均应支持这些请求。HOST通过标准请求来识别和配置设备。 
2. 类（class）请求。USB还定义了若干个子类，如HUB类、大容量存储器类等。不同的类又定义了若干类请求，该类设备应该支持这些类请求。设备所属类在设备描述符中可以得到。 
3. 厂商请求。这部分请求并不是USB规范定义的，而是设备生产商为了实现一定的功能而自己定义的请求。

#### 2.1.2 USB数据包以及事务传输

​	USB采用littleedian字节顺序，在总线上先传输一个字节的最低有效位，最后传输最高有效位，采用NRZI编码，若遇到连续的6个1要求进行为填充，即插入一个0。所有的USB包都由SYNC开始，高速包的SYNC宽度为32bit，全速/低速包的SYNC段长度为8bit。实际接收到的SYNC产度由于USB HUB的关系，可能会小于该值。 
​	USB数据包[^15]的格式如图所示。

![USB数据包的格式](https://upload-images.jianshu.io/upload_images/6128001-ad55f549d6db56be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	PID表征了数据包的类型，分为令牌(Token)、数据(Data)、握手(Handshacke)以及特殊包4大类，共16种类型的PID。

​	对于令牌包来说，PID之后是7位的地址和4位的端点号。令牌包没有数据域，以5位的CRC校验和结束。SOF是一类特殊的令牌包，PID后跟的是11位的帧编号。 	
​	对于数据包来说，PID之后直接跟数据域，数据域的长度为N字节，数据域后以16位的CRC校验和结束。握手包仅有PID域，没有数据也没有校验和。分离传输会用到一类特殊的包，Start-Split和Complete-Split包，格式如图所示。

![Start-Split和Complete-Splite包](https://upload-images.jianshu.io/upload_images/6128001-2655132d72971124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在Start-Split和Complete-Split包中主要指定了此次分离传输所在的HUB的地址和下行端口编号以及端点类型（控制、中断、批量、同步）。以及此次传输中数据包在整个数据中的位置（第一个包、中间的包、末尾的包）。

​	握手包包括ACK，NAK，STALL以及NYET四种，其中ACK表示肯定的应答，成功握手包握手包的数据传输；NAK表示否定的应答，失败的数据传输，要求重新传输；STALL表示功能错误或端点被设置了属性；NYET表示尚未准备好，要求等待。 

​	数据在USB总线上的传输以包为单位，包只能在帧内传输。高速USB总线的帧周期为125uS，全速以及低速USB总线的帧周期为1mS。帧的起始由一个特定的包（SOF包）表示，帧尾为EOF。EOF不是一个包，而是一种电平状态，EOF期间不允许有数据传输。虽然高速总线和全速低速总线的帧周期不一样，当时包中帧编号的增加速度是USB/USBSOF一样的，因为在高速USB系统中，SOF包中帧编号实际上取得是计数器的高11位，最低三位作为微帧编号没有使用，因此其帧编号的增加周期也为1 ms。 

​	图中一个方框表示一个Packet，灰色的包表示主机发出的包，白色的包表示Device发出的包。批量传输是可靠的传输，需要握手包来表明传输的结果。若数据量比较大，将采用多次批量事务传输来完成全部数据的传输，传输过程中数据包的PID按照DATA0-DATA1-DATA0-…的方式翻转，以保证发送端和接收端的同步。允许连续次以下的传输错误，会重试该传输，若成功则将错误次数计数器清零，否则累加该计数器。超过三次后，HOST认为该端点功能错误（STALL），放弃该端点的传输任务。USB协议定义了四种事务传输。

![事务传输(Transaction)的流程图](https://upload-images.jianshu.io/upload_images/6128001-ee22187c85f30e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 批量传输：一次批量传输(Transfer)由1次到多次批量事务传输(Transaction)组成。 发送端按照DATA0-DATA1-DATA0-…的顺序发送数据包，只有成功的事务传输才会导致PID翻转，也就是说发送端只有在接收到ACK后才会翻转PID，发送下一个数据包，否则会重试本次事务传输。同样，若在接收端发现接收到到的数据包不是按照此顺序翻转的，比如连续收到两个DATA0，那么接收端徨为第二个DATA0是前一个DATA0的重传。

- 控制传输：一次控制传输分为三（或两个）个阶段：建立（SETUP）、数据（DATA）（可能没有）以及状态（STATUS）。每个阶段都由一次或多次（数据阶段）事务传输组成。 

  ​	如图2.4所示为建立阶段的控制传输流程图。可以看出：与批量传输相比，在流程上并没有多大区别，区别只在于该事务传输发生的端点不同、支持的最大包长度不同、优先级不同等这样一些对用户来说透明的信息。 
  ​	建立阶段过后，可能会有数据阶段，这个阶段将会通过一次或多次控制传输事务，完成数据的传输。同样也会采用PID翻转的机制。建立阶段， Device只能返回包，或者不返回任何包。 
  ​	最后是状态阶段，通过一次方向与前一次相反的控制事务传输来表明传输的成功与否。如果成功会返回一个长度为0的数据包，否则返回NAK或STALL。如图2.5所示为整个控制传输的示意图。

- 中断传输：中断传输在流程上除不支持PING之外，其他的跟批量传输是一样的。他们之间的区别也仅在于事务传输发生的端点、支持的最大包长度、优先级等信息不同。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-064bb7ae36ec33d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-580c001ce5962c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-2fccc4cb70fe3cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	主机在排定中断传输任务时，会根据对应中断端点描述符中指定的查询间隔发起中断传输。中断传输有较高的优先级，仅次于同步传输。同样中断传输也采用PID翻转的机制来保证收发端数据同步。如图2.6所示为中断传输的流程图。

- 同步传输：同步传输[^16]是不可靠的传输，所以它没有握手包，也不支持PID翻转。主机在排定事务传输时，同步传输有最高的优先级。如图2.7所示为同步传输的流程图。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-68020a2b0a8b9323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2 通信设备类

#### 2.2.1 通信设备类

​	USB的CDC类是USB通信设备类(Communication Device Class)的简称。CDC类是USB组织定义的一类专门给各种通信设备(电信通信设备和中速网络通信设备)使用的USB子类[^17]。根据CDC类所针对通信设备的不同，CDC类又被分成以下不同的模型：USB传统纯电话业务(POTS)模型，USB ISDN模型和USB网络模型。其中，USB传统纯电话业务模型，有可分为直接线控制模型(Direct Line Control Model)，抽象控制模型(Abstract Control Model)和USB电话模型(USB Telephone Model)，如图2.8所示。本文所讨论的虚拟串口就属于USB传统纯电话业务模型下的抽象控制模型。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-977204c8c228519e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	通常一个CDC类又由两个接口子类组成通信接口类（Communication Interface Class）和数据接口类(Data Interface Class)。笔者主要通过通信接口类对设备进行管理和控制，而通过数据接口类传送数据。这两个接口子类占有不同数量和类型的终端点（Endpoints），如图2.9所示。对于前面所述的不同CDC类模型，其所对应的接口的终端点需求也是不同的。如所需要讨论的抽象控制模型对终端点的需求，通信接口类需要一个控制终端点（Control Endpoint）和一个可选的中断（Interrupt）型终端点，数据接口子类需要一个方向为输入（IN）的周期性（Isochronous）型终端点和一个方向为输出（OUT）的周期性型终端点。其中控制终端点主要用于USB设备的枚举和虚拟串口的波特率和数据类型（数据位数、停止位和起始位）设置的通信。输出方向的非同步终端点用于主机（Host）向从设备（Slave）发送数据，相当于传统物理串口中的TXD线（如果从单片机的角度看），输入方向的非同步终端点用于从设备向主机发送数据，相当于传统物理串口中的RXD线。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-351980426b1f98b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2.2.2 抽象控制类

​	抽象控制模型（ACM）可以消除老式调制解调器与USB设备间的“代沟”。为了支持以前开发且基于串口的应用程序，需要解决两个问题。第一个是，驱动程序需要支持先前的控制信号和状态变量，因为许多载波调试标准都依赖它们。由于这些依赖关系的存在，驱动程序需要开发一个模拟的调制解调器，它向USB HOST[^18]呈现一个抽象控制模型的通信类接口。为了实现这些功能，需要处理额外的请求和通知。 
​	第二个需要解决的问题是，消除先前调试解调器的设计与抽象控制模型在数据类接口上多通道通信的特征之间的差异。先前的调制解调器只对一个通道支持“AT”命令和数据传输。为了支持先前调试解调器的这个特性，设备需要支持设定通道个数限制的命令。 
​	枚举这类设备时，通信类接口仍然指定一个抽象控制模型，然而实际的控制信号会发生至数据类接口。为了描述这个特征，调用管理功能描述（Call Management Functional Descriptor）的D1位用于表示拥有这个特性。

​	为了支持这两种模式，基于通信类接口的调试控制模式(call control)和基于数据类接口的调试控制模式,并且能够在两个模式间自由转换，CDC提供了GetCommFeature()函数实现模式的设置以及转换。包括请求-抽象控制模型和通知-抽象控制模型两种，如下表所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-a0337ad6253a35f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	通信子类为抽象控制模型的通信类接口支持表2.1所示的这些与类相关的请求。一些没有列出来的与这些类相关的请求，比如SET_HOKK_STATE，不适用于抽象控制模型，并且发送这些请求时，会造成设备处于STALL状态。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-d8db7c7bf5098bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

通信子类为抽象控制模型的通信类接口支持表2.2所示的这些和类相关的通知。其他和类相关的通知，比如RING_DETECT，不适用于抽象控制模型，并且这种设备不能够发送这个信号。

请求-抽象控制模型中的请求分别描述如下： 

(1) SendEncapsulatedCommand请求 

​	这个请求用于发送一个支持控制协议格式的命令到通信类接口，如表2.3所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-3ded9b8246f552a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(2) GetEncapsulatedResonse请求 

​	这个请求用于获取通信类接口的信息，一个支持控制协议格式的命令用于指定获取的的信息类型，如表2.4所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-c071af6055e4fb94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(3) SetCommFeature请求 
​	这个请求用于设置与特定设备的某次通信中的状态，如表2.5所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-f650f9a2ccff58ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(4) GetCommFeature请求 
​	这个请求用于获取与特定设备的通信中的某些状态的值，如表2.6所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-959199f57bcd3263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



(5) GetCommFeature请求中可设置或获取的状态及代码如表2.7所示。  



### 2.3 本章小结

​	本章首先总结了三种USB控制请求的应用场景，分析了USB数据包的格式以及四种事务传输类型在USB传输中的作用。其次，分析了USB通信设备类在解决虚拟设备问题方面的优势，为本文的进一步研究奠定了基础。最后，研究了抽象控制模型的处理请求的流程以及注意事项，对虚拟串口驱动程序的设计有很好的指导作用。





## 第三章 Windows驱动程序框架

​	本章首先简要论述了Windows驱动程序的架构，概括了Windows驱动程序的分层结构，描述了驱动程序中常用的数据结构；然后介绍了USB的协议栈，并分析了虚拟串口驱动程序的特征。

### 3.1 Windows驱动程序框架

#### 3.1.1 分层结构

​	WindowsNT操作系统的驱动程序构架[19]为分层式，该系统也是分层构建的操作系统。即使磁盘的驱动程序全在一个源程序文件中，该驱动程序仍然被加载到驱动栈的某一层。WindowsNT系列操作系统通过调用特定的接口获得下层系统提供的服务，其体系结构如图2.1所示。除了I/O管理器，还包括Windows磁盘管理器（Windows Management Instrumentation，简称WMI），即插即用管理器（Plug and Play，简称PnP）和电源管理组件等。所有的组件中，最主要的是I/O管理器。它根据接收到的请求创建IRP，然后将该IRP以特定的顺序传递给驱动栈[30]。栈顶驱动根据IRP的内容，分为三种情况处理： 

1.  该层驱动能处理IRP。直接处理后设置IRP状态为处理完毕，然后将该IRP返回给I/O管理器； 

2.  该层驱动不能单独处理IRP。比如过滤驱动程序，驱动可能重新创建IRP将上层传递下来的IRP分多次传递到下层驱动完成，完成IRP以后由该层驱动设置IRP状态为处理完毕； 

3.  该层驱动无法处理IRP，直接传递到下层驱动处理。 

其余各层驱动的处理情况也类似。最底层的驱动可能直接调用硬件抽象层(Hardware Abstract Layer,简称HAL)接口完成I/O操作。

#### 3.1.2 I/O请求包

​	IPR(I/O请求包)即输入输出请求包是Windows内核中的一种数据结构[^20]。上层应用程序与底层驱动程序间进行通信的时候，应用程序会发出I/O请求，操作系统就将I/O请求转化为相应的IRP数据，不同的类型的IRP会根据类型传递道不同的派遣函数内。IRP是从系统非分页内存池中分配的一个数据结构，包含有一个固定大小的首部和一个可变大小的堆栈。

​	首部含有IRP自身的属性；返回状态、信息，定义了系统缓冲区、用户缓冲区。系统缓冲区指针指向的是一个位于内核模式的非分页内存中的数据缓冲区。对IRP的读操作和写操作，如果顶层设备指定buffer标志，则I/O管理器就会创建一个数据缓冲区。I/O管理器把用户模式程序发送给驱动程序的数据复制到缓冲区，这些数据可以与WriteFile调用有关数据，也可以是DeviceIoControl调用中的输入数据。对于读请求，驱动程序把读出的数据填到系统的缓冲区，I/O管理器再把缓冲区的内容复制到用户模式缓冲区。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-6df763f625c91293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

堆栈由一个或者是多个I/O单元组成，而且他们都采用IO_STACK_LOCATION结构，内部包含有I/O请求的函数代码和参数，I/O栈单元的个数等于该I/O请求的驱动程序的个数，或者说是驱动程序栈的层数，而且每层驱动程序只能够访问对应的I/O栈单元。

#### 3.1.3 IRP传递策略

​	IRP创建好了以后，可以调用IoGetNextIrpStackLocation函数获得IRP第一个堆栈单元的指针。I/O堆栈是一个IO_STACK_LOCATION结构数组，可以将这个指针初始化为一个不存在的元素，当需要初始化第一个堆栈单元的时候，需要给出下一个堆栈单元，初始化给出的堆栈单元。IRP中第一个堆栈单元指针被初始化为指向该堆栈单元之前的堆栈单元。IRP有三种处理情况：派遣函数立即完成IRP、排队IRP由驱动程序其他例程处理、传递到处于同一堆栈的下层驱动程序。

#### 3.1.4 派遣函数

​	驱动程序主要是用来处理I/O请求，而大部分I/O请求均在派遣函数中处理。用户模式下所有对驱动程序的I/O请求，全部由操作系统转化为IRP，不同的IRP会被第四章 接口转换器驱动模型分析与实现机制 27派遣到不同的派遣函数中，在派遣函数中IRP将得到处理。 

​	IRP有两个基本属性：MajorFunction，MinorFunction。分别记录IRP的主类型和子类型，操作系统根据MajorFunction将IRP派遣到不同的派遣函数中，在派遣函数中还可能继续判断MinorFunction()。 

​	WDM驱动程序的派遣函数都是在入口函数DriverEntry里注册的。通过设置 DriverEntry的驱动对象pDriverObject中的函数指针数组MajorFunction，可以将IRP的类型和派遣函数关联起来。 

​	IRP的处理类似于Win32中“消息”的处理方式，不同的IRP会被派遣到不同的派遣函数中进行处理，当没有对应的派遣函数时，将会进入到系统默认的派遣函数中进行处理。大部分的IRP都源于文件I/O处理Win32API，处理这些IRP可以在相应的派遣函数中就IRP的状态设置为成功，然后结束IRP请求，并返回成功。

#### 3.1.5 内存分配与管理

​	Windows中采用的虚拟内存使得系统可以使用比物理内存跟多的内存[^21]。虚 拟内存的实现方式如下：将每个应用程序的可能地址空间划分成固定大小的块，称之为页。页可以驻留在物理内存中，也可以交换到硬盘。设备驱动程序分配的内存通常有两两种：交换型的分页内存，永久驻留的非分页内存。当在线程调度或者更高终端级别访问分页内存时，就会引起缺页故障，造成内核崩溃。 

​	常规线程访问非驻留的分页内存，内核也会造成线程阻塞，直到内存管理器将所需访问的分页内存装回内存。因此，在设计驱动程序时，要注意两个方面的问题：一不能滥用非分页内存；二就是经常得使用非分页内存，在线程调度或更高级别的中断级访问内存时，必须调用非分页内存。当完成内存调用后，应当对所有类型的内存通过ExFreePool释放。如果不释放，将会导致内存减少，因为即使当驱动程序卸载后，内核也不会回收这些分配了的内存。

​	当频繁申请和回收内存时，会导致内存上产生大量的内存“空洞”，进而导致最终无法申请内存。因此，当驱动程序需要频繁地从内存中申请、回收固定大小的内存时，就必须解决“空洞”问题，DDK提供了一种机制就是使用Lookaside对象来解决。 

​	Lookaside对象可以被认为是一个内存容器。在初始的时候它先向Windows申请一块较大内存。以后需要申请内存的时候，直接向Lookaside对象申请内存，而不向Windows申请。Lookaside对象能智能地避免产生内存“空洞”。如果Lookaside对象内部的内存不够用时，就会向操作系统申请更多内存。当Lookaside内部有大量未使用的内存时，会自动让Windows回收部分内存。可以将Lookaside看成是一个自动的内存分配容器，对Lookaside对象申请内存的效率高于直接向Windows申请内存。 

​	Lookaside一般在每次申请固定大小的内存而且申请和回收的操作很频繁的情况下使用。



### 3.2 USB协议栈

#### 3.2.1 USB协议栈

​	USB的驱动栈[^22]是Windows操作系统的一部分，下图对它进行了说明。所有的驱动都嵌入在WDM的分层架构中。

​	USB驱动栈中各个模块的说明如图3.2所示。

​	USB主控制器是控制统一串行总线（USB）的硬件组成部分。它控制着连接它的USB根集线器。主控制器的实现有两种形式，一种形式是支持USB的全速模式，即Open Host Controller(OHC)和Universal Host Controller(UHC)。另外的一种实现形式支持USB高速模式，即Enhanced Host Controller(EHC)。

​	OpenHCI.sys是主控制器驱动它适用于符合Open Host Controller Interface 标准的控制器。这个驱动程序不是必须的，兼容UHCI或EHCI的控制器的驱动程序可以替换它，而这个驱动程序根据电脑的主板芯片组不同而不同。比如，Intel芯片组包含EHC和UHC。

​	USBD.SYS是USB总线驱动程序，它负责控制并管理总线上的所有USB设备。它是Windows操作系统的一部分，由微软提供。

​	USBHUB.SYS是USB集线器驱动程序。它负责管理和控制所有的USB集线器。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-7e9e9feed724f0c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	虚拟串口驱动程序是一个内核模式的驱动程序，它支持各种USB协议并能模拟出一个虚拟串口的COM端口。在操作系统中，供USB设备驱动程序访问USB外设的接口是USDBI(USB Driver Interface)。它位于USB驱动栈的最顶端。USBDI是一种基于IRP的接口，即每一个独立的请求被包装在一个IRP中。IRP是WDM模型中定义的数据结构。I/O请求包会被传输给USB驱动栈中的下层驱动进行处理，并在完成请求后将结果返回给调用者[^23]。

#### 3.2.2 虚拟串口驱动的特征

​	虚拟串口驱动支持USB的CDC-ACM协议。设计的虚拟串口驱动作为串口应用程序和USB外设之间的桥梁，具有如下特征：

1. **静态的设备点(Device Node)**

   ​	USB设备是个典型的即插即用设备，驱动程序在设备连接成功后加载并在设备移除时卸载。一个兼容支持即插即用功能的应用程序可以检测到设备的插入和移除并能够关闭和打开设备驱动程序的句柄。在设备移除的时候，不兼容即插即用功能的应用程序会产生错误。即使在设备重新连接到应用程序之后，设备驱动程序的句柄仍然为无效的句柄。此时，这类应用程序必须要先重启自己然后重新建立，才可能和支持即插即用的驱动进行通信。

   ​	虚拟串口的一个功能是支持先前不兼容即插即用功能的的应用程序。应用程序可以在设备被移除或重新连接后使用已经打开的句柄。修改驱动程序的INF文件可以设置这个功能。如果设置了这个功能，驱动程序的行为如下：

   - USB设备移除以后，设置CTS，DSR，RI，DCD信号设置为无效。如果应用程序正在等待某些事件，返回事件发生的信号。
   - 设备移除后，接收所有的类的请求，但是不发送这些请求到USB设备。
   - 读写请求加入读写IRP队列。超时后，返回超时状态并通知应用程序传输的字节数为0。
   - 设备重新连接后，串口的状态设置为默认的状态，串口的默认态存储在设备对象的驱动扩展中，并用事件通知应用程序当前的状态。如果USB设备的状态已更新，立即将此状态通知应用程序。
   - 读写模块启动，处理未完成的写操作，并返回读取到的数据至应用程序。

   如果USB设备从电脑移除，设备可能会丢失它当前的状态信息，而且，在USB设备移除的时候传输的数据也可能会丢失。设备移除之后的读写操作会在超时之后结束。如果这种情况发生，没有检测到USB设备已经移除的应用程序会产生错误。虚拟串口驱动程序启用了这个功能之后，如果设备没有连接到电脑，应用程序不能打开虚拟出的COM端口，并且在设备管理器当中没有虚拟COM端口节点。

2. **块传输**

   ​	虚拟COM端口模拟了真实的COM端口，它传输的数据是数据块而不是串口上的字节流。这会对串口API产生一些影响。传输到COM端口的数据块与传输到USB设备上的数据块没有直接的关系。电脑和PC设备间传输的数据在某些情况下需要传输一个短的数据包,比如： 

   - 传输的数据可以根据FIFO的大小分为几个小的数据包。
   - 传输的数据包长度小于INF文件中指定的读写缓冲的大小。
   - 完成某此数据传输后，没有需要立即传输的数据。

3. **流量控制**

   ​	==虚拟串口驱动程序中的流量控制使用了USB协议中规定的流量控制方法，而与串口应用程序设置的控制信号以及选择的流控方式无关==。如果连接到虚拟串口的应用程序没有读取数据或者是所有的输入缓冲区为满，电脑停止发送IN令牌。如果设备中的FIFO缓冲区为空，他会向电脑发送NAK令牌。电脑中的应用程序和设备中程序间传递的与设备相关的特殊信号只会作为数据传输，不会影响虚拟串口驱动程序的正常工作。

4. **循环缓冲区**

   ​	虚拟串口驱动程序为输入和输出数据各维护一个循环缓冲区。缓冲区的大小可以通过调用windows函数SetupComm()实现。如果循环缓冲区的大小被修改，缓冲区中的所有数据都会被清空。驱动程序设置了缓冲区的范围为128字节和128000字节之间，默认值为4096字节。循环缓冲区的大小会影响数据的传输速度，比如，在发送相同长度的数据时，一个小的缓冲区会增加发送的处理次数。

5. **数据传输**

   ​	应用程序打开COM端口后，驱动程序开始传输数据；应用程序关闭COM端口后，驱动程序结束传输数据。这样处理，驱动程序不会占用系统额外的带宽。

6. **启动初始化**

   ​	在应用程序打开COM端口时，驱动发送标准的USB请求清空端点的停止状态，清除总线上的错误并清理FIFO中的数据。应用程序也可以调用ClearFeatureOnStart()函数实现同样的功能，这个函数的定义在INF文件中说明。

7. **Overlapped模型**

   ​	如果应用程序打开串口时指定了overlapped模式，那么每个windows函数调用都可以返回状态吗ERROR_IO_PENDING。Windows操作系统允许驱动支持这种模式，不过每个串口驱动程序的实现方式可能不同，因此应用程序需要以正确的方式调用windows函数。

8. **加强的错误恢复**

   ​	主机和USB外设之间的数据传输通过循环冗余校验码保证正确性。如果一个传输失败，主控制器会重试3次。如果传输了3次之后仍然传输失败，主控制器通知操作系统这个错误，让他启动错误处理流程。加强的错误恢复是指处理错误的时候不丢失数据。为了实现加强的错误恢复功能。这个长度标志不限制数据传输的长度，也不限制主机一致发送这个长度的数据包。它是指在数据传输的时候发生了硬件错误之后，需要重传的数据块的长度。重传缓冲区的长度必须为USB端点的整数倍。为了确定这个长度的大小，需要考虑两个方面的因素。首先，设备必须为每一个端口以及方向都提供足够的空间用作重传缓冲区。其次，如果重传缓冲区太大，设备会需要更多的空间；如果缓冲区太小，数据传输的效率会明显的下降。

   ​	设置了重传缓冲区后，数据操作时如何实现呢？主机发送一个长度为重传缓冲区大小的数据，这些数据块被处理为FIFO的大小的数据块，分几次发送。如果最后的数据块正确的传输到设备当中，设备把这些数据返回给设备中的程序。如果主机发送了小于重传缓冲区长度的数据设备会检测到这是一个短包。这种情况下，重传缓冲区中接收到的数据会返回给设备中的程序。主机端的驱动程序也是如此处理数据的。最重要的一点是，设备在最后一个数据块成功的传输之前需要存储重传缓冲区中的数据。

   ​	错误恢复功能在传输数据时发送硬件错误后发挥作用。比如，主机向设备发送数据时发生了错误。驱动程序检测到了这个错误，它向设备发送丢弃重传缓冲区数据的命令(DiscardRetryBuffer)。设备收到DiscardRetryBufer命令之后，清空重传缓冲区中的数据并设置重传缓冲区的数据量为0。驱动从重传缓冲区的起始位置重传数据。在设备向主机发送数据时的处理方式一样。

### 3.3 本章小结

​	本章首先对Windows驱动程序的分层结构进行了介绍，重点介绍了在分层结构当中处理用户请求的流程。其次，分别介绍了I/O请求包、IRP传递策略、派遣函数和内存分配与管理等重要概念，为本文的设计和实现奠定了基础。最后，研究了分层结构中的USB协议栈以及虚拟串口驱动的特征。



## 第四章 通信命令转换和数据高速传输的设计

​	本章设计了符合通信设备类中抽象数据模型的虚拟串口驱动程序结构，并以此为核心研究设计了虚拟串口通信命令转换和高速数据传输两个主要的模块，给出了两个模块的功能实现方案。

### 4.1 串口和USB间通信命令转换的设计

#### 4.1.1 通信设备类中的USB请求处理

​	通信设备类的抽象数据模型对USB请求的处理基于一般USB驱动对USB请求的处理[^24]。在USB传输系统有主机系统和USB设备等组成。传输事务的发起端为主机，设备作为接受端相应主机发起的事务。主机系统一般采用分层的结构，其层次结构如图4.1所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-e7f384e06505a297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	USB总线接口包括USB主控制器和根集线器，其中USB主控制器负责处理主机与设备之间电气和协议层的互连，根集线器提供USB设备连接点。USB系统使用USB主控制器来管理主机和USB设备之间的数据传输，另外它也负责管理USB资源,如带宽等。应用软件不能直接访问USB设备硬件，而通过USB系统和USB总线接口与USB设备进行交互。

​	USB设备包含一些向主机软件提供一系列USB设备的特征和能力的信息的设备描述符，用来配置设备和定位USB设备驱动程序。这些信息确保了主机以正确的方式访问设备。通常，一个设备有一个或者是多个配置(Configuration)来控制其行为。配置是接口(Interface)的集合，接口指出软件应该如何访问硬件。接口又是端点(endpoint)的集合，每一个与USB交换数据的硬件就为端点，它是作为通信管道的一个终点。图4.2显示了一个多层次结构的通信模型，它表明了端点和管道所扮演的角色。

​	对于USB设备来说，其WDM驱动程序分为USB底层（总线）驱动程序和USB功能(设备)驱动程序。USB驱动程序符合Windows 2000下的内核模式驱动程序的分层体系结构，如图2所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-502d3b018269daf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	USB底层驱动程序由操作系统提供，负责与实际的硬件打交道，实现繁琐的底层通信。USB功能驱动程序由设备开发者编写，不对实际的硬件进行操作，而是通过向USB底层驱动程序发送包含URB(USB Request Block,USB请求块)的IRP，来实现对USB设备信息的发送和接收。采用这种分层驱动程序的设计方法有两个优点：多个USB设备可以通过USB底层驱动程序来协调它们的工作；编写分层驱动程序较之编写单一驱动程序相对简单，且可以节省内存和资源，不易出错。

​	USB驱动程序工作简述如下：当应用程序想对USB设备进行I/O操作，它需调用Windows API函数，I/O管理器将此请求构造成一个合适的I/O请求包（IRP）并把它传递给USB功能驱动程序。USB功能驱动程序接收到这个IRP后，根据IPR中包含的具体操作代码构造相应USB请求块（URB），并把此URB放到一个新的IRP中，然后把它传递给USB底层驱动程序。USB底层驱动程序根据IRP中所含的URB执行相应的操作，并把操作的结果返回给USB功能驱动程序。USB功能驱动程序接收到此返回的IRP后，将操作结果通过IRP返还给I/O管理器，最后I/O管理器将此IRP操作结果传回给应用程序，至此应用程序对设备的一次I/O操作完成。

#### 4.1.2 串口请求控制码处理流程

​	驱动开发需要硬件设备对上层的应用程序展现为虚拟串口。主要的功能是沟通上层应用程序和底层的USB设备，起到一个数据流的桥接作用。而且能够控制USB芯片，操作连接USB的模块完成数据收发的功能。

​	具体的设计为创建一个虚拟串口设备，然后由应用程序连接该串口，由于串口需要涉及到其特有的控制码IOCTL，所以USB-Serial驱动需要将这些控制码进行处理，并转换为相应的USB设备请求。并将转换之后的请求发送给USB设备。然后将USB设备的处理结果保存到虚拟串口驱动的缓冲区，由应用程序调用ReadFile获取返回结果。由于USB设备与串口设备的差异，驱动需要在设备加载时获取USB设备的各种描述符，根据上层需要选择合适的配置信息，这样才可以根据接收到的控制码控制USB外设的状态和数据接收。

​	应用程序通过PurgeComm(),GetCommState()等windows API函数操作串口，而这些串口最终由系统解析为响应的控制码，并将这些控制码发送给USB-Serial驱动，虚拟串口驱动虚拟出来的串口要和真实串口一样支持常用的串口操作，因此驱动在正确地处理这些控制码所表示的控制命令的情况下就可保证模拟出的虚拟串口与实际串口具有相同的特征。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-05da7e316aa19ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 4.2 数据高速传输的设计

#### 4.2.1 一般虚拟串口驱动数据处理方式

​	串口读写数据的一般流程为：串口应用程序首先通过调用CreateFile打开虚拟驱动程序虚拟出的串口设备，获得串口的句柄，然后通过调用writeFile把需要向串口写入数据的发送至虚拟串口。虚拟串口在接收到数据之后，会根据数据包的大小以及串口当前所设置的奇偶校验位以及停止位设置适当的包长度以及格式，然后再将数据依次发送出去。

​	一般虚拟串口驱动程序的数据处理流程有以下几个可改进之处：

1. 发送的数据包中含有奇偶校验位，停止位等信息。串口读取数据的一般流程在处理数据的时候，会模拟真实的串口，并根据串口的设置添加奇偶校验位和停止位等，将数据分为较小的字节（比如8字节），然后分次发送出去。这样处理，主要是为了保证数据的正确性。即接受的数据流是发送端发送的数据流，并且数据流的先后顺序是正确的。然而下层设备为USB设备时，USB驱动程序再从USB外设获取数据时是可以保证数据的准确性和完整性及顺序的正确性的。因此在虚拟串口驱动对数据增加停止位及奇偶校验位的方法可以忽略掉。一般虚拟串口与改进后的虚拟串口发送数据包的对比图如下：


![图片.png](https://upload-images.jianshu.io/upload_images/6128001-9ca688e781070d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. 一般虚拟串口驱动程序与下层驱动以及USB设备进行数据交换的方式

一般的虚拟串口在同下层驱动或者是USB设备进行数据交换的时候，会先开辟一段可以容纳应用层数据包的缓冲区，先将应用层的数据包拷贝到这个缓冲区，然后在根据串口包的一般长度(比如8字节)将缓冲区分为若干个小包，然后循环地单次发送这些小包，待所有的数据包都发送完成之后，再将当前的发送情况返回给应用程序。

​	在接收数据的时候，虚拟串口驱动程序会先开辟一段缓冲区用于接收数据如果接收到的数据大于这个长度，则分次接收，待接收完成所有的数据之后，再将这些数据一次性的返回给串口应用程序。

​	虚拟串口应用程序在读写数据的时候，将单次读写的数据长度设置为8字节，会严重的影响数据的传输速度。USB外设一次可以接受和读取的数据长度由USB外设的最大包长度决定。对于USB外设，这个包长度远远大于8字节。如果对于长度为1024字节的数据包，单次发送的数据长度为8字节的时候，虚拟串口驱动程序需要发送128次，而如果单次发送数据位1024字节(USB 2.0芯片的最大包长度一般均为1024字节)时，只需要发送1次。在只考虑发送次数的情况下，数据传输的速度就可以提高128倍（单次传输数据长度由8字节换为1024字节后）。因此提高单次传输数据长度为USB外设额最大包长度会极高的提高传输速度。



3. 一般虚拟串口驱动程序与应用程序进行数据交换的方式

一般虚拟串口驱动程序在处理应用程序发送给它的数据以及由下层或者是USB外设获取的数据时，对数据进行了不必要的拷贝操作。一般的虚拟串口驱动程序在处理应用程序发送给它的数据时，会先拷贝这些数据到驱动加载的时候创建的专用缓冲区中，然后再次分发这些数据。分析发送数据的流程，这个拷贝是可以省略掉的。应用程序发送给虚拟串口的数据，虚拟串口可以将它们直接发送到下层驱动或者是USB外设，而不用先拷贝，再发送。然而应用程序发送给虚拟串口的数据处于用户态，如果在核心态(以及虚拟串口驱动程序当中)使用的话，需要先将数据锁存在内核态，然后再发送。一般的虚拟串口以及改进后虚拟串口与应用程序进行交换的对比图如下:

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-f9dbdc472755db79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 4.2.2 高速传输数据流程的设计

​	一般虚拟穿串口驱动程序中对数据处理过慢的缺陷是影响数据传输的关键因数。减少奇偶检验位，停止位等用于验证数据正确性的设置，可以减少驱动中数据处理的流程，从而缩短数据传输的时间。增加单次串口驱动程序向下层驱动或者是USB外设发送数据的数据包长度可以减少同下层驱动或者是USB外设交互的次数，从而缩短数据传输的时间。在与应用程序进行交互的时候，不建立用于缓存应用程序数据的缓冲区，而是直接锁存应用程序发送下来的数据，然后分批次发送至下层驱动或者是USB外设。

​	串口驱动程序在接收到由串口应用程序传输过来的数据之后，不再添加奇偶校验验位，停止位等信息；在从下层驱动或USB外设读取到信息后，不再解析数据流获取真实传输数据的操作，而所接收到的数据即原始数据。虚拟串口驱动程序只需将其直接返回给当前正在读取数据的串口应用程序。

​	增加单次串口驱动程序向下层驱动及USB外设发送数据的数据包长度。 增大单次向下层驱动或USB外设发送的数据长度后，将会减少虚拟串口驱动程序调用下层驱动发送数据的次数。如果单次发送的数据长度大于应用程序向USB外设发送的数据长度，则在一次对下层驱动或USB外设的数据传输工程中即可完成数据的传输。如果单次发送的数据长度小于应用程序向USB外设发送的数据长度，则应用程序向USB外设发送的数据必须被分为若干块进行发送。因此，虚拟串口驱动程序必须首先获取应用程序传递下来的数据长度，根据数据包的长度决定单次向下层驱动或USB外设发送的数据包大小。

​	在对应用程序传递给虚拟串口驱动程序的包分片后发送的情况下，后面的数据分片必须要迟于前面的数据分片发送。因此，为了保证数据的顺序性，必须要等待前面的数据发送完成后再发送后面的数据。如果前面的数据发送失败，则可以再次发送前面的数据，或者返回当前已发送出的数据长度，并终止本次发送。

​	保证数据的顺序性，可以采用驱动程序中的完成例程来实现。完成例程可以帮助你了解下层驱动对某个I/O请求的处理结果。完成例程可以用在虚拟串口驱动程序中用于获取数据发送至下层驱动或USB外设的情况。要使用完成例程，一般有三个步骤：

​	(1) 调用内核函数IoCopyCurrentIrpStackLocationToNext()，将当前IRP的堆栈单元拷贝至下层驱动，以方便下层驱动对数据进行处理。 
​	(2) 调用内核函数IoSetCompletionRoutine()，为当前的IRP设置完成例程。在为当前IRP设置好完成例程后，下层驱动程序或USB外设完成数据传输或数据传输出错后，系统会查看在当前的IRP在虚拟串口驱动程序中有无指定完成例程，如果有，则会执行指定的完成例程，如果没有，则返回数据给上层驱动程序或应用程序。在调用IoSetCompletionRoutine()时指定的完成例程中，虚拟串口驱动程序会判断本次数据传输的情况，如果数据传输成功，则继续从锁存的缓冲区中获取后续数据，并将这些数据发送至下层驱动或USB外设，直至所有的数据发送完成后，再返回成功状态至串口应用程序。 
​	(3) 调用内核函数IoCallDriver()，将当前的IRP发送至下层驱动或USB外设。虚拟串口驱动会在通过IoSetCompletionRoutine()设置的完成例程中获取数据的发送或接收情况。 
串口驱动程序发送给虚拟串口驱动的数据，首先会被I/O管理器映射至核心态，即驱动程序可以在核心态访问这些数据。由于windows系统中对内存的管理采用了虚拟内存的技术，即用户使用的地址空间只是虚拟存在的，并不一定在物理内存中占有一段空间，它也有可能因为没有被及时访问而替换出物理内存。如果被替换出物理内存后，驱动程序在核心态通过核心态地址访问这些数据时，会获取到错误的数据。因为这个地址中的数据已经被替换成其他程序使用的数据了。为了防止这种情况的发生，虚拟串口驱动程序在获取到应用程序发送下来的数据之后，必须要首先锁存数据，以防再次读取这些数据时出现错误。

​	在虚拟串口驱动获取到数据之后，需要先调用内核函数IoAllocateMdl()来创建一个描述用户缓冲区的MDL。这个函数通过一个独立的MDL来映射缓存的一小部分，或者映射驱动分配的内存。驱动会调用MmBuildMdlForNonPagedPool()来设置MDL的内存，使得MDL描述驱动分配的缓存处于不可置换的内存中。MmProbeAndLockPages函数校验那个数据缓冲区是否有效，是否可以按适当模式访问。如果我们向设备写数据，我们必须能读缓冲区。如果我们从设备读数据，我们必须能写缓冲区。另外，该函数锁定了包含数据缓冲区的物理内存页，并在MDL的后面填写了页号数组。在效果上，一个锁定的内存页将成为非分页内存池的一部分，直到所有对该页内存加锁的调用者都对其解了锁。

​	驱动程序在对数据进行了锁存以后，再调用内核函数将数据发送到USB设备。

### 4.3 本章小结

​	本章设计了基于通信设备类的虚拟串口驱动程序的实现。首先，结合抽象控制模型对虚拟串口驱动程序的规范要求，给出了串口和USB之间通信命令转换的处理方法。然后，分析了一般虚拟串口驱动程序中数据处理的方式，给出了一种改进的数据传输流程。



## 第五章 通信命令转换和数据高速传输的实现

​	本章首先给出了虚拟串口驱动在加载和卸载时的处理方法，然后分别介绍了支持通信设备类中抽象数据模型的串口通信命令及用户自定义命令的处理细节，最后根据通信设备类中抽象数据模型对传输的要求，详细描述了的数据高速发送模块和接收模块的实现流程，并对驱动进行了测试。

### 5.1 虚拟串口驱动的加载和卸载模块

​	驱动程序的加载模块用于在虚拟串口设备加载及数据传输前完成设备的初始化和数据通路的准备工作。卸载模块用于在传输结束后或设备卸载时完成设备资源的释放及数据通路的清理操作。

#### 5.1.1 虚拟串口驱动的加载模块

​	虚拟串口驱动程序采用了WDM（Windows Driver Model），即“视窗驱动程序模块”技术。Windows驱动程序模型(Windows Driver Model，WDM)是Windows98和Windows2000使用的新的驱动程序设计规范。它是Win32驱动程序模型，也是Microsoft力推的全新驱动程序模式，旨在通过提供一种灵活的方式来简化驱动程序的开发，在实现对新硬件支持的基础上减少并降低所必须开发的驱动程序的数量和复杂性[^25]。

​	使用WDM使得硬件驱动程序更加稳定，让操作系统对硬件更加有效地控制硬件。基本上，WDM规范依靠一个标准化的类驱动程序来控制一类硬件的最常用和基本的功能。Windows2000为每一类硬件包括一个本地类驱动程序，然后，对应于某个特定厂商或者硬件型号的迷你驱动程序加入在类驱动中未包括的特殊或定制功能。厂商还可以更进一步地加入过滤器驱动程序来提供在类驱动的上层或底层进行的微调特性，以此来提供驱动程序本身和由硬件设备执行的任务最大的效率。在绝大多数情况下，这种设计将得到各方面均兼容于Windows2000的驱动程序，提供更好的性能，消耗更少的系统资源，并且对驱动程序大小的缩减经常达到90%。注意此处大小指的只是厂商/型号特定驱动程序，而不包括本地类驱动程序。除了定义一个驱动程序与操作系统连接的标准接口以外，WDM也指明了驱动程序应该采用的更加模块化的设计。WDM采用了模块化分层技术，它只构建一般驱动程序的结构，并将驱动程序分层处理，不同层的驱动程序处理不同的数据，各层驱动根据所处的层对数据进行不同的处理[^26]。



​	在虚拟驱动加载时，有两种情况。

- 第一种情况为当设备插入电脑的USB的接口时。此时windows的设备管理器会枚举USB设备，根据设备的类型查找合适的驱动程序，然后调用驱动程序的入口函数DriverEntry中指定的与此驱动对象相关的设备扩展中的AddDevice函数指针指向的函数，即DriverObject->DriverExtension->AddDevice指向的函数。在虚拟串口驱动中，DriverObject->DriverExtension->AddDevice指向的函数为USB2COM_PnPAddDevice函数，此函数完成USB外设的加载过程，它的流程图如图5.1所示。虚拟串口驱动程序设置虚拟设备的设备名为Device\Serial+n的形式，其中n为大于0的整数。由于其他驱动程序可能已经创建了类似设备名得设备，因此此函数在创建设备前需找到一个未被使用的设备名。此函数首先枚举当前所有正在使用的且以Device\Serial作为前缀的设备名，直到找到n，且满足没有以Device\Serial+n作为设备名的设备为止。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-6d3ec467356ffd39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	查找到合适的设备名之后，就可以通过调用内核函数IoCreateDevice创建设备。内核函数IoCreateDevice在因为某种情况调用失败后，它会返回一个错误码，但是它并不会干涉功能设备对象的属性。当IoCreateDevice调用成功以后，他会返回一个成功码，此时功能设备的指针会被设置。在创建好对象以后。需要清空设备扩展，并设置一些域的值，这些域即新的设备对象的一些属性和特征。如果在设置设备扩展中的域时出现了错误，则需要释放刚才创建的设备对象，并返回错误的原因。

​	KeInitializeEvent用于初始化事件对象，事件对象阻塞一个线程直到其它线程检测到某事件发生。为了初始化一个事件对象，首先应该为其分配非分页存储，然后调用KeInitializeEvent内核函数。调用时需要的参数为事件对象的地址，事件类型以及事件的初始状态三个参数。事件类型可以为NotificationEvent或者是SynchronizationEvent中之一。通知事件类型的事件对象在进入信号态后，将会一直处于信号态直到程序中某处调用函数将它设置为非信号态。而且，当通知类型的事件对象在进入信号态之后，在这个事件上等待的所有线程都会被释放。应用程序中的手动重置事件也是这个道理。对于同步类型的事件对象，只要有一个线程被释放掉，这个事件就转为非信号态。这和应用程序中的自动重置事件是一样的。KeWaitXxx内核函数在同步类型的事件对象上会执行一些其他的动作，比如把这个内核同步对象设置为非信号态。第三个参数为事件的初始状态，如果为FALSE则表示内核事件对象的的状态为非信号态，为TRUE表示此事件的初始状态为信号态。

​	在PnPAddDevice中KeInitializeEvent内核函数初始化了removeEvent，SelfRequestedPowerIrpEvent，NoPendingIoEvent三个内核事件对象。其中，removeEvent用于指示是否发生了USB外设突然从电脑的USB插座移除的事件，数据传输前需要判断，否则会造成数据传输超时的问题。SelfRequestedPowerIrpEvent用于指示是否出现了用户自定义的电源管理IRP，它区别于设备管理器发送的电源管理IRP。NoPendingIoEvent用于指示是否有读取或写入的IRP还没有处理完毕，及数据传输还没有结束。

​	KeInitializeSpinLock用于初始化自旋锁，自旋锁可以解决多CPU上代码运行的同步问题，当然在单CPU上也可以用来解决代码同步问题。在使用一个自旋锁之前，首先需要在非分页内存中为一个KSPIN_LOCK对象分配存储空间。然后调用KeInitializeSpinLock初始化这个对象。然后，当代码运行在低于或等于DISPATCH_LEVEL级上时获取这个锁，并执行需要保护的代码，最后释放自旋锁。这样某些会被多个线程访问到的数据，就可以顺序的被访问从而保证了各线程获取到的数据的正确性。 
​	在PnPAddDevic中KeInitializeSpinLock内核函数初始化了IoCountSpinLock，OutputBufferLock和ReadQueueSpinLock三个自旋锁。其中，IoCountSpinLock用于设备中各例程再访问IRP计数时不出现错误。OutputBufferLock用于保护写入USB外设中数据不能同时被多个例程或线程访问。ReadQueueSpinLock用于保护从USB外设中读取到的数据在虚拟串口中进行处理时不出现多例程或线程访问的情况。

​	第二种情况为串口应用程序通过调用windows API函数CreateFile()打开虚拟串口时，虚拟串口驱动会创建相应的设备对象，其流程图如图5.2。 
​	此时，设备管理器会调用驱动加载时驱动对象中MajorFunction数组中指定的IRP_MJ_CREATE对应的创建设备对象的USB2SER_Create函数。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-df6d8a9477e7c7cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	USB2SER_Create函数首先通过调用IncrementIoCount()增加当前设备正在处理的IRP的个数。然后通过调用CanAcceptIoRequests()判断驱动设备是否可以处理新的IRP，即IO请求。驱动程序在一些特定情况下是不能处理新的IO请求的。在设备被移除后，设备对象可能还没有被从内存中清除，这时如果不判断设备是否被移除而直接处理IO请求会产生内核错误，直至蓝屏。在处理IO请求之前，也要判断设备是否已经被启动，对未启动的设备进行IO操作也会造成内核错误。设备在启动之后，也会由于某些原因停止但设备对象依然存在的情况，因此也要判断设备是否已经停止运行。如果操作系统用户主动执行了移除USB外设的操作，设备管理器会向USB外设发送一个移除请求，如果设备此时有正在进行传输的操作，则移除请求会处于等待状态，此时也不可以处理IO请求，因此也要判断是否有处于等待状态的移除请求。操作系统用户也有可能在某些时刻停止设备的运行，此时也不可以处理IO请求，因此也要判断是否有处于等待状态的停止设备请求。这些特殊情况的判断都是通过CanAcceptIoRequests()来执行的，如果有一项复合条件，则CanAcceptIoRequests()会返回FALSE。因此在USB2SER_Create只需判断CanAcceptIoRequests()的值即可获取此设备对象是否可以处理IO请求的信息。USB2SER_Create函数的流程图如图5.3所示。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-55668cd46596ff6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	虚拟串口驱动程序会建立输入缓冲区用于缓存从USB外设中读取的数据，这个缓冲区的大小会在创建驱动对象时指定，而这个缓冲区的初始化则是在创建设备对象时通过调用ResetInputBuffer()执行的。虚拟串口驱动程序会根据USB外设的配置创建用于从USB外设读取数据的IRP以及向USB外设写入数据的IRP。函数StartReadIntUrb()用于创建一个从USB外设读取数据的IRP，此IRP会不间断的从USB外设读取数据，然后将读取到的数据置于设备对象的输入缓冲区(InputBuffer)中,待返回给应用程序。函数PrepareWriteIntUrb()用于创建向USB外设写入数据的IRP，再向USB外设写入数据时，调用相关的函数即可。最后，需要设置设备对象中设备扩展域的PipeOpened状态为TURE，表示用于传输数据的管道已经打开，可以进行数据传输了。

​	在虚拟串口设备加载之前，虚拟串口驱动程序必须检测下层的USB设备是否已正常配置，如果没有正常配置则需要提供出错信息，并返回错误码。在设备加载后，驱动程序需要时刻监测USB外设有无数据，若有数据则会读取数据，并缓存于虚拟串口驱动程序中的输入缓冲区中，待应用程序调用ReadFile()后将这些数据按序返回给应用程序。

#### 5.1.2 虚拟串口驱动的卸载模块

​	设备卸载时，需要调用在DriverEntry例程中指定的卸载函数，虚拟串口驱动指定的卸载函数为USB2SER_Close函数。USB2SER_Close函数必须先结束当前用于从下层驱动或USB外设读取数据的IRP，然后结束向下层驱动或USB外设写入数据的IRP。在结束了这些IRP之后，驱动还需要监测有无其他正处于等待中的IRP，如果有，等待这些IRP完成。设备扩展的NoPendingIoEvent事件对象标示了当前有无处于等待中的IRP，因此只需要调用内核函数KeWaitForSingleObject等待NoPendingIoEvent即可。最后需要关闭USB外设的电源，这通过向USB外设发送关闭电源信号实现。

### 5.2 通信命令转换模块的实现

​	通信命令转换模块用于串口的控制命令向USB控制命令的转换。由于串口物理设备和USB设备的差异，两者的控制命令也有很大的差异，比如串口设置中有波特率、奇偶校验位、停止位等设置选项，而USB设备没有这些设置选项。USB中有的设置选项，比如设备描述符，端口端口描述符等，串口中没有。因此为了保证虚拟串口驱动程序在接收到串口应用程序发送到的串口控制命令时，要根据USB设备的情况，或者忽略掉不再使用的控制命令，或者向USB下层驱动或外设发送类似功能的控制命令。通信命令转换模块的入口函数也在DriverEntry中指定。在DriverEntry中，设置驱动对象的MajorFunction指针数组域的IRP_MJ_DEVICE_CONTROL索引的指针地址为处理命令转转换的函数指针。在虚拟串口驱动程序中，处理命令转换的函数为USB2SER_ProcessIOCTL()函数。 
USB2SER_ProcessIOCTL()是一个分发函数，会根据获取到的控制码的不同调用不同的处理函数，它的流程图如图5.3所示。函数同其他函数一样，首先增加IO计数，再判断设备对象是否可以接收IO请求，这样可以保证对设备发送的命令得到正确相应。

#### 5.2.1  串口通信命令转换的实现

​	USB2SER_ProcessIOCTL()函数会处理所有的控制命令，包括串口通信命令和用户自定义的命令。串口通信命令需要根据当前串口的设置及下层驱动和USB外设的状态返回结果或转换成USB命令，用户也可以定义一些与此设备相关的命令，实现特殊的功能，比如加解密等

​	制码来实现的。一个设置串口状态的系统API函数一般和一个控制码相对应。下面简单介绍一些串口控制码的典型处理方法，其他未介绍的可以根据其性质参照这些控制码的处理方法。 

1. IOCTL_SERIAL_SET_BAUD_RATE 
  IOCTL_SERIAL_SET_BAUD_RATE控制码用来设置串口传输数据的波特率。在电子通信领域，波特率（Baud rate）即调制速率，指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，它是对符号传输速率的一种度量，1波特即指每秒传输1个符号。在串口通信中波特率的大小直接决定了数据传输的速度。由于在高速数据传输中，数据的传输需要达到USB的极限速度，因此波特率的设置可以忽略不计，直接以高速传输速度。在一些特殊情况下，可能需要控制速度的大小为某一特定值，在IOCTL_SERIAL_SET_BAUD_RATE不在设置波特率的情况下，可以用它来设置传输速度。与IOCTL_SERIAL_SET_BAUD_RATE相对应的控制码是IOCTL_SERIAL_GET_BAUD_RATE，它用来获取当前传输的波特率或者传输速度。

2. IOCTL_SERIAL_SET_TIMEOUTS 
  IOCTL_SERIAL_SET_TIMEOUTS用于超时设置。通过它可以对一个特定通信设备上的所有读写操作设置超时时间。一般虚拟串口设备会根据设置的时间等待读写的完成，如果在规定时间内完成了读写操作，则返回读写结果，如果没有完成，则返回超时。由于应用程序在计算超时时间时，是根据串口的波特率计算的，在波特率已不再反映真实的数据传输速度时，这个超时时间的等待也会有些多此一举。实现了高速数据传输的虚拟串口驱动中，数据的传输远高于一般串口的传输速度，因此在绝大数情况下会在超时时间内完成数据传输的。高速数据传输的虚拟串口中，通过设置超时可以检测数据通路是否正常。与此控制码相对应的控制码是IOCTL_SERIAL_GET_TIMEOUTS，它实现了获取当前超时时间的功能。

3. IOCTL_SERIAL_SET_DTR 
  IOCTL_SERIAL_SET_DTR 用于设置DTR状态。DTR是数据终端就绪（Data Terminal Ready）的首字母缩略词。例如，在串行通信中使用的一个信号，通过计算机发送到调制解调器上，以表明计算机已经准备就绪，可以接收未来的传输。这个控制码的处理需要考虑到外接调制解调器的情况，在高速数据传输的虚拟串口中直接返回成功，表示设备一直处于可传输状态。 

4. IOCTL_SERIAL_RESET_DEVICE 

  IOCTL_SERIAL_RESET_DEVICE用于重置设备。外设为物理串口时，这个控制码会清空串口设备中与串口设置相关的寄存器，并恢复串口状态至启动状态。外设为USB外设时，除了清空设备对象保存的与串口设置相关的域，还需要向USB芯片发送USB命令重置外设。与册控制码处理相似的控制码还有IOCTL_SERIAL_SET_RTS和IOCTL_SERIAL_CLR_RTS等控制。

5. IOCTL_SERIAL_SET_XOFF
  IOCTL_SERIAL_SET_XOFF用于在软件流控模式时，终止数据的传输。软件流控通过发送用户指定的特殊符号XOFF终止对方向己方放送数据，发送XON来恢复对方的发送，计算机接收时，流控信号XON/XOFF字符从TD线发至MODEM；当MODEM接收时，XON/XOFF字符从RD线发至计算机，软件流控不适合于用来传输二进制文件，因为它会把文件中的数据误认为是流控信号。在虚拟串口中，会在进行数据传输前根据空闲缓冲区的大小来设置读取数据的大小，如果缓冲区已满，则不会读取数据。因此，IOCTL_SERIAL_SET_XOFF控制码在虚拟串口驱动中也可以直接返回成功。同这个控制码相对应的控制码是IOCTL_SERIAL_SET_XON控制码，它实现的功能和IOCTL_SERIAL_SET_XOFF相反。 

6. IOCTL_SERIAL_GET_WAIT_MASK 

  IOCTL_SERIAL_GET_WAIT_MASK用于获取当前的事件对象。当前的事件对象即串口等待的事件的集合，虚拟串口驱动需要正确处理这个控制码，因为串口应用程序会在进行数据传递前设置当前的事件对象，然后通过发送IOCTL_SERIAL_WAIT_ON_MASK控制码等待事件的发生。如果应用程序等待的事件没有发生，虚拟串口驱动不能直接返回，而是等待事件发生后再返回结果。如果在事情发生前返回，会造成应用程序获取等待事件失败，从而影响应用程序的执行。与此控制码对应的是IOCTL_SERIAL_SET_WAIT_MASK控制码，它用开设置等待的时间对象。一般驱动在收到IOCTL_SERIAL_SET_WAIT_MASK控制码后会立即收到IOCTL_SERIAL_SET_WAIT_MASK控制码。

7. IOCTL_SERIAL_WAIT_ON_MASK 

   虚拟串口驱动收到IOCTL_SERIAL_WAIT_ON_MASK控制码时，表示应用程序正在等待通过IOCTL_SERIAL_SET_WAIT_MASK控制码设置的事件发生。如果当前这些事件没有发生，则不要返回当前正处理的IRP，因为应用程序再驱动返回后会检测是否成功，如果成功，则认为必有事件发生，因此在没有时间发生的情况下发挥会造成应用程序处理逻辑的错误。IOCTL_SERIAL_WAIT_ON_MASK控制码的处理函数是SerialWaitOnMask()函数，它的流程图如图5.4所示。

   ![图片.png](https://upload-images.jianshu.io/upload_images/6128001-4c50219a46e213b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

SerialWaitOnMask()函数为了防止重入情况的发生，在处理waitMask之前，会先获取同步自旋锁。获取同步自旋锁之后会判断当前的waitMask是否为空，如果为空，则表示应用程序不等待任何事件，因此无需处理直接返回即可。在应用程序等待事件发生之前，这些事件也可能已经发生，因此需要先判断这些事件有没有已经发生的。如果有已发生的事件则直接返回，如果没有，需要调用IoMarkIrpPending()内核函数设置当前IRP的状态为未完成状态并返回STATUS_PENDING，当需要等待的事件发生后再返回发生的事件码即可。

IOCTL_SERIAL_PURGE： 
IOCTL_SERIAL_PURGE控制码用于清除发送或接收缓冲内的数据。在某些同步出错或其他情况下，应用程序可以清空当前缓冲区的数据，重新同步或发送数据。



#### 5.2.2 用户自定义命令的实现

​	用户自定义命令也是在USB2SER_ProcessIOCTL ()中处理的，用户自定义的串口控制码需要和应用程序中使用的控制码统一。设置用户自定义命令可以更好的控制虚拟串口驱动下的USB外设，方便管理。下面简单介绍一些用户自定义命令及其处理方式。

1. IOCTL_USB2SER_RESET_PIPE 
  IOCTL_USB2SER_RESET_PIPE用于重置管道。一个USB管道是设备上的一个端点和主机上软件之间的联系，体现了主机上缓存和端点间传输数据的能力，有两种不同的且互斥的管道通信格式。一般传输中，需要两个管道：输入管道和输出管道。应用程序再发现数据传输出错或失效时，可以发送IOCTL_USB2SER_RESET_PIPE控制码，它的处理函数USB2SER_ResetPipe()会构建重置管道的URB数据包发送至USB外设。USB外设的固件再收到重置管道的URB数据包之后会调用固件中的函数进行重置。 

2. IOCTL_USB2SER_GET_CONFIG_DESCRIPTOR 
  IOCTL_USB2SER_GET_CONFIG_DESCRIPTOR用于获取配置描述符。一个USB设备有一个设备描述符，设备描述符里面决定了该设备有多少种配置，每种配置描述符对应着配置描述符；而在配置描述符中又定义了该配置里面有多少个接口，每个接口有对应的接口描述符；在接口描述符里面又定义了该接口有多少个端点，每个端点对应一个端点描述符；端点描述符定义了端点的大小，类型等等。USB的描述符之间的关系是一层一层的，最上一层是设备描述符，下面是配置描述符，再下面是接口描述符，再下面是端点描述符。在获取描述符时，先获取设备描述符，然后再获取配置描述符，根据配置描述符中的配置集合长度，一次将配置描述符、接口描述符、端点描述符一起一次读回。其中可能还会有获取设备序列号，厂商字符串，产品字符串等。获取设备描述符之后就会对USB设备的详细信息，应用程序可以根据这些信息判断USB外设的状态。这个控制码的处理函数通过直接向USB外设发送获取设备描述符命令的方式获取设备描述符。 

3. IOCTL_USB2SER_RESET_DEVICE 

  IOCTL_USB2SER_RESET_DEVICE用于重置设备。应用程序再发现数据传输出错或失效时，可以先重置管道，如果重置管道仍然不能传输数据，可以重置设备。这个控制码的处理函数USB2SER_ResetDevice()会先检测设备是否启动，如果没有，启动它。然后再检测设备是否被禁用了，如果是，则启用它。 
  虚拟串口命令的转换是进行数据传输的基础。在不影响虚拟串口功能的情况下，串口驱动程序返回的状态及信息需要尽可能的与真实串口相同。只有这样，串口驱动程序才可以正确得执行。

### 5.3 数据高速传输模块的实现

​	高速传输数据模块有两个子模块组成，一个是高速数据发送模块，另一个是高速数据接收模块。 
​	高速数据发送模块用于将应用程序传递下来的发送数据传输至USB外设，并在保证数据正确传输的前提下，尽量达到远高于物理串口的传输速度。高速数据接收模块用于从USB外设不间断的读取数据，并填充至驱动程序中的专用缓冲区中。下面分小节对两个模块的实现进行详细的说明。

#### 5.3.1 数据高速发送模块的实现

​	高速数据发送模块的实现主要是通过减少奇偶校验位和停止位等设置，增加单次串口驱动向USB外设发送数据包的长度以及直接锁存应用程序中的数据三个方面来实现。

​	在虚拟串口驱动当中，高速数据发送模块的入口函数是USB2SER_Write()函数，它是在创建设备对象时指定的。USB2SER_Write()函数直接调用QueueOrStartWriteIrp()函数实现写入数据IRP的处理。之所以没有在DriverEntry()的派遣函数表中直接指定发送数据的函数为USB2SER_Write()函数，而不是QueueOrStartWriteIrp()，主要是为了增加代码的可读性。QueueOrStartWriteIrp()函数的主要功能是维护IRP写入队列(WriteQueue)，它根据WriteQueue的空满处理IRP写入请求。

​	QueueOrStartWriteIrp()函数会先判断当前是否在对USB外设进行写入。如果有，将正在处理的IRP加入IRP写入队列；如果没有，调用StartWriteIntUrb()函数，发送正在处理的IRP。QueueOrStartWriteIrp()函数会判断当前虚拟串口驱动是否在对对USB外设进行读写操作，如果驱动没有进行读写操作，则立即向USB外设写入设备。如果驱动在进行读写操作，则排队当前的IRP至IRP写入队列。驱动在结束正在读或写的IRP后，查询当前IRP写入队列中是否为空，如果非空，则依次完成写入IRP的请求。

​	QueueOrStartWriteIrp()首先获取需要写入数据的地址及数据的字节长度。内核函数MmGetMdlVirtualAddress()用于获取数据的虚拟地址。如果需要使用MmGetMdlVirtualAddress()获取设备的虚拟地址，需要在设备对象中指定DO_DIRECT_IO方式，I/O管理器将创建一个MDL用来描述包含该用户模式数据缓冲区的锁定内存页。

```c
typedef struct _MDL {   
  struct _MDL *Next;
  CSHORT Size;
  CSHORT MdlFlags;
  struct _EPROCESS *Process;
  PVOID MappedSystemVa;
  PVOID StartVa;
  ULONG ByteCount;
  ULONG ByteOffset; 
}MDL,*PMDL;
```

​	下图显示了MDL扮演的角色。StartVa成员给出了用户缓冲区的虚拟地址，这个地址仅在拥有数据缓冲区的用户模式进程上下文中才有效。ByteOffset是缓冲区起始位置在一个页帧中的偏移值，ByteCount是缓冲区的字节长度。Pages数组没有被正式地声明为MDL结构的一部分，在内存中它跟在MDL的后面，包含用户模式虚拟地址映射为物理页帧的个数。  
如果在创建设备对象后，指定标志位为DO_DIRECT_IO方式，那么应用程序需要写入USB外设的数据不会被拷贝，而是被锁定在内存中，并通过此MDL表示。这样做的好处是可以减少内存拷贝的操作。尤其在读写大数据量数据里，会大大减少由于拷贝数据产生的实验。在实现虚拟串口驱动向下层驱动或USB外设高速发送的功能是也采用了这种方法。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-b8ad2f4948f61cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	QueueOrStartWriteIrp()函数在获取了需要写入数据的虚拟地址和长度后，需要对地址和长度的有效性进行简单的判断。如果参数错误，需要返回参数错误的错误码(STATUS_INVALID_PARAMETER)。在写入数据前，还需要判断USB外设是否能进行接收读写请求和是否有正在写入的IRP请求。CanAcceptIoRequests()函数用于判断是否可接收读写请求，关于它的处理逻辑前面章节已经介绍过。HaveWriteIntIrpUrp()用于判断在初始化设备对象时创建的写入数据IRP和URP是否存在，如果没有存在，说明创建失败或者设备被突然移除。在发送数据之前，需要检查USB设置及连接是否正常（此处指否被移除），如果不满足，说明设备已被或正被移除，因此需要错误，终止数据的写入。如果这两个条件有一个不满足，就需要返回错误码(STATUS_DELETE_PENDING)。在判断设备可正常读写之后，还需要判断当前是否有写入数据的IRP正被处理及写入队列是否有数据。写入队列可以被多个线程同时访问，因此为了防止多个线程同时对它进行操作产生错误，在访问写入队列直线之前，需要先获取与写入队列相对应的写入自旋锁（WriteQueueSpinLock）。在应用程序写入数据量很大且驱动程序处理滞后的情况下，虚拟串口驱动程序会将不能立即处理的IRP(IRP包含写入数据的索引)排队至写入队列（WriteQueue）。因此在处理每个写入IRP时，都需要判断当前的写入队列是否为空，如果为空且没有正在写入的IRP，则可以对当前的写入IRP进行处理。在处理之前，首先需要标记当前的IRP为驱动中正在处理的IRP，然后通过调用IoMarkIrpPending()内核函数标记当前的IRP为pending状态，最后调用StartWriteIntUrb()函数，这个函数将当前IRP的数据写入USB外设中。

​	如果当前有写入数据的IRP正被处理或写入队列不为空，那么需要将此IRP插入到IRP写入队列（WriteQueue）。当然，在插入此IRP到IRP写入队列之前还需要标记此IRP处于pending状态。IoSetCancelRoutine()函数设置IRP的取消例程。取消例程用于取消当前的IRP操作，即写入操作，它在IoCancelIrp()函数中被调用。在某些情况下（比如设备突然被移除），需要终止当前的读写操作，驱动程序会调用IoCancelIrp()对当前处于pending状态的IRP进行处理，并释放一些资源。通过调用IoSetCancelRoutine()函数，驱动程序在每个IRP被取消前，会获取IRP的控制权。

​	然而，有一种极端的情况。在我们正处理此IRP的过程时，设备管理器调用了此IRP的取消例程。这种情况需要特殊处理，我们先用IoSetCancelRoutine例程在该IRP中安装我们自己的取消例程，该例程执行一个互锁的数据交换。然后我们测试Cancel标志。如果Cancel标志被设置，我们的取消例程可能被调用，也可能没被调用，这取决于我们的代码与IoCancelIrp执行的确切顺序。如果我们的取消例程被调用，则第二次调用IoSetCancelRoutine将返回NULL；这样我们就能把该IRP加入队列，并利用取消例程立即提取该IRP并完成它。如果我们的取消例程没有被调用，在这里完成该IRP。具体的处理流程在QueueOrStartWriteIrp()的伪代码中有描述。

​	在QueueOrStartWriteIrp()中，当前的发送数据IRP或者立即被处理，或者被加入IRP写入队列，然后依次被处理。处理IRP的函数是StartWriteIntUrb()函数，其流程图如图5.6所示。 
​	StartWriteIntUrb()函数将应用程序传递下来的数据发送至下层驱动或USB外设。由于此函数是实现数据发送的关键函数，因此提高此函数中的数据处理及传输速度，就可以提高总的传输速度。在StartWriteIntUrb()函数的处理过程中，不再增加奇偶校验位及停止位等信息，并实现了写入数据的一次发送。而且，在处理应用程序发送下来的数据时采用了先锁存数据再发送的技术，减少了因拷贝数据产生的开销。

​	在真实的串口当中，数据的传输是通过串口线读取的，而在虚拟串口驱动中，数据的传输是通过调用USBDI接口提供的函数实现的。USBDI接口的函数传输数据是以块为单位的，且有块大小的限制，因此在传输数据的时候，需要根据情况将应用程序发送下来的数据锁存在内存当中,然后依次发送数据块，直到要发送的数据完全发送出去之后再结束应用程序的等待状态。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-3af3baad1b689213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 5.3.2 数据高速接收模块的实现

​	高速数据接收模块用于完成数据的接收操作，流程图如图5.7所示。在虚拟串口驱动中，高速数据接收模块的入口函数是USB2SER_Read()函数，它跟USB2SER_Write()函数一样，也是在创建设备对象时指定的。USB2SER_Read()函数直接调用QueueOrCompleteReadIrp()函数实现写入数据IRP的处理，它的流程图如5.8所示。

​	QueueOrCompleteReadIrp()函数先根据当前输入缓冲区中数据的长度与应用程序需要接受的数据长度的差值或者是否超时再决定是否结束当前应用数据接收数据的请求。如果这两个条件都没有满足，QueueOrCompleteReadIrp()函数将此读取（接收）IRP加入读取队列（ReadQueue），读取队列中的IRP请求根据先入先出的方式依次处理。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-9d0fba83fb37704c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	首先，QueueOrCompleteReadIrp()通过调用内核函数MmGetMdlByteCount()和MmGetSystemAddressForMdlSafe()获取读取数据请求需要读取的数据大小及缓冲区首地址。如果需要读取的数据大小小于零，或缓冲区首地址为空，返回错误代码STATUS_INVALID_PARAMETER，这表示参数不正确。应用程序可根据此错误码准确定位至出错的位置。QueueOrCompleteReadIrp()函数需要在处理这个读取请求前，判断是不是发生了USB设备突然从电脑移除的情况。这通过调用CanAcceptIoRequests()函数实现，如果CanAcceptIoRequests()函数返回FALSE，则QueueOrCompleteReadIrp()函数返回错误码STATUS_DELETE_PENDING，通知应用程序，USB设备正在或已经被移除。SerialTimeOutArrive()用于判断是否有读取超时的情况发生，如果有，设置returnWhatsPresent变量为TRUE。如果returnWhatsPresent为真，QueueOrCompleteReadIrp()在缓冲区数据长度小于IRP请求的数据长度时，也会返回当前读取到的数据至串口应用程序。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-4792a2c07b00218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-f01867b97f2939dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	其次，QueueOrCompleteReadIrp()函数根据输入缓冲区（InputBuffer）中数据的长度及returnWhatsPresent变量的值决定是否要完成当前IRP请求。调用内核函数KeAcquireSpinLock()获取InputBufferLock的自旋锁，防止有其他IRP同时在对输入队列进行读取或写入操作时产生错误。CircularBufferDataLen函数用于获取当前输入缓冲区中的数据长度。如果当前缓冲区中的数据长度大于需要读取的数据长度或returnWhatsPresent变量为真，那么调用PopCircularBufferEntry()函数获取可以读取的数据。

​	PopCircularBufferEntry()函数实现了从输入缓冲区（InputBuffer）获取数据并写入指定地址范围的功能。由于PopCircularBufferEntry()函数不会获取和释放输入缓冲区（InputBuffer）自旋锁，因此在调用PopCircularBufferEntry()函数之前需要先获取输入缓冲区（InputBuffer）自旋锁。PopCircularBufferEntry()函数只对传入的指针及数据长度做简单的有效性检查，因此调用此函数前需要保证指针及数据长度的有效性。

​	PopCircularBufferEntry()函数实现了从输入缓冲区（InputBuffer）获取数据并写入指定地址范围的功能。由于PopCircularBufferEntry()函数不会获取和释放输入缓冲区（InputBuffer）自旋锁，因此在调用PopCircularBufferEntry()函数之前需要先获取输入缓冲区（InputBuffer）自旋锁。PopCircularBufferEntry()函数只对传入的指针及数据长度做简单的有效性检查，因此调用此函数前需要保证指针及数据长度的有效性。

​	如果不满足立即完成当前读取请求的条件，则需要将当前正在处理的IRP加入到读取队列（ReadQueue）。将IRP加入到读取队列（ReadQueue）的函数是InsertTailList内核函数。虚拟串口驱动会在读取到足够数据或超时发生时依次完成读取队列（ReadQueue）中IRP请求。

​	在当前正在处理的IRP加入到读取队列（ReadQueue）中后，需要设置当前IRP的取消例程，这样在取消此IRP的时候可以释放与此IRP相关的数据。由于驱动程序的并发性，在QueueOrCompleteReadIrp()函数未结束前，驱动程序也可能已经开始取消此IRP请求。此时，通过判断IRP的Cancel域是否为真即可知道此IRP是否正在被取消。IRP正在被取消时，驱动管理器有可能已经调用了通过IoSetCancelRoutine()内核函数设置的取消例程，也可能没有。如果已经调用了完成例程，则需要通过调用内核函数RemoveEntryList()将此IRP移除。并设置当前IRP的状态为STATUS_CANCELLED，表示此IRP已经被取消。在完成这些操作后，需要调用KeReleaseSpinLock()内核函数完成对ReadQueueSpinLock自旋锁的释放。

​	最后，根据当前IRP的处理状态判断是否调用内核函数IoCompleteRequest()。由于只能对IRP请求包调用一次IoCompleteRequest()函数，因此需要判断是对当前正在处理的IRP调用过IoCompleteRequest()函数。判断的依据是当前IRP的处理状态。当前IRP的处理状态为STATUS_PENDING时表示IRP处于读取队列（ReadQueue）中，此时不能调用IoCompleteRequest()函数，此函数的调用会在取消例程或完成此IRP请求时被调用。如果当前正处理的IRP请求包的状态不为STATUS_PENDING时，可以调用IoCompleteRequest()内核函数完成此IRP请求包。

​	在真实串口中，数据的传输是通过串口线读取的，而在虚拟串口驱动中，数据的传输是通过调用USBDI接口提供的函数实现的。USBDI接口的函数传输数据是以块为单位的[27]，因此在传输数据时，虚拟串口驱动不能够立刻将数据发送出去或读到所需长度的数据。这时，在应用程序读取数据时，需要将发送的数据放在缓冲区里，并让应用程序等待，直到要发送的数据完全发送出去之后再结束应用程序的等待状态。 
应用程序可能会多次向驱动程序发送数据，如果这些数据部进行排序（先来的数据先发送），接受端接受的数据顺序可能会发生错误。因此，在驱动中必须将每次发送的数据进行排队，再本次发送结束之后再启动下次发送。接受数据时也是这样处理。

### 5.4 驱动测试

​	驱动程序的测试前期使用基于MFC[^28]的串口测试软件，后期采用Microsoft公司出品的ActiveSync软件进行测试。ActiveSync软件实现设备端与电脑的连接与通讯，并能实现同步音乐、图片和视频的功能，并能对其进行管理。ActiveSync软件可以基于串口、USB和蓝牙[^29]等进行通信。在测试中，选择采用串口通信，并连接ActiveSync软件至虚拟串口设备。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-61635d7f7b55c04f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 5.4.1 模块测试

​	模块测试采用基于MFC的串口测试软件，主要用于测试发送模块和接收模块的功能完善性及发送速率。MFC的串口测试软件从随机产生的大文件获取发送数据，并随机产生单次发送的数据长度，依次将整个文件发送出去。测试结果汇总如下表所示。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-db158af2a11433af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

测试结果：从表4.2可以看出，传输小文件时，速率没有明显差异，且正确率为100%。传输大数据文件时，速度维持在19MB/s，正确率虽然有所下降，但依然保持在90%以上，符合设计要求。

#### 5.4.2 应用测试

1. 发送短信测试 
  测试目的：验证在ActiveSync基础上可通过虚拟串口发送和接受短信。 测试软件：智能手机工作室 测试步骤： 
  (1) 使用ActiveSync将手机连接PC；
  (2) 在PC端安装智能手机工作室主程序； 
  (3) 打开PC端智能手机工作室主程序，此时在PC端主程序显示已连接状态； 
  (4) 发送短信、拨打电话。 
  测试结果：短信发送100条，顺利接受100条，符合设计要求。
2. 共享摄像头测试 
  测试目的：验证在ActiveSync基础上可通过虚拟串口共享摄像头。 测试软件：webcamera plus 2.1 测试步骤： 
  (1) 使用ActiveSync将手机连接PC； 
  (2) 在PC端安装webcamera plus 2.1主程序； 
  (3) 打开PC端webcamera plus 2.1主程序，此时在手机端程序显示已连接状态； 
  (4) 配置手机端webcamera plus 2.1；
  (5) 在PC端使用webcamera plus 2.1作为网络聊天摄像头等工具。 
  测试结果：PC端可使用手机端作为网络摄像头，且通信流畅，符合设计要求。
3. 上网测试 
  测试目的：验证在ActiveSync基础上可通过虚拟串口浏览网站。 测试软件：无 测试步骤： 
  (1) 使用ActiveSync将手机连接PC； 
  (2) 点击PC端ActiveSync的“工具”--->“选项”，在弹出的窗口上，设置"共享网络"，选择"internet"，点“确定”； 
  (3) 在手机端，选择开始，“设置”--->“连接”--->“USB至PC”，把ActiveSync以及高级网络功能选上；
  (4) 打开手机端浏览器。 
  测试结果：可是实现上网功能，时延较小，符合设计要求。
4. 邮件测试 
  测试目的：验证在ActiveSync基础上可通过本模块收发邮件。 
  测试软件：Microsoft Office Outlook 2007[31] 测试步骤： 
  (1)  PC端安装Microsoft Office Outlook 2007；
  (2) 使用ActiveSync将手机连接PC； 
  (3) 在弹出对话框中选择“同步邮件和通讯录”；
  (4) 同步邮件和通讯录； 
  测试结果：可顺利同步邮件和通讯录，时延较小，符合设计要求。

### 5.5 本章小结

​	本章根据上一章的方案研究内容，对虚拟串口驱动程序实现过程中的关键点和难点作了分析。第一节中实现了虚拟串口驱动程序的加载及卸载模块，第二节基于通信设备类的规范了实现了通信命令转换模块，第三节实现了系数据高速传输模块，第四节对驱动程序进行了测试。



## 第六章 结束语 

### 6.1 工作总结 

随着越来越多的外设开始使用USB接口进行数据通信，合理并快速地实现基于USB的数据传输显得尤为重要，而基于通信设备类的虚拟设备实现又是开发人员研究的重点。论文研究了以USB通信设备类为核心的虚拟串口实现方案，并对虚拟串口驱动的加载及卸载、通信命令转换和数据高速传输进行了研究，实现了基于通信设备类的虚拟串口驱动程序的可用版本。与现有类似驱动程序相比，该系统具有符合通信设备类的抽象控制模型和高速传输等优点，此外它还与Windows2003、XP、Vista和Win7系统在源代码级别兼容，具有广阔的应用前景。论文中通信设备类的研究及基于通信设备类的虚拟串口实现，对开发人员设计其他基于通信设备类的虚拟设备实现方案具有很好的指导意义。 
本论文主要完成了以下工作： 
(1) 深入研究了Windows驱动的工作原理，阅读了英文原版的WindowsNT文件系统及USB协议中通信设备类的相关书籍，既学习了Windows驱动程序的的一般开发方法，又学习了符合USB协议的驱动程序的开发方法。阅读了相关的驱动开发源码，掌握了WindowsNT操作系统下虚拟设备驱动程序的开发方法； 
(2) 研究了现有的虚拟串口实现技术，分析了各种实现方法的优缺点，从中选择了通信设备类的抽象控制模型作为虚拟串口实现的理论依据，避免了重新设计USB转串口电路板及兼容性的问题，这使得虚拟串口驱动有更广阔的应用前景，通用性和高效性； 
(3) 学习了USB协议，对通信设备类进行了深入的研究和分析，并且根据通信设备类中各模型的特点，确定了虚拟串口驱动所用的模型为抽象控制模型； 
(4) 根据虚拟串口驱动程序的设计目标，研究了虚拟串口驱动程序的总体结构和详细方案，对虚拟串口驱动程序中的难点和重点问题进行深入的分析和解决方法的优化； 
(5) 根据虚拟串口驱动程序的研究结果，实现了该驱动程序的演示版本，进行了兼容性和稳定性的测试，通过测试得出了还需要对系统做后续的改进和完善的工作。 

### 6.2 展望 

论文研究并且实现了基于通信设备类的的虚拟串口驱动程序，在命令转换和数据传输中都做了详细的设计。然而，研究并且实现一个基于通信设备类的虚拟设备是一个复杂的过程，论文不能对所有可能存在的问题都处理得当。论文的后续的工作中还需要处理以下问题： 
(1) 通信设备类由USB传统纯电话业务模型、USB ISDN模型和USB网络模型三个模型组成，虚拟串口属于USB传统纯电话业务模型下的抽象控制模型子模型。因此，本论文只是介绍了通信设备类一个子模型的一个设备，关于其他设备的虚拟技术实现方案还需要进一步的研究； 
(2) 系统目前仅支持虚拟单个串口设备，在需要虚拟多个串口设备的情况下，还需要做进一步的研究与设计；  
(3) 安全问题越来越受到重视，驱动可以在后续设计中考虑加入加解密算法，实现数据的加密传输； 
(4) 驱动的测试芯片为Cypress公司的CY7C68013A芯片，还需要在更多的USB芯片进行测试；

(5) 系统还需要进一步地在支持USB通信设备类的操作系统中进行测试，包括32位版本和64位版本，以及测试与其他驱动的兼容性。



## 致谢 

时光荏苒，三年的研究生生活已经接近尾声。在学位论文完成之际，我谨向所有给予了我指导、关心和支持的老师、同学和亲人们致以最衷心的感谢！ 
首先，深深感谢我的导师权义宁副教授。有了您的悉心指导与勉励，我才能顺利完成了理论学习和毕业论文。您平易近人、治学严谨、知识渊博，对待生活积极乐观，为我们营造了轻松积极的环境，真正做到了传道、授业、解惑。三年来，您在学习和生活上给予了我很多引导和帮助，为人的和蔼、敏锐的把握能力和孜孜不倦的研究精神永远是我学习、生活和工作的榜样，这将成为我人生中一笔宝贵的财富。非常有幸能够成为您的学生，在此谨向尊敬的权老师致以最衷心的感谢，同时也祝您身体健康、工作顺利、合家欢乐！ 
其次，感谢王传磊、郑德祥、史柯、周峙和吴祥业五位同门同学，感谢你们给予的支持和热情帮助。感谢实验室里的师弟师妹们给我的研究生生活带来的快乐与欢笑！同时，感谢计算机学院的所有老师，您们的辛勤劳动为莘莘学子们打开了通往科学知识殿堂的大门，您们的谆谆教诲和渊博的专业知识使我在研究生期间受益颇丰。感谢西安电子科技大学的教育和培养，使我在各方面的素质有了质的提高。 
非常感激我的父母和亲人，一直以来都是你们在默默地支持我、关心我、鼓励我，给了我无私的爱与感动。感谢我最最亲爱的父母，正是您们的含辛茹苦与激励使我不断进取，成为我在成长道路上不竭的动力源泉。在我的人生路途上，每一个新的脚步都凝聚了您们的心血与操劳，纵然岁月无情地在您们的发丝上悄悄地留下了印痕，在未来的日子里，我将倍加努力，不辜负您们的期望！在此，一并感谢所有好朋友的关怀与鼓励，衷心地祝愿大家开心快乐每一天！  
最后，谨向百忙之中抽出宝贵时间评审本论文的专家、学者致以最诚挚的谢意。





​	

​	 



## 参考文献

[^1]: Universal Serial Bus Specification,Revision 2.0. Compaq,Hewlett-Packard,Intel,2000
[^2]: 许永和. EZ-USB FX 系列单片机USB外围设备设计与应用. 北京：北京航空航天大学出版社,2002.
[^3]: MindShare,inc,Don Anderson,Dave Dzatko,孟文. USB系统体系. 北京：中国电力出版社,2003.
[^4]: 肖踞雄,翁铁成,宋中庆. USB技术及应用设计. 北京: 清华大学出版社,2004.
[^5]: Lawrence Harte, Robert Flood.  Introduction to Public Swithcd Telephone Networks; Pots, ISDN, DLC, DSL and Pon Technologies, System and Services. Althos,2005.
[^6]: Miroslaw Wasniowski. ATM Basics: High-Speed Packet Network Operation and Services.  Althos, 2005.
[^7]: 郇极,刘艳强. 工业以太网现场总线EtherCAT驱动程序设计及应用. 北京航空航天大学出版社, 2010.
[^8]: 王成儒,李英伟. USB2.0原理与工程开发. 北京: 国防工业出版社, 2004.
[^9]: Jan Axelson. USB Complete: The Developer’s Guide. Lakeview Research,2011.
[^10]: 张帆,史彩成. Windows设备驱动程序开发指南. 北京: 北京航空航天大学出版社,2008.
[^11]: Walter Oney. Programming the Microsoft Windows Driver Model. Microsoft Press,2003.
[^12]: Penny Orwick,Guy Smith. Developing Drivers With the Windows Driver Foundation. Microsoft Press, 2007.
[^13]: Chris Cant. Writing Windows WDM Device Drivers. Focal Press,1999.
[^14]: 周立功. USB2.0与OTG 规范及开发指南. 北京: 北京航空航天大学出版社,2004.
[^15]: 刘荣. 圈圈教你玩USB. 北京：北京航空航天大学出版社. 2009.
[^16]: 薛园园,赵建领. USB应用开发宝典. 北京：人民邮电出版社. 2011.
[^17]: Gen Chandler,Chris Kolb,Maria Polhman,etal. On-the-go supplement to the USB2.0 specification. http://www.usb.org.
[^18]: Enhanced Host Controller Interfaces Specification for Universal Bus Revision 1.1 Intel,March 12,2002.
[^19]: 武安河. Windows设备驱动程序WDF开发. 北京：电子工业出版社,2009.
[^20]: Walter Oney. Programming the Microsoft Windows Driver Model. Microsoft Press,2003.
[^21]: Penny Orwick,Guy Smith. Developing Drivers With the Windows Driver Foundation. Microsoft Press, 2007.
[^22]: Chris Cant. Writing Windows WDM Device Drivers. Focal Press,1999.
[^23]: David Solomon, Mark Russinovich. Microsoft Windows Internals,Fourth Edition. Microsoft Press,2009.
[^24]: Jan Axelson. USB Complete: Everything You Need to Develop USB Periphrals, Third Edition. Lakeview Research,2005.
[^25]: 廖济林. USB2.0应用系统开发实例精讲. 北京：电子工业出版社,2006.
[^26]: 张佩,马勇,董鉴源. 竹林蹊径:深入浅出Windows驱动开发. 北京: 电子工业出版社,2011.
[^27]: 边海龙,贾少华. USB2.0设备的设计与开发. 人民邮电出版社,2004.
[^28]: 齐舒创作室. Visual C++ 6.0开发技巧及示例剖析. 北京：清华大学出版社,2000 .
[^29]: 喻宗泉. 蓝牙技术基础. 机械工业出版社,2006.
[^30]: 伏英娜. Windows Phone 7应用开发指南. 北京：电子工业出版社,2011.
[^31]: Jlyce Cox,Steve Lambert,Curtis Frye,吴浩,李娜. Microsoft Office 2007标准教程. 人民邮电出版社,2011.