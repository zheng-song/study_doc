一下内容摘自[基于USB通信设备类的虚拟串口研究与设计](http://xueshu.baidu.com/s?wd=paperuri%3A%289ffb3cb9136fb7c87979b108bc11fa0e%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http%3A%2F%2Fwenku.baidu.com%2Fview%2Fb625f3ca0c22590102029d2b.html&ie=utf-8&sc_us=4827041105237611123)

##												摘要

​	USB接口由于支持热插拔和标准统一等特点得到了广泛的应用，越来越多的电脑设备开始采用USB接口进行数据的传输，而如何在不改变现有应用软件的情况下，将设备移植到USB接口成为了人们研究的热点。

​	论文以USB通信设备类中的抽象控制模型为基础，研究了通信设备类以及实现虚拟设备的原理，设计并实现了基于通信设备类的虚拟串口驱动程序。

​	论文研究设计了基于通信设备类的虚拟串口驱动程序的结构和实现方案，程序主要由通信命令转换和数据传输两个部分组成，通信命令转换符合通信设备类中抽象控制模型的规范，数据传输部分对现有的虚拟串口的实现技术进行了改进。主要工作如下：

1. 研究了USB协议的请求和传输模式，分析了通信设备类实现虚拟设备的方案。
2. 给出了一种符合通信设备类中抽象控制模型的虚拟串口的实现方案。该方案提供了一种基于通信设备类开发虚拟设备的模板，对设计中的诸多问题进行了详细的说明，并改进了虚拟串口驱动程序中数据的处理流程。
3. 将改进后的数据处理流程应用于虚拟串口的实现当中，生成了一种机遇通信设备类的稳定、高速的虚拟串口。



## 第一章 绪论

​	本章首先介绍了在VxWorks进行USB转串口的研究背景及现实意义。然后在根据技术的实现方式分类介绍当前国内外对USB通信设备类以及虚拟串口的研究状况，最后介绍了项目的设计与实现的安排。具体分为三小节来组织。

### 1.1 论文的研究背景以及意义

​	USB[^1]  \(通用串行总线\)是用于电脑和外设进行数据交换的一种通用总线或接口,这种标准接口由于具有数据传输快、支持热插拔、通用性强、易于扩展、总线可给外设供电等特点，得到了广泛的应用。并且，这种标准的串口接口不仅仅在当前所有的接口当中都有使用，而且在嵌入式系统尤其是在移动设备中的应用也越来越广泛[^2]，在各种MP3/4、数码相机，手机和PSP等设备当中，USB接口也几乎成为了唯一的外部接口。信息产业部正式公布的“移动通信手持机充电器及接口技术要求和测试方法”通信行业标准明确了手机接口方面将参照USB的接口规范[^3]，目前市场上的手机多采用USB接口进行数据传输，USB接口已成为手机与数据传输的的“实际”标准。

​	然而越来越多的设备开始使用USB接口，对USB协议也是一个很大的挑战。一般在设计外设时，传输数据的接口与通讯协议是一一对应的，而由于接口的不同，不同外设使用的协议也不同。比如网线为RJ45接口，可传输基于TCP/IP等协议的数据；串口为RS232接口，可传输的数据遵循串口协议；打印机为并行接口，可传输符合打印机通信协议的数据。如果在不改变传输协议的情况下，将数据接口换为USB接口，必然不能正确的传输数据。而本文研究的USB通信设备类很好的解决了这个问题[^4]。

​	USB 通讯设备类协议CDC (Communication Devices Class Specification) 的技术可以将USB接口虚拟成不同的通讯设备接口。自从USB通信设备类规格发布以来，国外的软硬件公司都使用USB 通信设备类在USB上实现一些通讯接口的功能，如串口、ISDN[^5]、ATM[^6]和以太网[^7]等。比如，Microsoft 在WINDOWS XP版本上内置了基于通信设备类的RNDIS驱动，使得在WINXP下可以无缝的连接基于RNDIS的USB以太网接口设备。Linux在2.6以后的版本就缺省支持基于通信设备类的以太网接口(usbnet)与串口。本文研究了USB通信设备类，并给出了符合通信设备类中抽象控制模型规范的虚拟串口驱动程序的设计和实现。



### 1.2 国内外研究现状

​	USB和串口之间的转换实现，有硬件实现和软件实现两种。硬件实现一般需要设计专门的控制芯片。设备控制芯片分为通用设备控制器和专用设备控制器，通用设备控制器定位于某几类USB产品的编程应用；专用设备控制器，定位于某一个USB产品的应用。

​	国内外有很多商业上成熟的此类接口转换器，其重点都是放在虚拟串口设备的设计上，一个好的转接器需要设计一个能够列举出虚拟串口的驱动程序，在这种情况下，PC端的应用软件依然是针对RS-232串行端口进行编程的，外设也是以RS-232为数据通信通道，但是从PC到外设之间的物理连接却是使用的USB总线，其上的数据通信也是USB数据格式的。采用这种方式的好处在于:一方面可以保护原有的软件开发投入，并使得已有的针对RS-232外设的应用软件可以不加修改，便可以继续使用；另一方面就是USB总线的高传输速率和即插即用的特性得到了充分的利用。虚拟串口的用途最初都是用于串口转网络通信接口，也就是把对网口的操作映射为对串口的操作。由于原有的平台软件是哦通过电脑的串口收发数据，为了使得平台的软件不用改变工作方式，需要在电脑平台上安装虚拟串口驱动，通过虚拟串口驱动可以将硬件转换器从网络上传送来的数据重定向到一个虚拟串口上。这样，平台软件通过虚拟串口进行数据收发。

​	USB和串口之间的转换，还有一种实现是软件实现。这里的软件实现主要是指设计USB转串口的驱动程序。在USB中CDC子类成为规范之前，USB转串口驱动程序的实现各种各样，且基于特定的设备，通用性较差。USB中CDC子类抽象控制模型规范了虚拟串口实现的框架，增强了虚拟串口驱动程序的通用性。



### 1.3 论文的主要内容和组织结构

#### 1.3.1 研究目标

​	论文的目标是实现一个规范、高速、实用的虚拟串口驱动程序，具体如下：

1. 符合通信设备类当中的抽象控制模型的规范。只要USB设备的固件程序符合通信设备类规范，开发人员就可以使用本驱动程序或基于本驱动程序进行二次开发；
2. 速度高。**传输数据率接近USB设备的传输速度????**，时延小；
3. 使用方便。用户不需要重新开发应用程序，符合串口标准的应用程序均可以在本虚拟串口上进行数据传输。
4. 缩短开发时间。在开发基于通信设备类的驱动程序时，开发人员可以参考本驱动中的设计模型以及实现方法；
5. 给出通信设备类驱动程序的一般设计方法。基于本文中通信设备类驱动程序的设计模型，开发人员可以设计出模拟其他设备的虚拟接口。

#### 1.3.2 研究难点以及工作内容

​	USB通信设备类的研究目前尚未成熟，可以参考的资料文献和代码都比较少，更多的是依靠讨论得出方法，然后对该方法的可行度和可靠性进行试验。存在开发难度大，需要解决的问题多等困难。此外，驱动程序开发对操作系统的依赖性很高，需要对操作系统的相关细节了解透彻，但是微软的WindowsNT系列操作系统不开源，无法查证实现细节，这也加大了设计实现的难度。由于驱动程序运行在内核态，因此在用户态能用的很多标准函数都无法使用，需要重新查阅函数用法，驱动程序的开发不能像用户态程序一样方便地进行调试。程序设计的过程中还要非常注意内存的使用，如果发生内存使用错误，将导致BSOD（Blue Screen of Death，简称BSOD）发生，需在系统重启后分析出错时的内存核心镜像，根据错误码和相关参数来查找出错的原因。此外，设计虚拟串口驱动程序时需要考虑USB通信设备类中的诸多规范，这也使设计实现的过程中需要考虑的因素比较多，工作量较大。

​	论文工作的内容如下：

1. 阅读微软提供的驱动开发手册，查阅WindowsNT驱动开发相关的中英文书籍[^10][^11][^12][^13]，深入了解WindowsNT的内部运行机制，理解驱动程序开发的基于USB通信设备类的虚拟串口研究与设计原理，学习驱动开发的手段和步骤，对现有的驱动开发工具进行比较分析，选择适合的开发工具;
2. 分析并试用现有的通信设备类驱动程序，对各种通信设备类及虚拟串口的实现技术进行比较。针对现有虚拟串口驱动实现中的种种问题[^25]，采用通信设备类的抽象控制模型作为基础开发虚拟串口驱动框架； 
3. 研究通信设备类驱动程序设计需要解决的各种问题，分析比较了现有的解决方法，得出了与抽象控制模型更适合的解决方法；
4. 设计实现一个符合通信设备类中抽象控制模型的虚拟串口驱动程序，并将该驱动应用于某项目中。基于本驱动，实现手机端Microsoft ActiveSync软件同电脑端
5. ​

#### 1.3.3 论文的组织结构

论文首先介绍了国内外现有的虚拟串口实现技术的研究现状，并分析了各自的利弊。论述了基于通信设备类设计虚拟串口的优点，然后分析了WindowsNT系统驱动程序的层次结构。研究了驱动程序开发的理论知识，对驱动程序中的各种机制进行分析，设计了一套基于通信设备类中抽象控制模型的虚拟串口驱动程序实现方案。最后根据方案实现了该系统，并对其进行了测试。 

第一章，绪论。介绍了通信设备类和虚拟串口驱动程序的研究意义和国内外现状，给出了论文的工作内容以及创新点。 

第二章，USB通信设备类研究。分析了USB请求和传输模式，研究了通信设备类及抽象控制模型的规范和实现方法。 

第三章，Windows驱动程序架构。分析了Windows驱动程序中处理请求及传输数据的原理，研究了USB驱动程序的协议栈结构及虚拟串口驱动程序的特征。 

第四章，通信命令转换和数据高速传输的设计。设计了系统总体方案，针对各个模块给出了详细方案。 

第五章，通信命令转换和数据高速传输的实现。给出了虚拟串口驱动程序的加载及卸载模块、通行命令转换模块和数据高速传输模块的实现及其关键技术，并且对系统进行了测试。 

第六章，结束语。总结了论文所做的工作,阐述了论文后续研究的重点。

## 第二章 USB通信设备类的研究

​	本章对USB通信设备类进行了研究和分析。首先，总结了USB控制请求的种类，并分析了USB数据包及四种事务传输的方式；其次，重点研究了用于虚拟设备的USB通信设备类协议；最后，深入分析了抽象控制模型的消息和通知。

### 2.1 USB请求和传输模式

#### 2.1.1 USB控制请求

USB接口设备通过管道和HOST通信，在默认控制管道上接受并处理以下三种类型的请求[^14]： 

1. 标准请求。一共有11个标准请求，如得到设备描述、设置地址、得到配置描述等。所有USB设备均应支持这些请求。HOST通过标准请求来识别和配置设备。 
2. 类（class）请求。USB还定义了若干个子类，如HUB类、大容量存储器类等。不同的类又定义了若干类请求，该类设备应该支持这些类请求。设备所属类在设备描述符中可以得到。 
3. 厂商请求。这部分请求并不是USB规范定义的，而是设备生产商为了实现一定的功能而自己定义的请求。

#### 2.1.2 USB数据包以及事务传输

​	USB采用littleedian字节顺序，在总线上先传输一个字节的最低有效位，最后传输最高有效位，采用NRZI编码，若遇到连续的6个1要求进行为填充，即插入一个0。所有的USB包都由SYNC开始，高速包的SYNC宽度为32bit，全速/低速包的SYNC段长度为8bit。实际接收到的SYNC产度由于USB HUB的关系，可能会小于该值。 
​	USB数据包[^15]的格式如图所示。

![USB数据包的格式](https://upload-images.jianshu.io/upload_images/6128001-ad55f549d6db56be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	PID表征了数据包的类型，分为令牌(Token)、数据(Data)、握手(Handshacke)以及特殊包4大类，共16种类型的PID。

​	对于令牌包来说，PID之后是7位的地址和4位的端点号。令牌包没有数据域，以5位的CRC校验和结束。SOF是一类特殊的令牌包，PID后跟的是11位的帧编号。 	
​	对于数据包来说，PID之后直接跟数据域，数据域的长度为N字节，数据域后以16位的CRC校验和结束。握手包仅有PID域，没有数据也没有校验和。分离传输会用到一类特殊的包，Start-Split和Complete-Split包，格式如图所示。

![Start-Split和Complete-Splite包](https://upload-images.jianshu.io/upload_images/6128001-2655132d72971124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在Start-Split和Complete-Split包中主要指定了此次分离传输所在的HUB的地址和下行端口编号以及端点类型（控制、中断、批量、同步）。以及此次传输中数据包在整个数据中的位置（第一个包、中间的包、末尾的包）。

​	握手包包括ACK，NAK，STALL以及NYET四种，其中ACK表示肯定的应答，成功握手包握手包的数据传输；NAK表示否定的应答，失败的数据传输，要求重新传输；STALL表示功能错误或端点被设置了属性；NYET表示尚未准备好，要求等待。 

​	数据在USB总线上的传输以包为单位，包只能在帧内传输。高速USB总线的帧周期为125uS，全速以及低速USB总线的帧周期为1mS。帧的起始由一个特定的包（SOF包）表示，帧尾为EOF。EOF不是一个包，而是一种电平状态，EOF期间不允许有数据传输。虽然高速总线和全速低速总线的帧周期不一样，当时包中帧编号的增加速度是USB/USBSOF一样的，因为在高速USB系统中，SOF包中帧编号实际上取得是计数器的高11位，最低三位作为微帧编号没有使用，因此其帧编号的增加周期也为1 ms。 

​	图中一个方框表示一个Packet，灰色的包表示主机发出的包，白色的包表示Device发出的包。批量传输是可靠的传输，需要握手包来表明传输的结果。若数据量比较大，将采用多次批量事务传输来完成全部数据的传输，传输过程中数据包的PID按照DATA0-DATA1-DATA0-…的方式翻转，以保证发送端和接收端的同步。允许连续次以下的传输错误，会重试该传输，若成功则将错误次数计数器清零，否则累加该计数器。超过三次后，HOST认为该端点功能错误（STALL），放弃该端点的传输任务。USB协议定义了四种事务传输。

![事务传输(Transaction)的流程图](https://upload-images.jianshu.io/upload_images/6128001-ee22187c85f30e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 批量传输：一次批量传输(Transfer)由1次到多次批量事务传输(Transaction)组成。 发送端按照DATA0-DATA1-DATA0-…的顺序发送数据包，只有成功的事务传输才会导致PID翻转，也就是说发送端只有在接收到ACK后才会翻转PID，发送下一个数据包，否则会重试本次事务传输。同样，若在接收端发现接收到到的数据包不是按照此顺序翻转的，比如连续收到两个DATA0，那么接收端徨为第二个DATA0是前一个DATA0的重传。

- 控制传输：一次控制传输分为三（或两个）个阶段：建立（SETUP）、数据（DATA）（可能没有）以及状态（STATUS）。每个阶段都由一次或多次（数据阶段）事务传输组成。 

  ​	如图2.4所示为建立阶段的控制传输流程图。可以看出：与批量传输相比，在流程上并没有多大区别，区别只在于该事务传输发生的端点不同、支持的最大包长度不同、优先级不同等这样一些对用户来说透明的信息。 
  ​	建立阶段过后，可能会有数据阶段，这个阶段将会通过一次或多次控制传输事务，完成数据的传输。同样也会采用PID翻转的机制。建立阶段， Device只能返回包，或者不返回任何包。 
  ​	最后是状态阶段，通过一次方向与前一次相反的控制事务传输来表明传输的成功与否。如果成功会返回一个长度为0的数据包，否则返回NAK或STALL。如图2.5所示为整个控制传输的示意图。

- 中断传输：中断传输在流程上除不支持PING之外，其他的跟批量传输是一样的。他们之间的区别也仅在于事务传输发生的端点、支持的最大包长度、优先级等信息不同。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-064bb7ae36ec33d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-580c001ce5962c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-2fccc4cb70fe3cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	主机在排定中断传输任务时，会根据对应中断端点描述符中指定的查询间隔发起中断传输。中断传输有较高的优先级，仅次于同步传输。同样中断传输也采用PID翻转的机制来保证收发端数据同步。如图2.6所示为中断传输的流程图。

- 同步传输：同步传输[^16]是不可靠的传输，所以它没有握手包，也不支持PID翻转。主机在排定事务传输时，同步传输有最高的优先级。如图2.7所示为同步传输的流程图。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-68020a2b0a8b9323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2 通信设备类

#### 2.2.1 通信设备类

​	USB的CDC类是USB通信设备类(Communication Device Class)的简称。CDC类是USB组织定义的一类专门给各种通信设备(电信通信设备和中速网络通信设备)使用的USB子类[^17]。根据CDC类所针对通信设备的不同，CDC类又被分成以下不同的模型：USB传统纯电话业务(POTS)模型，USB ISDN模型和USB网络模型。其中，USB传统纯电话业务模型，有可分为直接线控制模型(Direct Line Control Model)，抽象控制模型(Abstract Control Model)和USB电话模型(USB Telephone Model)，如图2.8所示。本文所讨论的虚拟串口就属于USB传统纯电话业务模型下的抽象控制模型。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-977204c8c228519e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	通常一个CDC类又由两个接口子类组成通信接口类（Communication Interface Class）和数据接口类(Data Interface Class)。笔者主要通过通信接口类对设备进行管理和控制，而通过数据接口类传送数据。这两个接口子类占有不同数量和类型的终端点（Endpoints），如图2.9所示。对于前面所述的不同CDC类模型，其所对应的接口的终端点需求也是不同的。如所需要讨论的抽象控制模型对终端点的需求，通信接口类需要一个控制终端点（Control Endpoint）和一个可选的中断（Interrupt）型终端点，数据接口子类需要一个方向为输入（IN）的周期性（Isochronous）型终端点和一个方向为输出（OUT）的周期性型终端点。其中控制终端点主要用于USB设备的枚举和虚拟串口的波特率和数据类型（数据位数、停止位和起始位）设置的通信。输出方向的非同步终端点用于主机（Host）向从设备（Slave）发送数据，相当于传统物理串口中的TXD线（如果从单片机的角度看），输入方向的非同步终端点用于从设备向主机发送数据，相当于传统物理串口中的RXD线。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-351980426b1f98b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2.2.2 抽象控制类

​	抽象控制模型（ACM）可以消除老式调制解调器与USB设备间的“代沟”。为了支持以前开发且基于串口的应用程序，需要解决两个问题。第一个是，驱动程序需要支持先前的控制信号和状态变量，因为许多载波调试标准都依赖它们。由于这些依赖关系的存在，驱动程序需要开发一个模拟的调制解调器，它向USB HOST[^18]呈现一个抽象控制模型的通信类接口。为了实现这些功能，需要处理额外的请求和通知。 
​	第二个需要解决的问题是，消除先前调试解调器的设计与抽象控制模型在数据类接口上多通道通信的特征之间的差异。先前的调制解调器只对一个通道支持“AT”命令和数据传输。为了支持先前调试解调器的这个特性，设备需要支持设定通道个数限制的命令。 
​	枚举这类设备时，通信类接口仍然指定一个抽象控制模型，然而实际的控制信号会发生至数据类接口。为了描述这个特征，调用管理功能描述（Call Management Functional Descriptor）的D1位用于表示拥有这个特性。

​	为了支持这两种模式，基于通信类接口的调试控制模式(call control)和基于数据类接口的调试控制模式,并且能够在两个模式间自由转换，CDC提供了GetCommFeature()函数实现模式的设置以及转换。包括请求-抽象控制模型和通知-抽象控制模型两种，如下表所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-a0337ad6253a35f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	通信子类为抽象控制模型的通信类接口支持表2.1所示的这些与类相关的请求。一些没有列出来的与这些类相关的请求，比如SET_HOKK_STATE，不适用于抽象控制模型，并且发送这些请求时，会造成设备处于STALL状态。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-d8db7c7bf5098bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

通信子类为抽象控制模型的通信类接口支持表2.2所示的这些和类相关的通知。其他和类相关的通知，比如RING_DETECT，不适用于抽象控制模型，并且这种设备不能够发送这个信号。

请求-抽象控制模型中的请求分别描述如下： 

(1) SendEncapsulatedCommand请求 

​	这个请求用于发送一个支持控制协议格式的命令到通信类接口，如表2.3所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-3ded9b8246f552a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(2) GetEncapsulatedResonse请求 

​	这个请求用于获取通信类接口的信息，一个支持控制协议格式的命令用于指定获取的的信息类型，如表2.4所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-c071af6055e4fb94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(3) SetCommFeature请求 
​	这个请求用于设置与特定设备的某次通信中的状态，如表2.5所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-f650f9a2ccff58ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

(4) GetCommFeature请求 
​	这个请求用于获取与特定设备的通信中的某些状态的值，如表2.6所示。 

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-959199f57bcd3263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



(5) GetCommFeature请求中可设置或获取的状态及代码如表2.7所示。  



### 2.3 本章小结

​	本章首先总结了三种USB控制请求的应用场景，分析了USB数据包的格式以及四种事务传输类型在USB传输中的作用。其次，分析了USB通信设备类在解决虚拟设备问题方面的优势，为本文的进一步研究奠定了基础。最后，研究了抽象控制模型的处理请求的流程以及注意事项，对虚拟串口驱动程序的设计有很好的指导作用。





## 第三章 Windows驱动程序框架

​	本章首先简要论述了Windows驱动程序的架构，概括了Windows驱动程序的分层结构，描述了驱动程序中常用的数据结构；然后介绍了USB的协议栈，并分析了虚拟串口驱动程序的特征。

### 3.1 Windows驱动程序框架

#### 3.1.1 分层结构

​	WindowsNT操作系统的驱动程序构架[19]为分层式，该系统也是分层构建的操作系统。即使磁盘的驱动程序全在一个源程序文件中，该驱动程序仍然被加载到驱动栈的某一层。WindowsNT系列操作系统通过调用特定的接口获得下层系统提供的服务，其体系结构如图2.1所示。除了I/O管理器，还包括Windows磁盘管理器（Windows Management Instrumentation，简称WMI），即插即用管理器（Plug and Play，简称PnP）和电源管理组件等。所有的组件中，最主要的是I/O管理器。它根据接收到的请求创建IRP，然后将该IRP以特定的顺序传递给驱动栈[30]。栈顶驱动根据IRP的内容，分为三种情况处理： 

1.  该层驱动能处理IRP。直接处理后设置IRP状态为处理完毕，然后将该IRP返回给I/O管理器； 

2.  该层驱动不能单独处理IRP。比如过滤驱动程序，驱动可能重新创建IRP将上层传递下来的IRP分多次传递到下层驱动完成，完成IRP以后由该层驱动设置IRP状态为处理完毕； 

3.  该层驱动无法处理IRP，直接传递到下层驱动处理。 

其余各层驱动的处理情况也类似。最底层的驱动可能直接调用硬件抽象层(Hardware Abstract Layer,简称HAL)接口完成I/O操作。

#### 3.1.2 I/O请求包

​	IPR(I/O请求包)即输入输出请求包是Windows内核中的一种数据结构[^20]。上层应用程序与底层驱动程序间进行通信的时候，应用程序会发出I/O请求，操作系统就将I/O请求转化为相应的IRP数据，不同的类型的IRP会根据类型传递道不同的派遣函数内。IRP是从系统非分页内存池中分配的一个数据结构，包含有一个固定大小的首部和一个可变大小的堆栈。

​	首部含有IRP自身的属性；返回状态、信息，定义了系统缓冲区、用户缓冲区。系统缓冲区指针指向的是一个位于内核模式的非分页内存中的数据缓冲区。对IRP的读操作和写操作，如果顶层设备指定buffer标志，则I/O管理器就会创建一个数据缓冲区。I/O管理器把用户模式程序发送给驱动程序的数据复制到缓冲区，这些数据可以与WriteFile调用有关数据，也可以是DeviceIoControl调用中的输入数据。对于读请求，驱动程序把读出的数据填到系统的缓冲区，I/O管理器再把缓冲区的内容复制到用户模式缓冲区。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-6df763f625c91293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

堆栈由一个或者是多个I/O单元组成，而且他们都采用IO_STACK_LOCATION结构，内部包含有I/O请求的函数代码和参数，I/O栈单元的个数等于该I/O请求的驱动程序的个数，或者说是驱动程序栈的层数，而且每层驱动程序只能够访问对应的I/O栈单元。

#### 3.1.3 IRP传递策略

​	IRP创建好了以后，可以调用IoGetNextIrpStackLocation函数获得IRP第一个堆栈单元的指针。I/O堆栈是一个IO_STACK_LOCATION结构数组，可以将这个指针初始化为一个不存在的元素，当需要初始化第一个堆栈单元的时候，需要给出下一个堆栈单元，初始化给出的堆栈单元。IRP中第一个堆栈单元指针被初始化为指向该堆栈单元之前的堆栈单元。IRP有三种处理情况：派遣函数立即完成IRP、排队IRP由驱动程序其他例程处理、传递到处于同一堆栈的下层驱动程序。

#### 3.1.4 派遣函数

​	驱动程序主要是用来处理I/O请求，而大部分I/O请求均在派遣函数中处理。用户模式下所有对驱动程序的I/O请求，全部由操作系统转化为IRP，不同的IRP会被第四章 接口转换器驱动模型分析与实现机制 27派遣到不同的派遣函数中，在派遣函数中IRP将得到处理。 

​	IRP有两个基本属性：MajorFunction，MinorFunction。分别记录IRP的主类型和子类型，操作系统根据MajorFunction将IRP派遣到不同的派遣函数中，在派遣函数中还可能继续判断MinorFunction()。 

​	WDM驱动程序的派遣函数都是在入口函数DriverEntry里注册的。通过设置 DriverEntry的驱动对象pDriverObject中的函数指针数组MajorFunction，可以将IRP的类型和派遣函数关联起来。 

​	IRP的处理类似于Win32中“消息”的处理方式，不同的IRP会被派遣到不同的派遣函数中进行处理，当没有对应的派遣函数时，将会进入到系统默认的派遣函数中进行处理。大部分的IRP都源于文件I/O处理Win32API，处理这些IRP可以在相应的派遣函数中就IRP的状态设置为成功，然后结束IRP请求，并返回成功。

#### 3.1.5 内存分配与管理

​	Windows中采用的虚拟内存使得系统可以使用比物理内存跟多的内存[^21]。虚 拟内存的实现方式如下：将每个应用程序的可能地址空间划分成固定大小的块，称之为页。页可以驻留在物理内存中，也可以交换到硬盘。设备驱动程序分配的内存通常有两两种：交换型的分页内存，永久驻留的非分页内存。当在线程调度或者更高终端级别访问分页内存时，就会引起缺页故障，造成内核崩溃。 

​	常规线程访问非驻留的分页内存，内核也会造成线程阻塞，直到内存管理器将所需访问的分页内存装回内存。因此，在设计驱动程序时，要注意两个方面的问题：一不能滥用非分页内存；二就是经常得使用非分页内存，在线程调度或更高级别的中断级访问内存时，必须调用非分页内存。当完成内存调用后，应当对所有类型的内存通过ExFreePool释放。如果不释放，将会导致内存减少，因为即使当驱动程序卸载后，内核也不会回收这些分配了的内存。

​	当频繁申请和回收内存时，会导致内存上产生大量的内存“空洞”，进而导致最终无法申请内存。因此，当驱动程序需要频繁地从内存中申请、回收固定大小的内存时，就必须解决“空洞”问题，DDK提供了一种机制就是使用Lookaside对象来解决。 

​	Lookaside对象可以被认为是一个内存容器。在初始的时候它先向Windows申请一块较大内存。以后需要申请内存的时候，直接向Lookaside对象申请内存，而不向Windows申请。Lookaside对象能智能地避免产生内存“空洞”。如果Lookaside对象内部的内存不够用时，就会向操作系统申请更多内存。当Lookaside内部有大量未使用的内存时，会自动让Windows回收部分内存。可以将Lookaside看成是一个自动的内存分配容器，对Lookaside对象申请内存的效率高于直接向Windows申请内存。 

​	Lookaside一般在每次申请固定大小的内存而且申请和回收的操作很频繁的情况下使用。



### 3.2 USB协议栈

#### 3.2.1 USB协议栈

​	USB的驱动栈[^22]是Windows操作系统的一部分，下图对它进行了说明。所有的驱动都嵌入在WDM的分层架构中。

​	USB驱动栈中各个模块的说明如图3.2所示。

​	USB主控制器是控制统一串行总线（USB）的硬件组成部分。它控制着连接它的USB根集线器。主控制器的实现有两种形式，一种形式是支持USB的全速模式，即Open Host Controller(OHC)和Universal Host Controller(UHC)。另外的一种实现形式支持USB高速模式，即Enhanced Host Controller(EHC)。

​	OpenHCI.sys是主控制器驱动它适用于符合Open Host Controller Interface 标准的控制器。这个驱动程序不是必须的，兼容UHCI或EHCI的控制器的驱动程序可以替换它，而这个驱动程序根据电脑的主板芯片组不同而不同。比如，Intel芯片组包含EHC和UHC。

​	USBD.SYS是USB总线驱动程序，它负责控制并管理总线上的所有USB设备。它是Windows操作系统的一部分，由微软提供。

​	USBHUB.SYS是USB集线器驱动程序。它负责管理和控制所有的USB集线器。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-7e9e9feed724f0c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	虚拟串口驱动程序是一个内核模式的驱动程序，它支持各种USB协议并能模拟出一个虚拟串口的COM端口。在操作系统中，供USB设备驱动程序访问USB外设的接口是USDBI(USB Driver Interface)。它位于USB驱动栈的最顶端。USBDI是一种基于IRP的接口，即每一个独立的请求被包装在一个IRP中。IRP是WDM模型中定义的数据结构。I/O请求包会被传输给USB驱动栈中的下层驱动进行处理，并在完成请求后将结果返回给调用者[^23]。

#### 3.2.2 虚拟串口驱动的特征

​	虚拟串口驱动支持USB的CDC-ACM协议。设计的虚拟串口驱动作为串口应用程序和USB外设之间的桥梁，具有如下特征：

1. **静态的设备点(Device Node)**

   ​	USB设备是个典型的即插即用设备，驱动程序在设备连接成功后加载并在设备移除时卸载。一个兼容支持即插即用功能的应用程序可以检测到设备的插入和移除并能够关闭和打开设备驱动程序的句柄。在设备移除的时候，不兼容即插即用功能的应用程序会产生错误。即使在设备重新连接到应用程序之后，设备驱动程序的句柄仍然为无效的句柄。此时，这类应用程序必须要先重启自己然后重新建立，才可能和支持即插即用的驱动进行通信。

   ​	虚拟串口的一个功能是支持先前不兼容即插即用功能的的应用程序。应用程序可以在设备被移除或重新连接后使用已经打开的句柄。修改驱动程序的INF文件可以设置这个功能。如果设置了这个功能，驱动程序的行为如下：

   - USB设备移除以后，设置CTS，DSR，RI，DCD信号设置为无效。如果应用程序正在等待某些事件，返回事件发生的信号。
   - 设备移除后，接收所有的类的请求，但是不发送这些请求到USB设备。
   - 读写请求加入读写IRP队列。超时后，返回超时状态并通知应用程序传输的字节数为0。
   - 设备重新连接后，串口的状态设置为默认的状态，串口的默认态存储在设备对象的驱动扩展中，并用事件通知应用程序当前的状态。如果USB设备的状态已更新，立即将此状态通知应用程序。
   - 读写模块启动，处理未完成的写操作，并返回读取到的数据至应用程序。

   如果USB设备从电脑移除，设备可能会丢失它当前的状态信息，而且，在USB设备移除的时候传输的数据也可能会丢失。设备移除之后的读写操作会在超时之后结束。如果这种情况发生，没有检测到USB设备已经移除的应用程序会产生错误。虚拟串口驱动程序启用了这个功能之后，如果设备没有连接到电脑，应用程序不能打开虚拟出的COM端口，并且在设备管理器当中没有虚拟COM端口节点。

2. **块传输**

   ​	虚拟COM端口模拟了真实的COM端口，它传输的数据是数据块而不是串口上的字节流。这会对串口API产生一些影响。传输到COM端口的数据块与传输到USB设备上的数据块没有直接的关系。电脑和PC设备间传输的数据在某些情况下需要传输一个短的数据包,比如： 

   - 传输的数据可以根据FIFO的大小分为几个小的数据包。
   - 传输的数据包长度小于INF文件中指定的读写缓冲的大小。
   - 完成某此数据传输后，没有需要立即传输的数据。

3. **流量控制**

   ​	==虚拟串口驱动程序中的流量控制使用了USB协议中规定的流量控制方法，而与串口应用程序设置的控制信号以及选择的流控方式无关==。如果连接到虚拟串口的应用程序没有读取数据或者是所有的输入缓冲区为满，电脑停止发送IN令牌。如果设备中的FIFO缓冲区为空，他会向电脑发送NAK令牌。电脑中的应用程序和设备中程序间传递的与设备相关的特殊信号只会作为数据传输，不会影响虚拟串口驱动程序的正常工作。

4. **循环缓冲区**

   ​	虚拟串口驱动程序为输入和输出数据各维护一个循环缓冲区。缓冲区的大小可以通过调用windows函数SetupComm()实现。如果循环缓冲区的大小被修改，缓冲区中的所有数据都会被清空。驱动程序设置了缓冲区的范围为128字节和128000字节之间，默认值为4096字节。循环缓冲区的大小会影响数据的传输速度，比如，在发送相同长度的数据时，一个小的缓冲区会增加发送的处理次数。

5. **数据传输**

   ​	应用程序打开COM端口后，驱动程序开始传输数据；应用程序关闭COM端口后，驱动程序结束传输数据。这样处理，驱动程序不会占用系统额外的带宽。

6. **启动初始化**

   ​	在应用程序打开COM端口时，驱动发送标准的USB请求清空端点的停止状态，清除总线上的错误并清理FIFO中的数据。应用程序也可以调用ClearFeatureOnStart()函数实现同样的功能，这个函数的定义在INF文件中说明。

7. **Overlapped模型**

   ​	如果应用程序打开串口时指定了overlapped模式，那么每个windows函数调用都可以返回状态吗ERROR_IO_PENDING。Windows操作系统允许驱动支持这种模式，不过每个串口驱动程序的实现方式可能不同，因此应用程序需要以正确的方式调用windows函数。

8. **加强的错误恢复**

   ​	主机和USB外设之间的数据传输通过循环冗余校验码保证正确性。如果一个传输失败，主控制器会重试3次。如果传输了3次之后仍然传输失败，主控制器通知操作系统这个错误，让他启动错误处理流程。加强的错误恢复是指处理错误的时候不丢失数据。为了实现加强的错误恢复功能。这个长度标志不限制数据传输的长度，也不限制主机一致发送这个长度的数据包。它是指在数据传输的时候发生了硬件错误之后，需要重传的数据块的长度。重传缓冲区的长度必须为USB端点的整数倍。为了确定这个长度的大小，需要考虑两个方面的因素。首先，设备必须为每一个端口以及方向都提供足够的空间用作重传缓冲区。其次，如果重传缓冲区太大，设备会需要更多的空间；如果缓冲区太小，数据传输的效率会明显的下降。

   ​	设置了重传缓冲区后，数据操作时如何实现呢？主机发送一个长度为重传缓冲区大小的数据，这些数据块被处理为FIFO的大小的数据块，分几次发送。如果最后的数据块正确的传输到设备当中，设备把这些数据返回给设备中的程序。如果主机发送了小于重传缓冲区长度的数据设备会检测到这是一个短包。这种情况下，重传缓冲区中接收到的数据会返回给设备中的程序。主机端的驱动程序也是如此处理数据的。最重要的一点是，设备在最后一个数据块成功的传输之前需要存储重传缓冲区中的数据。

   ​	错误恢复功能在传输数据时发送硬件错误后发挥作用。比如，主机向设备发送数据时发生了错误。驱动程序检测到了这个错误，它向设备发送丢弃重传缓冲区数据的命令(DiscardRetryBuffer)。设备收到DiscardRetryBufer命令之后，清空重传缓冲区中的数据并设置重传缓冲区的数据量为0。驱动从重传缓冲区的起始位置重传数据。在设备向主机发送数据时的处理方式一样。

### 3.3 本章小结

​	本章首先对Windows驱动程序的分层结构进行了介绍，重点介绍了在分层结构当中处理用户请求的流程。其次，分别介绍了I/O请求包、IRP传递策略、派遣函数和内存分配与管理等重要概念，为本文的设计和实现奠定了基础。最后，研究了分层结构中的USB协议栈以及虚拟串口驱动的特征。



## 第四章 通信命令转换和数据高速传输的设计

​	本章设计了符合通信设备类中抽象数据模型的虚拟串口驱动程序结构，并以此为核心研究设计了虚拟串口通信命令转换和高速数据传输两个主要的模块，给出了两个模块的功能实现方案。

### 4.1 串口和USB间通信命令转换的设计

#### 4.1.1 通信设备类中的USB请求处理

​	通信设备类的抽象数据模型对USB请求的处理基于一般USB驱动对USB请求的处理[^24]。在USB传输系统有主机系统和USB设备等组成。传输事务的发起端为主机，设备作为接受端相应主机发起的事务。主机系统一般采用分层的结构，其层次结构如图4.1所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-e7f384e06505a297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	USB总线接口包括USB主控制器和根集线器，其中USB主控制器负责处理主机与设备之间电气和协议层的互连，根集线器提供USB设备连接点。USB系统使用USB主控制器来管理主机和USB设备之间的数据传输，另外它也负责管理USB资源,如带宽等。应用软件不能直接访问USB设备硬件，而通过USB系统和USB总线接口与USB设备进行交互。

​	USB设备包含一些向主机软件提供一系列USB设备的特征和能力的信息的设备描述符，用来配置设备和定位USB设备驱动程序。这些信息确保了主机以正确的方式访问设备。通常，一个设备有一个或者是多个配置(Configuration)来控制其行为。配置是接口(Interface)的集合，接口指出软件应该如何访问硬件。接口又是端点(endpoint)的集合，每一个与USB交换数据的硬件就为端点，它是作为通信管道的一个终点。图4.2显示了一个多层次结构的通信模型，它表明了端点和管道所扮演的角色。

​	对于USB设备来说，其WDM驱动程序分为USB底层（总线）驱动程序和USB功能(设备)驱动程序。USB驱动程序符合Windows 2000下的内核模式驱动程序的分层体系结构，如图2所示：

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-502d3b018269daf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	USB底层驱动程序由操作系统提供，负责与实际的硬件打交道，实现繁琐的底层通信。USB功能驱动程序由设备开发者编写，不对实际的硬件进行操作，而是通过向USB底层驱动程序发送包含URB(USB Request Block,USB请求块)的IRP，来实现对USB设备信息的发送和接收。采用这种分层驱动程序的设计方法有两个优点：多个USB设备可以通过USB底层驱动程序来协调它们的工作；编写分层驱动程序较之编写单一驱动程序相对简单，且可以节省内存和资源，不易出错。

​	USB驱动程序工作简述如下：当应用程序想对USB设备进行I/O操作，它需调用Windows API函数，I/O管理器将此请求构造成一个合适的I/O请求包（IRP）并把它传递给USB功能驱动程序。USB功能驱动程序接收到这个IRP后，根据IPR中包含的具体操作代码构造相应USB请求块（URB），并把此URB放到一个新的IRP中，然后把它传递给USB底层驱动程序。USB底层驱动程序根据IRP中所含的URB执行相应的操作，并把操作的结果返回给USB功能驱动程序。USB功能驱动程序接收到此返回的IRP后，将操作结果通过IRP返还给I/O管理器，最后I/O管理器将此IRP操作结果传回给应用程序，至此应用程序对设备的一次I/O操作完成。

#### 4.1.2 串口请求控制码处理流程

​	驱动开发需要硬件设备对上层的应用程序展现为虚拟串口。主要的功能是沟通上层应用程序和底层的USB设备，起到一个数据流的桥接作用。而且能够控制USB芯片，操作连接USB的模块完成数据收发的功能。

​	具体的设计为创建一个虚拟串口设备，然后由应用程序连接该串口，由于串口需要涉及到其特有的控制码IOCTL，所以USB-Serial驱动需要将这些控制码进行处理，并转换为相应的USB设备请求。并将转换之后的请求发送给USB设备。然后将USB设备的处理结果保存到虚拟串口驱动的缓冲区，由应用程序调用ReadFile获取返回结果。由于USB设备与串口设备的差异，驱动需要在设备加载时获取USB设备的各种描述符，根据上层需要选择合适的配置信息，这样才可以根据接收到的控制码控制USB外设的状态和数据接收。

​	应用程序通过PurgeComm(),GetCommState()等windows API函数操作串口，而这些串口最终由系统解析为响应的控制码，并将这些控制码发送给USB-Serial驱动，虚拟串口驱动虚拟出来的串口要和真实串口一样支持常用的串口操作，因此驱动在正确地处理这些控制码所表示的控制命令的情况下就可保证模拟出的虚拟串口与实际串口具有相同的特征。

![图片.png](https://upload-images.jianshu.io/upload_images/6128001-05da7e316aa19ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 4.2 数据高速传输的设计

#### 4.2.1 一般虚拟串口驱动数据处理方式

​	串口读写数据的一般流程为：串口应用程序首先通过调用CreateFile打开虚拟驱动程序虚拟出的串口设备，获得串口的句柄，然后通过调用writeFile把需要向串口写入数据的发送至虚拟串口。虚拟串口在接收到数据之后，会根据数据包的大小以及串口当前所设置的奇偶校验位以及停止位设置适当的包长度以及格式

#### 4.2.2 高速传输数据流程的设计



### 4.3 本章小结





## 第五章 通信命令转换和数据高速传输的实现

### 5.1 虚拟串口驱动的加载和卸载模块

#### 5.1.1 虚拟串口驱动的加载模块

#### 5.1.2 虚拟串口驱动的卸载模块



### 5.2 通信命令转换模块的实现

#### 5.2.1  串口通信命令转换的实现

#### 5.2.2 用户自定义命令的实现



### 5.3 数据高速传输模块的实现

#### 5.3.1 数据高速发送模块的实现

#### 5.3.2 数据高速接收模块的实现



### 5.4 驱动测试

#### 5.4.1 模块测试

#### 5.4.2 应用测试



### 5.5 本章小结





#### 





​	

​	 





[^1]: Universal Serial Bus Specification,Revision 2.0. Compaq,Hewlett-Packard,Intel,2000
[^2]: 
[^3]: 
[^4]: 
[^5]: 
[^6]: 
[^7]: 