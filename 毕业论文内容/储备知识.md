# 1. [USB转TTL、USB转串口、USB转RS-232的区别](http://blog.sina.com.cn/s/blog_801127100102vsae.html)

​	因为单片机通信接口的电平逻辑和PC通信接口的电平逻辑不同，PC机上的通信接口有USB接口，相应的电平逻辑遵照USB的原则；还有DB9接口，相应的电平逻辑遵照RS-232原则；而单片机上的串行通信通过单片机的RXD、TXD、VCC、GND四个引脚，相应的电平逻辑遵照TTL原则。

​	进行转换的目的是把电平转换到双方都能够识别的状态。



# 2. [串口、COM口、TTL、RS-232的区别详解](http://www.dzsc.com/data/2016-10-19/110834.html)

1. 串口、COM口指的是物理接口形式(硬件)。而TTL、RS-232、RS-485是指电平标准(电信号)。
2. 在连接设备的时候，一般只会接GND、RX、TX。不会接VCC或者+3.3V的电源线，避免与目标设备上的供电冲突。
3. PL2303、CP2102芯片是USB转TTL串口的芯片，用USB来扩展串口(TTL)电平。
4. MAX232芯片是TTL电平与RS-232电平的专用双向转换芯片，可以TTL转RS-232，也可以RS-232转TTL。
5. TTL标准是低电平为0，高电平为1(+5V电平)。RS-232标准是正电平为0，负电平为1。



**串口、COM口：**

COM口即串行通讯端口，简称串口。这里区别于USB的"通用串行总线"和硬盘的"SATA"。一般我们见到的是两种物理标准。D型的9针插头和4针的杜邦头两种。4针的通常也会有第五根引脚--3.3V电源引脚。





## 2.1 串口通信

​	计算机与计算机之间或者是计算机与终端设备之间的通信方式有串口通信，并行通信以及网络通信等。使用串行通信方式的优点是成本低，使用线路少，而且可以解决由于不同的线路特性造成的问题，因此在远距离传输方面也是一种不错的选择。对于特性相异的设备要使用串行通信来连接时，必须保证双方所使用的的标准接口是一致的。一般的串口标准有RS-232、RS-485等[^12]

### 2.1.1 RS-232串口标准

​	串口通信中，根据实际的设计需要可以选择同步传输和异步传输2中方式。同步传输方式就是指在传输的过程中不需要再每一个字符之间进行停止然后再开始的操作，这样可以使得效率提高，不过由于更加复杂的传输，收发两端的时间一致性要求比较高，误差率要求比较低[^14]。同步传输方式适用于一端和多端之间的串口数据传递。异步传输方式是要针对每一个字符都完成开始和停止的操作，这样导致通信效率略低，不过由于传输很容易，收发两端的时间一致性要求比较低，可以许可一些误差的存在。异步传输方式适用于一端到一端的数据传输[^15]。		

​	从通信的方向性来看，串口通信有单工、半双工和全双工三种方式。单工通常使用一根导线，通信只在一个方向进行，如监视器、打印机、电视机。半双工可以在两个方向上进行，但是方向切换时有时间延迟，如打印机。全双工可以在两个方向上运行，且时间的切换没有时间延迟，适用于那些不能有时间延迟的交互式应用，如远程监控等。

### 2.1.3 端口参数

​	XON/XOFF是控制字符流启动的标志。发送端和接收端将这两个字符给予不同于普通字符的含义，在要发送的数据中插入这两个字符标识开始和结束，以此来控制字符流。在多数情况下，握手信号线DSR作为渠道，DCE通知DTE已经可以接收传送来的数据，这个过程叫做硬件设备流控制[^19-20]。第一个异步传送适配器可以得到硬件中断4，然后第二个异步传送适配器可以得到硬件中断3(其中0是定时器，1是键盘，2是保存，3和2串联，4和1串联，5是硬盘，6是软盘，7和1并联)，COM1地址范围是3F8-3FF，COM2地址范围是2F8-2FF。

​	串口通信技术在工程使用中主要是用于数据的采集，计算机系统的监控等方面，串口通信技术在应用中通常采用的流程图模型如下所示：

![串口通信技术在工程中应用流程](http://upload-images.jianshu.io/upload_images/6128001-8d2dac1f2e127473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 2.2.2 线程间通信

​	在进程的运行过程中,他所建立的不同线程之间有时候需要进行数据的交互。通常的话可以建立全局变量，这也是最简单的线程间数据共享的方法[^26]。建立的全局变量使得所有的线程都可以在自己地址空间中使用这个变量。一般的情况下全局变量是在实现文件的头部定义，在同一个进程中的不同线程都可以使用它[^27]。

​	还有一种情况是某一些线程之间要进行一些状态的交换，比如说工作者线程有时候要把状态传递给主线程，主线程做出相应的操作，在这种情况下可以使用消息机制，因为使用全局变量的话是难以达到这个作用的。基于这个情况，使用用户自定义消息是个不错的选择。通过在消息中指定要发送到线程以及指定消息的参数来承载要发送的消息，然后使用API来将消息发送到指定的线程的消息队列中等待处理。而接收消息的线程不断在处理消息队列中的消息。这个过程总结起来包括4个环节，开发人员自定义的消息，声明消息回调函数，定义消息回调函数中对消息的处理，以及发送自定义的消息。

### 2.2.3 线程同步

​	在多线程的使用当中，不同的线程有时候要访问以及修改同一个资源，就会造成也许不是开发人员所预期的结果，或者造成一些冲突。这种情况下，就有了线程同步。同步的方式主要有四种：临界区(Critical Section),信号量(Semaphore),互斥体(Mutex),事件(Event)。

- 临界区(Critical Section): 保证在进程中的资源在一个时刻上只能有一个线程可以访问到。使用这种方法的过程中，多个线程将会访问以及修改某一个共享的资源对象，这个资源对象将会有一个临界区，对于不同的线程，同一个时刻只能有一个线程进入到这个临界区，这个线程可以访问到该资源对象，其他线程请求访问这个资源的时候发现这个临界区被占用，就只能够等待。当占据临界区的线程使用完了以后释放了该临界区，其他的线程再按照优先级来确定哪个线程进入。也就是说，资源在某一个时刻只能够由一个线程使用[^29]。临界区和临界区对象是处于对应关系的。当线程需要访问某个数据资源，该线程就调用lock()方法以占据临界区。当着额数据资源使用完毕以后，该线程再调用Unlock()方法以释放临界区对象，这样就使得其他线程可以对该数据资源进行访问。
- 互斥体(Mutex)：类似于临界区，不过在使用过程上更加复杂。而且临界区只能够用于同一个进程中的不同线程之间的同步，互斥体可以在不同的进程之间进行同步。在使用的过程中，首先通过CreateMutxe()来建立一个句柄或者说是互斥体，然后通过OpenMutex来打开这个资源的互斥体，其他的线程通过使用WaitForSingleObject()来检测这个资源是否得到了释放。当使用资源的互斥体使用完毕以后，通过ReleaseMutex()来释放该资源的使用权。
- 信号量(Semaphore)：类似于互斥体，信号量允许同一个资源在某一个时刻由不同的线程访问，这其中引入了一个计数机制。在使用的过程中，首先使用CreateSemaphore()来创建一个句柄或者说是信号量，然后通过OpenSemaphore()来打开信号量，其他在等待使用该资源的线程通过WaitForSingleObject()来检测资源被使用线程的数量是否达到设定值[^30]。当使用完成以后，可以使用ReleaseSemaphore()来释放该线程对这个资源的使用，同时计数也减1。
- 事件(Event)：是通过通知操作的方式来保持线程的同步。在使用过程中，首先通过CreateEvent()来创建一个句柄或者说是事件对象，接下来通过OpenEvent来打开已经创建的事件对象，然后通过线程调用资源时使用SetEvent()和ResetEvent()来控制这个事件的信号
- ​



[^12]: 
[^14]: 
[^15]: 
[^19]: 
[^20]: 
[^26]: 
[^29]: 





以下内容摘自[嵌入式Linux设备驱动程序的设计与研究](http://xueshu.baidu.com/s?wd=paperuri%3A%28866d414b8629ae2469f1440d13a31dd0%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http%3A%2F%2Fwenku.baidu.com%2Fview%2F1a823a2dcfc789eb172dc88f.html&ie=utf-8&sc_us=3038571180740317288)

# 第三章 嵌入式Linux下USB设备驱动的设计与研究







# Qt的特点

​	Qt是一个跨平台的C++应用程序框架，支持Windows、Linux、Mac OS X、Android、iOS、Windows Phone、嵌入式系统等。也就是说，Qt可以同时支持桌面应用程序开发、嵌入式开发和移动开发，覆盖了现有的所有主流平台。你只需要编写一次代码，发布到不同平台前重新编译即可。

​	Qt不仅仅是一个GUI库，他除了可以创建漂亮的界面，还有很多其他的组件，例如，你不在需要研究STL，不在需要C++的\<string\>头文件，不再需要去找解析XML、连接数据库、socket的各种第三方库，这些Qt都已经内置了。

​	Qt虽然庞大，封装较深，但是它的速度并不慢，虽然不及MFC，但是比Java、C#要快。Qt程序最终会编译成本地代码，而不是依托于虚拟机。



## Qt可以做什么

​	使用Qt开发的程序非常多。1997年，Qt被用来开发Linux桌面环境KDE，大获成功，使得Qt成为Linux环境下开发C++ GUI程序的事实标准。Linux也是嵌入式的主力军，广泛应用于消费类电子、工业控制、军工电子、电信/网络/通讯、航空航天、汽车电子、医疗设备、仪器仪表等相关行业，这些地方都有 Qt 的影子。

​	在Windows下，GUI的解决方案比较多，基于C++的有Qt、MFC、WTL、wxWidgets、DirectUI、Htmlayout，基于C#的有WinForm、WPF，基于Java的有AWT、Swing，基于Pascal的有Delphi，还有国内初露头角的aardio；若你有Web开发经验，也可以基于Webkit或者是Chromium将网页转换为桌面程序。



## Qt 开发 Windows 桌面程序的优点

- 简单易学：Qt 封装的很好，几行代码就可以开发出一个简单的客户端，而 MFC 封装简陋，还需要了解 Windows API，普遍反映难学。
- 资料丰富：资料丰富能够成倍降低学习成本，否则你只能去看源码，关于 DirectUI、Htmlayout、aardio 的资料就很少。
- 漂亮的界面：Qt 很容易做出漂亮的界面和炫酷的动画，而 MFC、WTL、wxWidgets 比较麻烦。
- 独立安装：Qt 程序最终会编译为本地代码，不需要其他库的支撑，而 Java 要安装虚拟机，C#要安装 .NET Framework。
- 跨平台：如果你的程序需要运行在多个平台下，同时又希望降低开发成本，Qt 几乎是必备的。



## 使用Qt开发的程序

​	WPS、YY语音、Skype、豆瓣电台、虾米音乐、淘宝助理、千牛、暴雪的战网客户端、VirtualBox、Opera、咪咕音乐、Google地图、Adobe Photoshop Album 等。

​	但是，由于Android本身支持Java，iOS本身支持Objective-C和Swift，所以Qt 在移动端的贡献寥寥无几。







# VxWorks中的互斥

​	当共享地址空间进行简单的数据交换时，为了避免竞争，需要对内存进行互锁。实现资源互斥访问的方法很多，不同之处仅仅在于互斥的范围。例如禁止中断、禁止抢占、以及信号量对资源的上锁等情况。

## 1. 中断上锁和响应时间

​	对于互斥而言使用最强有力的办法是==禁止中断==，这种上锁的方法保证了对CPU的单独访问。

```c++
funcA()
{
  int lock = intLock();
  ...//禁止中断的代码临界区
  intUnlock(lock);
}
```

​	但是这种方法涉及到使用中断服务程序的互斥，由于它在上锁期间阻止系统对外部事件的响应，因此对于大部分实时系统而言不能够作为一种通用的互斥方法，一旦要求紧急响应外部事件，此时的终端响应时间将是难以接受的。然而在使用中断服务程序时，有时候又需要中断上锁，在这种情况下应该尽可能的使得中断上锁时间短。

## 2. 抢占上锁和响应时间

​	当不允许其他任务抢占当前执行任务的时候，禁止抢占提供了一种较小限制性的互斥，此时，中断服务程序仍然能够执行。

```c++
funcA()
{
  taskLock();
  ...//禁止中断的代码临界区
  taskUnlock();
}
```

但是使用这种方法可能会造成系统实时性得不到充分的保证。尽管高优先级任务本身没有涉及到临界区，然而该任务只能够在上锁任务离开临界区之后才能够执行。



# VxWorks中的信号量

​	在VxWorks中信号量被高度的优化，并提供了最快速的任务间通信机制。信号量是互斥和任务间同步最主要的手段。对于互斥而言，信号量可以对共享资源进行互锁，并提供比禁止中断和抢占上锁更为精确的互斥程度；而对于同步而言，信号量可以协调外部事件与任务之间的执行。

​	VxWorks操作系统提供了三种类型的wind信号量来解决不同类型的问题：

1. 二进制-----最快最通用的信号量，适用于同步和互斥；
2. 互斥----为了解决内在的互斥问题、优先级继承、删除安全以及递归等问题而最优化的一种特殊二进制信号量；
3. 计数----类似于二进制信号量，但是其跟踪信号量被释放的次数适用于单个资源多个实例需要保护的情况。

## 1. 二进制信号量

​	使用二进制信号量能够满足两种任务的协调需要：互斥和同步。二进制信号量需要的系统开销最小，因此特别适合于高性能的需求。在不需要使用互斥量的高级特性时，二进制信号量仍可用于互斥。二进制信号量可被用作一个标志；资源可用(full)或则不可用(empty)。当任务调用semTake()函数提取二进制信号量时，其结果依赖于被调用时信号量时可用的(full)还是不可用的(empty)；如图2-6所示。当任务调用semGive()函数释放二进制信号量时，其结果依赖于被调用信号量是可用的(full)还是不可用的(empty);如图2-7所示。

![image.png](https://upload-images.jianshu.io/upload_images/6128001-c4f29516d0df82c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1 互斥

​	二进制信号量能够有效的对共享资源的访问进行互锁。与禁止中断和抢占上锁不同，二进制信号量仅仅限制了相关资源的互斥范围。使用该技术时需要创建信号量来保护资源，信号量在最初创建时状态为可用(full).

```c++
SEM_ID semMutex;
semMutex = semCreate(SEM_Q_PRIORITY，SEM_FULL)；
semTake(semMutex,WAIT_FOREVER);
...//临界区，任何时候仅单个任务可以访问。
semGive(semMutex);
```

当任务访问资源时，首先要获取信号量，只要任务持有信号量，其他所有需要访问该资源的任务将会被阻塞。当该任务结束资源访问时释放信号量，允许其他任务访问资源。因此，对资源的所有访问需要互斥时，可以使用函数semTake()和semGive()来实现。

### 1.2 同步

​	当信号量用于任务同步时，信号量可以用作是任务等待的一个状态或者是事件。任务或者是中断服务程序通过释放信号量来表明事件的发生。调用semTake()函数提取信号量的其他任务处于等待状态，这些等待任务被阻塞，直至事件发生，并释放信号量。注意信号量在互斥和同步时状态次序不同。对于互斥，信号量初始时为可用(full),每一个任务先提取信号量，然后再释放，但是对于同步，信号量初始时为不可用(empty),每一个任务都需要等待提取被其他任务释放的信号量。



## 2. 互斥信号量

​	互斥信号量是一种用于解决内在互斥问题的特殊的二进制信号量，包括优先级倒置、删除安全以及资源的递归访问。互斥信号量的基本行为与二进制信号量一致，不同之处如下：

- 它仅用于互斥；
- 他仅能由提取它(即调用semTake())的任务释放；
- 不能够在中断服务程序中释放；
- semFlush()函数操作非法；



### 2.1 优先级倒置

`semId = semMCreate(SEM_Q_PRIORITY | SEM_INVERSION_SAFE);`

### 2.2 删除安全

​	互斥的另外一个问题涉及到任务的删除，一个受到信号量保护的临界区域内经常需要保护执行任务避免被意外的删除。删除一个在临界区执行的任务可能会导致意想不到的后果。资源可能会处于破坏状态，同时受保护的信号量不再可用，直接终止对该资源的所有访问。

### 2.3 递归资源访问

![image.png](https://upload-images.jianshu.io/upload_images/6128001-4626283a3f98a45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	互斥信号量能够递归获取，这意味着持有信号量的任务在最终释放其之前能够多次地提取。递归非常适用于一组需要互相调用的子程序同时又需要进行资源互斥访问的情况。由于系统保持跟踪当前那个任务持有的互斥信号量，因此这是能够实现的。

​	在释放信号量之前，递归获取的互斥信号量被释放和提取的次数应该相等。这通过一个计数器跟踪实现，每调用semTake()计数器加一，没调用semGive()计数器减一。



## 3. 计数器信号量

​	计数器信号量也是实现任务间同步和互斥的另外一种手段。计数器信号量与二进制信号量相似，它也是跟踪信号量被释放的次数。每释放一个信号量，计数器加一；每提取一个信号量，计数器减一，当计数器为零时，试图提取信号量的任务将会被阻塞，与二进制信号量一样，如果信号量被释放的时候存在被阻塞的任务，那么被阻塞的任务将会被解除阻塞。与二进制信号量不同的是，如果信号量被释放时不存在阻塞的任务，那么计数器将会加一。这意味着一个被释放两次的信号量，可以被无阻塞的提取两次。

​	计数信号量适用于保护多份复制的资源。例如，可以使用一个初始值为5的计数器信号量来协调五个磁带驱动器的工作；或者是使用初始值为256的计数器信号量来实现一个有256个入口的环形缓冲器。计数器信号量的初始值以参数形式用于semCCreate()中。





# VxWorks 文件系统

​	VxWorks操作系统中的I/O系统可以提供简单、统一、与任何设备无关的接口，它包括基本I/O系统和缓冲I/O系统。

​	在VxWorks中和linux中类似，也把一切当成文件来看。==系统中由驱动程序负责控制各种设备。通常，对I/O系统的操作并不需要深入的了解各种设备和驱动程序的运行方式。但是VxWorks操作系统当中的I/O系统对控制各种指定的设备具有很强的灵活性。驱动程序既可以运行于传统的方式之下，又可以在特定的应用程序中采用不同的方式。==

​	虽然所有的I/O操作都指向已命名的文件，但是它也分为两种不同的类型：基本操作和缓冲操作。这两种类型的操作区别在于数据缓冲的方式和调用I/O的方式。



​	VxWorks中的基本I/O接口在标准C语言库中与I/O原语兼容。包括create()、open()、close()、delete()、read()、write()、ioctl().



​	VxWorks操作系统中的I/O设备库包含有一个和UNIX和Windows操作系统中的stdio包相兼容的缓冲型I/O设备包，并且完全支持ANSI C语言。虽然VxWorks中的I/O操作效率较高，但是系统仍然需要花费一些与每一个底层函数调用有关的额外开销。

​	==第一种情况是为了实现某一个功能，I/O系统先调用与设备无关的功能函数(如read()、write()等)，然后再调用与驱动程序相关的底层函数。==

​	==第二种情况是大多数驱动程序都会采用互斥或者是队列机制来避免发生因同事调用同一个驱动程序而导致多个用户程序互相影响的情况。==



# VxWorks操作系统中的设备

## 1.串行I/O设备(包括终端和伪终端设备)

​	VxWorks操作系统提供了多种终端和伪终端设备驱动程序(tty和pty驱动)。tty用于驱动实际的终端设备，pty驱动程序用于模拟终端设备。这些伪终端设备在诸如远程登入等应用中很有用。

​	VxWorks操作系统中的I/O设备是从一个缓冲型的串行字节流设备。每一个设备都有一个环形缓冲区用于输入和输出操作。从一个tty型设备中读取数据实际是从输入环形缓冲区中提取数个字节数据；向一个tty设备中写入数据实际上是向输出环形缓冲中加入数个字节数据。在操作系统初始化的过程中创建设备时，指定每一个缓冲区的大小。



2. 管道设备：由pipeDrv文件负责管理管道设备，管道设备使用核心信息队列进行实际信息传输操作。
3. 伪存储设备
4. 网络文件系统(NFS)设备
5. 非NFS网络设备
6. CBIO接口：核心缓冲区块存取输入/输出(CBIO)组件“INCLUDE_CBIO_MAIN”提供了针对多种文件系统(dosFs和rawFs等)的接口，用户在使用这些文件系统时需要在系统内核中包含该组件
7. 块存取设备：块存取设备是由一系列可以独立访问的数据块组织起来的设备。最普通的块存取设备就是磁盘。在VxWorks中“块”表示在设备中可寻址的最小单位，对于大多数磁盘设备，与VxWorks操作系统中“块”相对应的术语是“扇区”。



# 与MS-DOS兼容的文件系统：dosFs文件系统

dosFs文件系统是一种与MS-DOS文件系统兼容的文件系统，它能够满足实时应用的多种要求。其主要特点如下：

- 支持层次化的文件和目录结构，能够在一个磁盘上建立一定数目的文件并进行有效的管理；
- 可以将每一个文件指定为连续存储或者非连续存储
- 广泛兼容各种可存储和可检索媒体(如软盘、硬盘)；
- 可以从dosFs文件系统中启动VxWorks操作系统；
- 支持VFAT和VXLONGS的目录机构；
- 支持FAT12、FAT16和FAT32文件分配表格式。



# 中断处理与定时机制

## 1. 看门狗定时机制

​	VxWorks中包括一个看门狗定时器机制，它允许任何C函数与一个特定的时间延时器联系。看门狗定时器应该作为系统时钟中断服务程序的一部分来维护。

​	被看门狗定时器调用的函数通常作为系统时钟中断级的中断服务代码来执行。但是如果内核由于某种原因不能够立即执行函数(例如一个优先中断或者是内核状态)，函数将放在tExcTask工作队列当中，tExcTask工作队列中的函数以tExcTask(通常是0)优先级来执行。

​	下表中的函数由wdLib提供

|     调用     |       功能描述       |
| :--------: | :--------------: |
| wdCreate() |  分配并初始化一个看门狗定时器  |
| wdDelete() |  终止并释放一个看门狗定时器   |
| wdStart()  |    启动一个看门狗定时器    |
| wdCancel() | 取消当前的一个计数的看门狗定时器 |

看门狗定时器由wdCreate()函数创建；由wdStart()函数启动，函数参数为：延迟tick数、需要调用的C程序以及传递给该函数的参数。一旦指定的tick结束，函数将会使用指定的参数进行调用。在定时器结束计算之前的任何时间内，调用wdCancel()函数会取消看门狗定时器的执行。

## 2. 中断服务程序

​	



## 3. POSIX时钟和计时器

​	实时系统扩展(1003.1b)的POSIX标准为内核设备提供了一套接口，为了提高应用的可移植性，VxWorks内核“wind”包括了POSIX接口，以及专门用于VxWorks设计的接口。

​	POSIX标准提供了一种可以识别多个虚拟时钟的方法，但是只有系统的实时时钟是必须的，VxWorks系统中不支持虚拟时钟。

​	POSIX计时器提供了在未来某一个时刻任务对其自身发送信号的函数；这些函数用于创建、设置和删除一个计时器。当计时器的执行完成之后，向任务发送默认的信号SIGALRM。如果要执行一个在计时器结束后执行的信号处理程序，可以调用函数sigaction()。

```C++
#include "VxWorks.h"
#include "time.h"
int createTimer(void)
{
  timer_t timerId;
  if(timer_create(CLOCK_REALTIME,NULL,&timerId) == ERROR){
    printf("create FAILED\n");
    return (ERROR);
  }
  return (OK);
}
```

nanosleep()作为POSIX的一个附加功能，与wind中的taskDelay()类似，用来指定一个以秒或纳秒为单位的睡眠或延迟时间，只不过taskDelay()的单位为tick。两者精度相同，都是由系统时钟速率决定的，只是单位不同而已。



# POSIX与Wind的比较

**1. POSIX和Wind调度方法比较**

- POSIX基于进程调度，Wind基于任务调度
- POSIX使用了FIFO调度术语，VxWorks使用基于优先级的抢占式调度。两者仅仅是表达不同，都使用了相同的基于优先级的策略。
- POSIX在进程到进程的基础上应用调度算法;Wind的调度算法应用于整个系统，即所有任务既可以使用轮转，也可以使用基于优先级调度。

**2. POSIX和Wind信号量比较**

POSIX信号量属于计数信号量，即他们会跟踪信号量被释放的次数。除了下列Wind信号量提供的附加特征外，Wind信号量机制与POSIX中信号量机制类似；而且下列特性起了重要的作时，Wind信号量性能更优越。

- 优先级继承
- 任务删除安全
- 对于单任务多次获取信号量的能力
- 互斥信号量的所有权
- 信号量超时
- 队列机制选择



# VxWorks中创建应用程序的两种方式

在RTOS当中内存的管理有两种模式：分时模式和保护模式。

## 1. 可下载的应用程序

​	可下载应用程序是一个可以重定位的目标模块组合，这些目标模块可以下载并且动态的链接到VxWorks，从shell或者debugger启动。











# 编写驱动程序

​	在设计驱动程序时一般的顺序应该是从上到下，但是在执行以及对驱动程序进行测试的时候，一般顺序应该是从下往下。

## 1. 从上至下设计

​	从上至下的设计步骤意味着在开始正式编码之前，要进行开发计划并且对可行性进行证明。

**1.1 模板文件**

​	开发驱动程序可以从模板文件或者现有的驱动程序开始。建议使用模板文件开始设计驱动程序，若使用现有的文件通常会引入其他驱动程序代码的很多问题。WindRiver为所有类别的驱动程序提供了模板文件。

**1.2 模块描述**

​	将芯片资料手册中对该芯片的介绍性文字拷贝到模块的描述部分，然后再加上一段文字描述这个驱动是如何工作的，驱动程序对芯片哪一些部分进行了控制，以及驱动程序所支持的操作模式等内容。

**1.3 设备结构**

​	从定义每一个设备的基本数据结构和每一个驱动程序的基本数据结构开始，这些结构定义了驱动程序和每一个设备的状态。像结构体一样，只用一个简单的打印命令，调试器就可以显示出它们的全部状态。

**1.4 宏定义**

​	证明所有用来为不同应用所定制的驱动程序的宏，比如访问芯片宏、访问存储器宏等。告诉用户这些宏的作用是什么，以及它们的默认值是如何定义的。

**1.5 子程序声明**

​	声明用户以及BSP编写者使用这个驱动器可能会需要的所有的子程序。尽可能的使得硬件设计和软件设计一致。

**1.6 设计功能函数**

​	为所有计划编写的函数建立标志和声明，先使它们的内容是空的，直到已经确实准备好编写其中的代码。在注释块中写上对子程序的描述，注释块中的注释比代码部分中的注释要重要的多。



## 2. 从下至上测试

​	在完成对驱动程序的计划，以及初步形成了由函数和数据结构构成的骨架之后，就可以开始准备执行和测试了。

**2.1 编写代码**

​	从设备初始化开始，编写代码来接受一个设备的数据结构并为以后的使用而对它进行初始化。为所有其他低级别的驱动程序函数添加内容。可以进行一次测试编译，来核实是否所有必须的程序都已被声明。检查目标模型中的符号来确认只有所有额外部程序未被执行，在编写代码时要注意以下两方面的问题：

- 避免在驱动程序中使用printf()：即使目的是为了调试，也要避免在驱动程序中使用printf(),可以使用logMsg()来代替。在驱动程序和I/O系统之间可能会有系统的交互作用，这可能会使printf()导致系统瘫痪。
- 调用intConnect()：不要从sysHwInit内部调用intConnect(),或者任何其他的调用malloc()的程序，因为内存分配库还没有被初始化，系统将会瘫痪。

**2.2 测试、调试、重编译**

​	一般的测试、调试和重编译是一个循环的过程。个人的不同选择和偏好影响着这一阶段，一些人一次只对一个程序进行编码和测试。

**2.3 一次完成一层**

​	对代码的每一层重复的进行编写、测试、调试、重新编译的循环工作。对每一层进行全面的测试可以提高工程的可信度。企图一次编写全部的代码是难以做到的。

**2.4 性能测试**

​	应该进行一系列的基准程序的测试，来证实这个设备可以满足一般的客户需求。仅能够提供5MB/s网络吞吐量的带宽SCSI设备，是不能够很好的满足客户的要求的。工程设计师有必要编写一个完整的性能测试基准程序作为整个项目的一部分。





# 驱动程序的轮询和中断处理

​	设备驱动通常会采用两种方式来获取硬件事件的发生或者状态的改变：

1. 轮询(polling)方式：周期性查询硬件时间的发生。实际上是通过读取设备的状态寄存器来获取设备状态的改变或事件的发生,然后再进行相应的处理。
2. 中断处理方式：当事件发生或状态改变时，硬件产生中断，然后执行相应的中断服务程序。

采用轮询方式时，如果一个系统有多个外部设备，那么CPU只能够轮流的对每一个外部设备进行查询，而这些外部设备的速度往往并不相同。这时CPU显然不能很好满足各个外部设备随机性的状态改变或事件发生。所以，这种方式的实时性比较差。

为提高实时性，通常采用中断处理方式来通知系统外部设备的事件发生或状态改变。因为在中断处理方式下，外部设备具有申请CPU服务的主动权，当设备的事件发生或状态改变时，便可以向CPU发出中断请求，使CPU暂停当前的工作而处理外部设备的请求。在这种方式下，CPU不必花费大量的时间查询外部设备的工作状态，显然提高了系统的实时性能。

## 1. 轮询

​	当使用不支持中断方式的设备时，可以通过轮询的方式对设备进行管理。而轮询方式可以采用下面的几种实现方式：

- 驱动程序任务在系统空闲时进行设备轮询
- 驱动程序任务周期性的进行设备轮询
- 驱动程序通过看门狗定时器进行设备轮询
- 驱动程序通过辅助时钟进行设备轮询

## 2. 中断

​	在微处理器的中断机制中，包含两类中断源，它是通过外部设备接口向CPU中断请求引脚“INTR”和“NMI”发出中断请求信号引起中断的，这类中断称为硬中断(或称为外部中断)。另外一类中断是内部中断(软中断)，内部中断是通过CPU执行中断指令产生的，或者是CPU在执行程序时遇到了一些异常情况产生的，像除法错误，溢出中断等都是产生内部中断的中断源。

​	中断管理在VxWorks中是一个重要的组成部分，因为系统是以中断的方式响应外部事件的发生。为了快速响应中断，中断服务程序ISR运行在特定的空间，不同于其它任何任务。因此与任务不同的是，中断处理没有任务的上下文切换。

​	以下是一些VxWorks常用的注册和卸载设备以及设备驱动程序的函数：

|       函数        |      描述      |
| :-------------: | :----------: |
| IosDrvInstall() |    注册设备驱动    |
| IosDrvRemove()  |    卸载设备驱动    |
|  IosDrvShow()   | 显示系统中所有的设备驱动 |
|   IosDevAdd()   |    注册一个设备    |
| IosDevDelete()  |    卸载一个设备    |
|  IosDevFind()   |    查找一个设备    |
|  IosDevShow()   |  显示系统中的所有设备  |



中断处理操作中，应注意下面一些问题：

- 中断服务程序(ISR)的安装；
- 中断服务程序可以进行什么操作，不可以进行什么操作；
- 中断服务程序的调试。

### 2.1 中断服务程序

​	中断服务程序是用户自定义的一个程序，只有当中断产生时它才执行，该程序拥有独立于任务的上下文。在中断服务程序中，不能够执行过多的I/O操作，不可以获取信号量，不可以分配内存，不可以申请任务控制块。像printf()、malloc()、semTake()、taskIdSelf()函数都不能使用，但是可以使用semGive()、logMsg()、msgQSend()以及bcopy()。

​	用户在使用中断服务程序之前，必须要采用一定的方法，将中断服务程序的入口地址放置在中断向量表上与中断类型号相应的位置中。当中断到来的时候，CPU会自动地取出中断向量表中的相应的内容送入IP寄存器和CS寄存器，从而改变程序的执行方向，转入中断服务程序的执行。

### 2.2 处理中断

​	事实中的中断处理并不是简单的执行C语言函数，它需要保存当前系统寄存器的状态以及正在执行的代码，然后装载中断堆栈，最后调用连接在中断向量上的中断服务程序。中断处理完成之后，从中断服务程序函数返回时，系统需要恢复寄存器和堆栈，并退出中断。这个中断处理过程如下：

1. 当设备产生IRQ(中断请求)时，中断当前任务并取中断类型号；
2. 在中断应答期间，系统决定哪个设备需要服务(计算中断向量地址)；
3. 为设备调用适当的函数(系统注册的设备中断服务程序)；
4. 在VxWorks定义的中断包裹函数里，保存有寄存器值以及调用用户定义的中断服务程序；
5. 中断处理结束之后，从中断服务程序返回并恢复寄存器的值；
6. 若执行中断服务程序之后，没有高优先级的任务运行，则恢复被中断任务的执行。



### 2.3 中断优先级

​	系统中存在多个设备用中断和CPU进行数据传输时，就有一个中断优先级处理的问题。通常在嵌入式系统当中对中断优先级采用以下的三种方法来解决：

1. 软件查询法：当硬件系统无法确定中断处理优先级时，可以通过软件来决定硬件设备的中断优先级。这种方法的优点是节省硬件，不需要判断优先级的硬件排队电路，而是使用程序的优先级来确定设备中断的优先级。这种方法的缺点是设备发出中断请求信号到CPU转入相应的服务程序入口的时间较长。
2. 简单的硬件方法(菊花链)：在每个外设对应的接口上连接一个逻辑电路，这些逻辑电路构成一个称为菊花链的结构。由菊花链来控制中断回答信号的通路。有了菊花链之后，各个外设接口就不会竞争中断回答信号，因为菊花链已经从硬件的角度根据设备在链中的位置决定了它们的优先级，越靠近CPU的设备，优先级越高。
3. 专用硬件方法：在嵌入式中，解决中断优先级管理的常用方法是采用可编程的中断控制器。可编程中断控制器中的中断类型寄存器、屏蔽寄存器都是可编程的，而且优先级排列也是按指令来设置的，所以可编程控制器使用起来很灵活方便。



### 2.4 中断号与中断向量的转换

​	嵌入式系统给每种中断都安排了一个中断类型号(中断号)。每种类型的中断都应该由相应的中断处理程序来处理，而中断向量表用来存放中断服务程序的入口地址。

​	例如在PC系统中，存储器的低1.5KB字节，即地址从0 ~ 5FFH为系统所占用，其中最低的1KB字节，地址从0 ~ 3FFH存放中断向量表。中断向量表中的256项中断向量对应256种中断类型，每项占四个字节(如下表所示),所以每类中断向量的地址可以由中断类型号乘以4来计算处理。

![image.png](https://upload-images.jianshu.io/upload_images/6128001-85291b258982e499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在VxWorks中，中断向量号与中断向量地址通过函数INUM_TO_IVEC(intNum)来转换。如下：

```C++
UINT32 uiIntVec；
BYTE irqNum = 0x9；
uiIntVec = (UINT32)(INUM_TO_IVEC(irqNum));
```

​	采用中断向量的方法大大加快了中断处理速度，因为计算机可以直接通过中断向量表跳转到相应的中断服务程序，而不需要CPU去逐个检查和确定中断原因。

​	





# 驱动设计中需要考虑的问题

## 1. 任务同步问题

​	当应用任务访问设备时，如果无论系统设备状态是否改变都对设备进行轮询操作，这种设计必然会增加系统的开销，降低系统整体性能。实际上可以采取同步设计解决这类问题。

### 1.1 应用任务与设备驱动的同步

​	任务间的同步设计如下图所示的应用任务与设备驱动任务同步设计

![image.png](https://upload-images.jianshu.io/upload_images/6128001-95736a0cde455185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这种设计的具体操作过程如下：

1. 应用任务(任务A)通过调用semTake()函数，因为等待信号量而处于阻塞状态，直到设备发生一个事件。
2. 当前驱动程序的轮询设备任务探测到这个事件时，调用semGive()函数释放信号量。
3. 应用任务(任务A)从semTake()中返回。

在系统设备中所发生的"事件"主要指如下的信息：

- 设备某一个状态的改变
- 设备接收到数据
- 设备处于可写状态
- 错误状态



### 1.2 驱动程序任务与设备中断服务程序的同步

​	在设备访问的同步问题上，可以采用应用任务与驱动程序任务之间的同步操作。同时，也可以采用驱动程序任务与设备中断服务程序的同步设计来实现同步操作。如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-4f7642216ae3d7c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

过程如下：

1. 驱动程序任务执行semTake()操作，当没有获得信号量时任务处于阻塞状态。
2. 当设备接收到数据时，产生中断。
3. 中断服务程序调用semGive()函数，释放信号量。
4. 驱动程序任务获得信号量并从semTake()中返回。



## 2. 数据缓冲问题

### 2.1 设备驱动任务与应用任务的数据缓冲

​	任务间的数据缓冲如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-107375f8c5897bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

任务之间通过一个共享缓冲区进行数据的发送和接收。这种设计在总体上提高了系统的性能。对这种设计的描述如下：

#### **2.1.1 接收数据**

数据的接收主要经过如下的操作：

1. 设备驱动程序中的轮询任务的数据存放操作。当设备上有数据到来时，轮询任务读取数据并把它存放到共享内存、环形缓冲区、链表、管道或消息队列中。
2. 应用任务的数据读取操作。协同操作任务(应用任务)从共享缓冲区中读取设备轮询任务所存放的数据。

#### **2.1.2 数据发送**

数据的发送处理和数据的接收处理相反，操作过程如下：

1. 应用任务层数据的发送。这个处理过程中，首先的操作是查看共享缓冲区是否有空间存放要发送的数据。如果有，则把要发送的数据写到缓冲区中。反之，应用任务通常因为等待缓冲区而被阻塞。
2. 设备驱动层数据的发送。轮询任务查看设备状态，当设备的发送寄存器或内存为空时，轮询任务从共享缓冲区中把数据"拷贝"给设备。

#### **2.1.3 管道或消息队列的采用**

​	在共享缓冲的问题上，系统通常采用管道或者和是消息队列作为数据发送和接受的中转站。因为它们本身具有一些很明显的优势。

1. 同步优势：管道或消息队列提供任务间的同步操作。当管道或者是消息队列中无数据时，则任务处于悬置状态，一旦有数据任务马航处于就绪状态
2. 防止优先级反转：管道或消息队列具有优先级继承功能，采用优先级继承方法，解决了任务因为等待贡献资源而发生优先级反转问题。

#### 2.1.4 数据缓冲注意事项

如果采用共享内存、环形缓冲区或者链表，驱动程序必须注意以下事项：

1. 如果有必要的话，确保临界资源(如共享内存)互斥现象。
2. 自身提供任务的同步操作。





# VxWorks中USB相关内容

## 1. 简介

​	通用串行总线（USB）为主机和设备提供了一个多功能通道，以低至中速进行通信。目前USB在低速（1.5 Mbps）和中速（12 Mbps）数据传输速率下提供以下类型的服务：

- 控制转移
- 批量转移
- 中断传输
- 等时传输

USB还包含电源管理和动态链接和移除设备的规定。这种灵活性使USB可以同时使用多种不同类型的设备，每一种设备都需要自己的设备驱动程序支持。希望这些设备驱动彼此独立并独立于底层USB主机控制器接口的实现。Wind River的USB主机驱动程序堆栈满足了这些要求，提供了一整套服务来操作USB以及一些预置USB类驱动程序，以处理特定类型的USB设备。

​	在Wind River的VxWorks中USB驱动程序堆栈的开发符合的是**通用串行总线规范1.1版**，在VxWorks中USB主机驱动程序堆栈体系结构如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-59141b5ec2e1a49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最底层的是USB主机控制器(USB HC),其作用是在主机系统控制每一个USB硬件。目前，市场上主要有两种USB主机控制器系列，它们支持因特尔最初推出的通用主机控制器接口(UHCI),以及支持Microsoft、Compaq、National Semiconductor的开放主机控制器接口（OHCI）。许多硬件制造商围绕这些规格中的一个或另一个建立了USB HC。	

​	对于每一种类型的主机控制器，都有一个与硬件相关的USB主控制器驱动程序(HCD)。在Wind River中提供了两种预先建立好的驱动：

- 用于UHCI HC的usbHcdUhciLib
- 用于OHCI HC的usbHcdOhciLib

USB主机驱动程序(USBD)和HCD之间的接口允许每一个HCD控制一个或者多个潜在的HC。此外，wind River的USBD能够同时连接到多个USB HCD。这些设计功能允许你构建一系列复杂的USB系统

​	USBD是HCD上方与硬件无关的模块。USBD管理连接到主机上的每一个USB设备，并提供更高层与USB通信的路径，USBD负责自动处理USB电源管理和USB带宽管理。另外，对于Wind River架构而言，USBD管理USB集线器是独一无二的。集线器的功能对于USB的正确操作至关重要，因此Wind River的USBD的设计者认为集线器的功能应该由USBD透明的处理。这意味着USBD还可以处理USB集线器和设备的动态链接和移除。

​	处于USBD上层的是USB客户端模块。USB类驱动程序是客户端模块的典型示例。USB类驱动程序负责管理可以连接到USB的各种类型的设备；他们依靠USBD为各个设备提供通信路径。应用程序，诊断程序和测试程序是依赖于USBD与USB设备通信的客户端模块的其他示例。例如，Wind River提供了测试应用程序/模块usbTool，它可以让你对USB和USB设备进行交互式控制。

​	下图说明了wind river 的USB主机驱动程序堆栈的模块之间的功能关系。

![主机模块路线图](https://upload-images.jianshu.io/upload_images/6128001-edf0a8b6fae5609a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在系统中随时可能会发生USB设备的热插拔，因此，必须要编写USBD极其客户端在运行时能够识别USB设备的出现和消失。正是因为如此，主机控制器的出现和消失也可以灵活的处理。当新的主机控制器连接到系统时，USBD会自动识别连接到它的设备并通知感兴趣的客户端。同样，当主控制器从系统中移除时，USBD会自动通知感兴趣的客户端，连接到该主控制器的设备已经消失。这里的关键是USBD客户端(如USB类驱动程序)从不会假定客户端首次初始化时存在特定的设备，并且这些驱动程序随时可以接受在其他的时间连接到系统的设备。

​	

要使用VxWorks提供的USBD库，必须要现将其初始化，USBD的初始化是一个两步的过程，

​	首先要至少一次调用USBD的入口点usbdInitialize()。该函数初始化内部的USBD数据结构，反过来，调用USB驱动程序堆栈的其他模块的初始化入口点。在给定的系统中，可以调用**usbdInitialize（）**一次（可能在引导序列期间）或多次调用它（如在每个USBD客户机的初始化期间）。USBD认为递增针对每个成功调用使用计数**usbdInitialize（）**和递减用于向每个相应的呼叫**usbdShutdown（）**。USBD仅在使用次数从零变为1时才真正初始化，并且当使用次数返回到零时它仅真正“关闭”。

​	其次是使用USBD的usbdHcdAttach()例程将至少一个HCD附加到USBD。通常，在VxWorks启动序列期间，HCD与USBD的连接发生。但是，USBD允许HCD在运行时连接和分离。这种灵活性使得USBD可以支持USB主机控制器可以在不重启系统的情况下实现热插拔。

​	HCD的连接和分离必须由USBD来决定。通常USBD客户端(如USB类驱动程序)不负责将HCD连接到USBD。



**注册客户端模块**

​	打算利用USBD与USB设备通信的客户端模块除了调用usbdInitialize()之外。还必须要通过调用usbdClientRegister()函数向USBD注册。当客户端向USBD注册的时候，USBD将会分配每个客户端的数据结构，之后用于跟踪该客户端发出的所有请求。在客户端注册期间，USBD还会为每一个祖册客户端创建一个回调任务。成功祖册新客户端之后，USBD将会返回一个句柄USBD_CLIENT_HANDLE,该句柄在进行后续USBD调用时必须由该客户端使用。

​	当不需要再使用USBD时，它必须要调用usbdClientUnregister()以释放其每个客户端数据和回调任务。客户发出的任何未完成的USB请求都会在此时被取消。



**客户端回调任务**

​	USB操作是对时间敏感的。例如USB中断传输和同步传输为了正确的工作必须依赖于时间服务。对于存在几个不同的USBD客户端的主机系统，一个客户端可能总是会干扰需要服务时间敏感USB通信的其他客户端的及时执行。Wind River USBD引入了每个客户端的回调任务来管理这个问题。

​	许多USB事件可能导致USBD客户端回调。例如，只要USBD完成USB IRP的执行，就会调用客户端的IRP回调例程。同样，只要USBD识别动态加载事件，就会调用一个或多个客户端的动态加载回调例程。USBD不是立即调用这些回调例程，而是将回调调度由相应的USBD客户端的回调任务执行。通常，每个客户端的回调任务是“休眠”（处于阻塞状态）的。当USBD为特定客户端安排回调时，相应的客户端回调任务将“唤醒”（取消阻止）并执行实际的回调。这种方法允许USBD在客户端自己获得CPU控制权之前处理所有未完成的USB事件。

​	每个客户端的回调任务继承最初称为**usbdClientRegister（）**的任务的VxWorks任务优先级。这可确保回调按每个客户端预期的任务优先级进行处理，并允许您编写客户端以利用任务优先级作为确保对时间敏感的USB通信进行适当调度的手段。

​	由于每个客户端都有自己的回调任务，因此客户在回调期间可以执行的工作量具有更大的灵活性。例如，在回调期间，执行代码可以被阻止而不会影响USBD或其他USBD客户端的性能。

​	客户端回调任务具有VxWorks任务名称**tUsbdCln**。











