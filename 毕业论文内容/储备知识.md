\textsc{%此处集成开发环境应该将其删除，或者将移到其他的部分来简单的介绍。
\section{集成开发环境Tornado}

	Tornado是嵌入式实时领域里最新一代的开发调试环境，其系统结构如\autoref{fig:Tornado开发系统结构}所示。Tornado提供了高效明晰的图形化的实时应用开发平台，可以帮助轻松的完成程序的编辑、编译、调试、系统配置等工作。它包括一整套完整的面向嵌入式系统的开发和调试工具。Tornado采用的是主机—目标机的交叉开发模型，应用程序在主机的Windows环境下编译链接生成可执行文件，下载到目标机，通过主机上的目标服务器与目标机上的代理程序的通信完成对应用程序的调测、分析。这些工具包括C和C++远程级调试器、目标和工具管理、系统目标跟踪、内存使用分析和自动配置，所有工具都能够很方便的同时运行，很容易增加扩展和交互式开发。
\begin{figure}[!h]
\centering
\includegraphics[width=1.0\textwidth]{./graphics/tornado-system-structure.pdf}
\caption{Tornado开发系统结构}\label{fig:Tornado开发系统结构}
\end{figure}
	
​	典型的主机开发系统通常有比较大的RAM、硬盘空间、打印机以及其他外部设备，而典型的目标机系统只有仅能满足实

时应用的资源，除此以外可能还有比较少量的用于测试和调试的额外资源。Tornado开发环境的基本优点是应用模块不需要链接到运行系统库。Tornado直接装载重定位的目标模块，通过每个模块里的符号表来动态解析外部符号的引用，解析符号表是由运行在目标机上的目标服务器来完成的。Tornado在开发过程中会把目标模块的大小减到最小，这样可以缩短开发周期。主机端驻留的shell和调试器也能够调用和测试独立的应用程序或者是完整的任务。

	Tornado是为开发VxWorks应用程序提供的集成开发环境，其中包含有工程管理软件，可以将用户自己的代码和VxWorks的核心有效的结合起来，可以按照用户的需要裁剪配置VxWorks内核；
Tornado开发系统包含有三个高度集成的部分：
\begin{itemize}
\item \hei{运行在宿主机和目标机上的强有力的交叉开发工具和实用程序；}
\item \hei{运行在目标机上的高性能、可裁剪的实时操作系统VxWorks；}
\item \hei{连接宿主机和目标机的多种通信方式，如以太网，串口线，ICE或ROM仿真器等。} 
\end{itemize}

Tornado主机集成开发环境中的主要工具为：
\begin{itemize}
\item \textbf{工程管理和配置工具：} 提供工作空间用于应用程序的组织和管理，可通过图形化的配置工具对VxWorks及其组件进行配置。
\item \textbf{交叉编译器：} 提供GNU和Diab两种交叉编译器和类库
\item \textbf{调试器：}提供图形界面的调试方式，可以通过编辑窗口的右键菜单来设置断点和查看变量；
\item \textbf{WindSh：} 一个驻留在主机端的命令行解释器，提供从主机端控制所有运行系统的接口
\item \textbf{CrossWind调试器：}一个远程源码级的调试器，该调试器控制窗口综合了GDB命令行接口和WindSh工具。
\item \textbf{浏览器：} 是一个系统对象的查看器，可以监视目标机的状态。
\item \textbf{WindView逻辑分析器：} 一个动态可视化工具，可以提供上下文切换的情况，事件和有关测量对象的信息。
\item \textbf{VxSim仿真器：} 用来模拟目标操作系统。
\end{itemize}

	位于主机上的目标服务器和位于目标机上的目标代理通过WDB(Wind Debug)协议完成主机和目标机之间的通信。二者无论采取哪种链接方式，都是基于WDB协议的。

​	
​	
​	
	方便编程人员对系统进行分析、调试。同时基于应用程序的可移植性的考虑，VxWorks在其内核Wind中也支持 POSIX 1003.1b的规定和1003.1中有关基本系统调用的规定，包括：过程初始化、文件与目录、I/O 初始化、语言服务、目录处理；而且 VxWorks 还支持 POSIX 1003.1b的实时扩展，主要包括：异步 I/O、记数信号量、消息队列、信号、内存管理和调度控制等\cite{Wind2003VxWorks}。当然有些POSIX接口也有VxWorks下的实现重新实现版本，比如定时器、二进制信号量、消息队列等。VxWorks下专用的实现版本和POSIX兼容的实现版本在性能上有一些差异，POSIX的接口主要是为简化Linux下程序的移植而设立的。对于没有POSIX接口的部分则必须将程序修改为VxWorks下的接口，对于修改了的代码在VxWorks下运行可能会出现各种问题，本文为了给出一个事后对程序进行分析的方法，于是设计了这个基于VxWorks下的调试通道。




	串口因为其简单可靠、使用方便、开发成本较低等优点\cite{串口调试}。 数据传输是现代通讯过程中的一个重要环节，在数据的传输过程中，不仅仅要求数据传输的准确率要高，而且要求速度快，连接方便。传统的RS232串口通讯和并口通讯都存在传输速度低，扩展性性差、安装麻烦等缺点，而基于USB接口的数据传输系统能够较好的解决这些问题。目前USB接口以其传输速率高、即插即用、支持热插拔等优点，逐步成为PC机的标准接口。PC端的应用软件依然是针对串口进行编程，外设也是以串口为数据通道，但是从PC到外设的物理连接使用的却是USB总线,在上的数据通信也是USB数据格式。
	
	对于特性相异的设备要使用串行通信来连接时，必须保证双方所使用的的标准接口是一致的。一般的串口标准有RS-232、RS-485、TTL等。从通信的方向性来看，串口通信有单工、半双工和全双工三种方式。单工通常使用一根导线，通信只在一个方向进行，如监视器、打印机、电视机。半双工可以在两个方向上进行，但是方向切换时有时间延迟，如打印机。全双工可以在两个方向上运行，且时间的切换没有时间延迟，适用于那些不能有时间延迟的交互式应用，如远程监控等。





\begin{enumerate}
\item \hei{USB设备与主机系统的交互}

	MCU对USB芯片进行初始化：设置内部时钟，选择内部连接方式以及是否开通DMA传输等;设定设备的工作模式，并设备本设备的初始地址为0(USB规范指明当设备接入PC的时候都由初始为0的地址对主机进行响应，之后再由主机分配一个地址给USB设备，设备接收到分配地址命令后，再更改自己的地址，并一直通过这个地址完成后续的通信)。
	完成初始化工作之后，MCU将使能USB接口，主机系统将因此检测到一个新的USB接入而很快与设备进行握手，获取设备的基本信息，并完成一些列的对设备的配置，其过程为：
	\begin{enumerate}
	\item USB上电使能后，主机会向USB设备发送GET DEVICE DESCRIPTOR的命令，之后主机会收到设备发出的设备描述符，随即为设备分配一个空闲地址，并向设备发送SET ADDRESS的命令，这时设备通过地址0发送一个长度为0的数据包予以应答，然后根据主机的要求更改自身的地址，而且这以后的数据交换都将会通过这个新的地址来进行。
	\item 完成地址设备之后，主机将会发送GET CONFIGURATION DESCRIPTOR，USB规定当主机发出该命令符的时候，设备必须要同时返回配置所包含的所有接口和接口所包含的所有端点的描述符。
	\item 主机获取到USB设备的描述符、配置描述符并进行了地址设置之后，设备与主机的握手初步完成，之后会将该设备加入到设备列表当中。
	\end{enumerate}
	
	\item \hei{USB设备与驱动程序的交互}

USB设备的驱动与传统意义上的硬件驱动不完全相同，他并不与硬件直接通信，而是以创建和发送URB请求块的形式把命令传递给操作系统所提供的USB总线驱动程序，由总线驱动程序来完成与硬件的直接交互。和主机类似，驱动会首先创建和发送请求得到该设备的DEVICE DESCRIPTOR的URB，并将获取到的信息存储在专用的数据结构当中，接着驱动为了得到完整的设备配置，必须要通过总线驱动发送两次GET CONGFIGURATION DESCRIPTOR命令得到设备。获取设备的配置信息之后，驱动在启动设备之前还要发送SET CONFIGURATION、SET INTERFACE命令。通过以上的几个步骤便可以完成驱动与USB设备过程。	
\end{enumerate}



实时操作系统(Real Time Operation System，简称RTOS)是整个实时系统的核心。POSIX1003.1标准为RTOS下了一个简单的定义：RTOS是能够在有限的响应时间内为应用提供所要求级别服务的操作系统\cite{Renard20081003}。当外界事件或者是数据产生时，RTOS需要快速的进行处理，并且处理的结果又能够在规定的时间之内来控制生产过程或者对处理系统做出快速的响应，调度一切可利用的资源来完成实时任务。实时系统按照实时的效果可以分为软实时和硬实时，硬实时要求在规定的时间内必须完成操作，这是通过操作的在设计的时候就得到保证的；软实时只需要按照任务的优先级，尽可能快的完成任务即可。\\
一个实时操作系统的特征通常包括以下几点：
\begin{itemize}
\item \textbf{高精度计时系统}\\
	计时精度是影响实时性的一个重要因素，在实时系统当中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统的高精度计时功能。
\item \textbf{多级中断机制}\\
	中断是实时操作系统当中的一个关键设施，是用于通知系统发生外部事件的常用机制。一个实时操作系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。
\item \textbf{实时调度机制}\\
	实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。
\end{itemize}
本次所需完成的调试通道正是基于一个目前业界有名的实时操作系统VxWorks。






\subsection{VxWorks下驱动程序的开发}
​	
	VxWorks作为一款嵌入式操作系统，为了屏蔽硬件的具体操作细节，为上层应用程序提供统一的接口，引入了设备驱动程序的概念。设备驱动程序是用来直接控制设备，以完成设备应有的操作。操作系统通过驱动程序来对设备进行操作，属于一种软件接口。这样，应用程序开发使用统一的软件接口，使得开发人员可以专注于应用程序的开发，不用考虑底层的物理设备。

	VxWorks操作系统下的驱动程序在其开发上有自身规范，且对于不同的设备的驱动程序开发也表现出较大的差异。嵌入式设备的硬件平台千差万别，厂商不可能遇见所有的设备并提供相应的驱动程序，因此要实现VxWorks的跨平台移植，用户必须要根据硬件平台开发驱动程序。所以，开发VxWorks操作系统下外围设备的驱动程序具有很大的实际应用价值。
	
	虽然VxWorks作为实时嵌入式系统有着无比强大的性能表现，但是就目前的现状来看，VxWorks操作系统的平台成本很高，因为VxWorks是一个专用系统，使用这个系统的单位或公司都是处于军事，航天等特殊行业当中，这使得他们的开发经验和资源不能够拿出来共享，导致VxWorks的参考资料比较少，没有成熟活跃的社区支持，且VxWorks并不是一个开源的系统，需要花不菲的价格进行购买和售后支持，这些都提高了VxWorks的应用的开发门槛，使得一般的开发人员不能够方便的接入到对其的应用研究当中，增加了开发难度。

​	





	VxWorks系统主要如下几个组件，一般的应用程序也就用到如下几个模块：任务调度负责任务优先级，任务创建，任务删除等功能。任务通讯主要涉及队列管理，管道管理等。IO管理就是通用外设的输入输出管理。文件管理包含文件或者链接创建，修改，删除，检索等等。内存管理包含内存申请及内存释放。定时器管理就是定时器创建，定时器删除。网络通信包含套接字创建，udp/tcp通信，套接字删除，及配置管理。同步就是任务同步。互斥就是任务互斥，保护关键资源。
	
	在VxWorks操作系统的代码架构里面，一般写一个应用程序只需要涉及上面几个系统组件，由于VxWorks操作系统组件化非常好，这几个组件的耦合度非常低，每个组件对外提供都是单独的头文件，比如任务调度，其头文件为taskLib.h，任务通讯如果用的队列，那其头文件就是msgQLib.h，如果是定时器管理，那其头文件就是timerLib.h，因此也让程序移植提供了很大的便利性。有很多人认为，VxWorks跟Linux操作性的系统头文件差异化太大，因此移植难度成倍速增加，其实不然，就是由于VxWorks的高度组件化，让程序移植提供了很大的便利性。

​	
	wind使用中断驱动和优先级的方式。它缩短了上下文转换的时间开销和中断的时间延迟。VxWorks中的任何例程都可以被启动为一个单独的任务，拥有它自己的上下文和堆栈，还有一些其他的任务机制可以使得任务挂起、继续、删除、延时或改变优先级。	

​	
	板级支持包BSP(Board Support Package)作为VxWorks系统的主要组成部分，对各种板子的硬件功能提供了同一的软件接口，它包括硬件初始化、中断的产生和处理、硬件时钟和计时器管理、局域和总线内存地址映射、内存分配等。每一个板级支持包包括一个ROM启动(Boot ROM)或其他启动机制。

% appendix环境用于附录环境。即可以将附录置于appendix环境当中。如：
% \begin{appendix}
%  <content>
% \end{appendix}

% 直接使用\appendix 则表明后文均为附录。如：
% \appendix
%  <content> 
\appendix

% publications环境用于已经发表了的论文的页面，一般用于附录当中，使用上同enumerate环境
\begin{publications}
    \item 论文1
    \item 论文2
\end{publications}

\chapter{这是一个附录}\label{appendix:1}
附录正文。


%\subsection{第二层}\label{sec:1}
%\subsubsection{第三层}\label{sec:1}
%测试测试测试测试测试测试测试测试测试测试测试测试。
%\footnote{\label{footnote:1}脚注}

\section{字体}

普通\textbf{粗体}\emph{斜体}

\hei{黑体}\kai{楷体}\fangsong{仿宋}

\section{公式}

单个公式，公式引用：\autoref{eq:1}。
\begin{equation}
 c^2 = a^2 + b^2 \label{eq:1}
\end{equation}

多个公式，公式引用：\autoref{eq:2}，\autoref{eq:3}。

\begin{subequations}
\begin{equation}
  F = ma \label{eq:2}
\end{equation}
\begin{equation}
  E = mc^2 \label{eq:3}
\end{equation}
\end{subequations}

\section{罗列环境}

\begin{enumerate}
    \item 第一层\label{item:1}
    \item 第一层
    \begin{enumerate}
        \item 第二层\label{item:2}
        \item 第二层
        \begin{enumerate}
            \item 第三层\label{item:3}
            \item 第三层
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

\begin{description}
    \item[解释环境]  解释内容
\end{description}



\clearpage

\section{代码环境}

\begin{lstlisting}[language=python]
import os

def main():
    '''
    doc here
    '''
    print 'hello, world' # Abc
    print 'hello, 中文' # 中文
\end{lstlisting}

\section{定律证明环境}

\begin{definition}
这是一个定义。
\end{definition}
\begin{proposition}
这是一个命题。
\end{proposition}
\begin{axiom}
这是一个公理。
\end{axiom}
\begin{lemma}
这是一个引理。
\end{lemma}

\begin{theorem}
这是一个定理。
\end{theorem}
\begin{proof}
这是一个证明。
\end{proof}

\section{算法环境}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{this text}
\KwResult{how to write algorithm with \LaTeX2e }
initialization\;\label{alg_line:1}
\While{not at end of this document}{
read current\;
\eIf{understand}{
go to next section\;
current section becomes this
 one\;
}{
go back to the beginning of current section\;
}
}
\caption{How to write algorithms}\label{alg:1}
\end{algorithm}


\section{表格}
表格见\autoref{tab:1}。

\begin{table}[!h]
\centering
\caption{一个表格}\label{tab:1}
\begin{tabular}{|c|c|}
\hline
a & b \\
\hline
c & d \\
\hline
\end{tabular}
\end{table}
\section{图片}
图片见\autoref{fig:1}。图片格式支持eps，png，pdf等。多个图片见\autoref{fig:2}，分开引用：\autoref{fig:2-1}，\autoref{fig:2-2}。

\begin{figure}[!h]
\centering
\includegraphics[width=.4\textwidth]{hust-title.pdf}
\caption{hust-title}\label{fig:hust-title}
\end{figure}

\begin{figure}[!h]
\centering
  \begin{subfigure}[b]{0.3\textwidth}
  \includegraphics[width=\textwidth]{./graphics/VxWorks-driver-structure.pdf}
  \caption{VxWorks-driver-structure}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.3\textwidth}
  \includegraphics[width=\textwidth]{}
  \caption{图片2}\label{fig:2-2}
  \end{subfigure}
\caption{多个图片}\label{fig:2}
\end{figure}

\section{参考文献示例}
这是一篇中文参考文献\cite{徐媛媛2003嵌入式实时操作系统的设备驱动}；这是一篇英文参考文献\cite{9787508342894}；同时引用\cite{9780124467422,bamboosilk}。

\section[\textbackslash{}autoref 测试]{\texttt{\textbackslash{}autoref} 测试}

\begin{description}
  \item[公式] \autoref{eq:1}
  \item[脚注] \autoref{footnote:1}
  \item[项] \autoref{item:1},\autoref{item:2},\autoref{item:3}
  \item[图] \autoref{fig:1}
  \item[表] \autoref{tab:1}
  \item[附录] \autoref{appendix:1}
  \item[章] \autoref{chapter:1}
  \item[小节] \autoref{sec:1},\autoref{sec:2},\autoref{sec:3}
  \item[算法] \autoref{alg:1},\autoref{alg_line:1}
  \item[证明环境] \autoref{def:1},\autoref{proposition:1},\autoref{axiom:1},\autoref{lemma:1},\autoref{theorem:1},\autoref{proof:1}
\end{description}}












# VxWorks下的内核态和Linux下的区别

通用操作系统进程栈（通用操作系统一般称每个调度单元为进程）分为两个层次，这是由于
通用操作系统一般具有两个运行态-内核态和用户态-决定的。通用操作系统需要提供高安全
性的运行环境，其必须明确的隔离两个不同层次上的操作，从而知道哪些操作是被允许的，
哪些是被禁止的，当然安全措施不单是通过运行态来实现，运行态的区分只是其中重要措施
之一。通用操作系统对于进程在两个不同运行态下具有不同的栈，当进程运行在用户态时，
其使用用户态栈，当发生系统调用或由于中断进入到内核态时，其切换到进程的内核态栈。
一般而言，用户态栈是使用不尽的，由平台内存空间决定，地址空间一般不造成限制（如
Linux 下用户态栈原则下有接近 3G 的空间可用），而内核态栈大小是由很大限制的，如 Linux
下内核态栈一般只有大约 4KB 的大小。所以进程运行在内核态时，要求大空间的结构必须
使用堆的方式分配，不要使用栈进行分配。事实上，由于运行在内核态的代码都是严格限制
的，所以一般都不会发生内核态栈溢出的问题。而由于用户态栈可使用空间极大，虽然其先
分配给用户态栈的实际内存较小，但是可以根据需要动态的增加用户态栈内存，所以很难使
得用户态栈溢出（你能想象一个应用程序可以使用完 3GB 的栈吗？）。
Vxworks 内核不使用通用操作系统下的运行态，虽然 Vxworks 下也有内核态的概念，不过
去本质上就是一个内核数据结构的简单保护机制，仅仅由一个全局变量 kernelState 表示是否
在内核态，当用户进行内核函数调用或者中断发生进入到 Vxworks 内核运行时，其并不发
生运行态的本质切换，而任务自始至终都在使用同一个栈。换句话说，Vxworks 下任务栈即
被应用函数（用户编写的函数）使用，也被内核函数（Vxworks 内核提供）使用，其 Vxworks
下任务栈在初始创建后，不可以根据需要在后期动态的增加内存容量。这就对 Vxworks 任
务栈的初始创建大小提出了一个要求，即其在创建栈（即创建任务）时指定的栈大小必须足够大，以满足任务后续运行期间对栈容量的需求，而这一点是很难由用户在创建时进行判断
的。故实际上，用户在创建任务时会指定一个比实际需要大得多的栈容量，这对于一个嵌入
式系统而言，对已然宝贵的内存资源造成了极大的浪费。Vxworks 官方文档的建议是在通过
试验法，在程序开发期间，在任务创建时，指定一个比较大的栈，在任务运行期间，不断地
使用 checkStack 函数查看任务的栈使用情况，从而得到一个任务栈的大致使用数据统计。其
后，用这个得到的统计值作为任务栈的实际容量。checkStack 函数的调用原型如下。
void checkStack
(
int taskNameOrId /* task name or task ID; 0 = summarize all */
)
参数指定要检查的栈对应任务的 ID。以参数 0 调用该函数时，会打印出系统内所有任务的
栈的使用情况。checkStack 函数的一个使用实例如下。

-> checkStack tShell 



### 2.2.2 线程间通信

​	在进程的运行过程中,他所建立的不同线程之间有时候需要进行数据的交互。通常的话可以建立全局变量，这也是最简单的线程间数据共享的方法[^26]。建立的全局变量使得所有的线程都可以在自己地址空间中使用这个变量。一般的情况下全局变量是在实现文件的头部定义，在同一个进程中的不同线程都可以使用它[^27]。

​	还有一种情况是某一些线程之间要进行一些状态的交换，比如说工作者线程有时候要把状态传递给主线程，主线程做出相应的操作，在这种情况下可以使用消息机制，因为使用全局变量的话是难以达到这个作用的。基于这个情况，使用用户自定义消息是个不错的选择。通过在消息中指定要发送到线程以及指定消息的参数来承载要发送的消息，然后使用API来将消息发送到指定的线程的消息队列中等待处理。而接收消息的线程不断在处理消息队列中的消息。这个过程总结起来包括4个环节，开发人员自定义的消息，声明消息回调函数，定义消息回调函数中对消息的处理，以及发送自定义的消息。

### 2.2.3 线程同步

​	在多线程的使用当中，不同的线程有时候要访问以及修改同一个资源，就会造成也许不是开发人员所预期的结果，或者造成一些冲突。这种情况下，就有了线程同步。同步的方式主要有四种：临界区(Critical Section),信号量(Semaphore),互斥体(Mutex),事件(Event)。

- 临界区(Critical Section): 保证在进程中的资源在一个时刻上只能有一个线程可以访问到。使用这种方法的过程中，多个线程将会访问以及修改某一个共享的资源对象，这个资源对象将会有一个临界区，对于不同的线程，同一个时刻只能有一个线程进入到这个临界区，这个线程可以访问到该资源对象，其他线程请求访问这个资源的时候发现这个临界区被占用，就只能够等待。当占据临界区的线程使用完了以后释放了该临界区，其他的线程再按照优先级来确定哪个线程进入。也就是说，资源在某一个时刻只能够由一个线程使用[^29]。临界区和临界区对象是处于对应关系的。当线程需要访问某个数据资源，该线程就调用lock()方法以占据临界区。当着额数据资源使用完毕以后，该线程再调用Unlock()方法以释放临界区对象，这样就使得其他线程可以对该数据资源进行访问。
- 互斥体(Mutex)：类似于临界区，不过在使用过程上更加复杂。而且临界区只能够用于同一个进程中的不同线程之间的同步，互斥体可以在不同的进程之间进行同步。在使用的过程中，首先通过CreateMutxe()来建立一个句柄或者说是互斥体，然后通过OpenMutex来打开这个资源的互斥体，其他的线程通过使用WaitForSingleObject()来检测这个资源是否得到了释放。当使用资源的互斥体使用完毕以后，通过ReleaseMutex()来释放该资源的使用权。
- 信号量(Semaphore)：类似于互斥体，信号量允许同一个资源在某一个时刻由不同的线程访问，这其中引入了一个计数机制。在使用的过程中，首先使用CreateSemaphore()来创建一个句柄或者说是信号量，然后通过OpenSemaphore()来打开信号量，其他在等待使用该资源的线程通过WaitForSingleObject()来检测资源被使用线程的数量是否达到设定值[^30]。当使用完成以后，可以使用ReleaseSemaphore()来释放该线程对这个资源的使用，同时计数也减1。
- 事件(Event)：是通过通知操作的方式来保持线程的同步。在使用过程中，首先通过CreateEvent()来创建一个句柄或者说是事件对象，接下来通过OpenEvent来打开已经创建的事件对象，然后通过线程调用资源时使用SetEvent()和ResetEvent()来控制这个事件的信号

  ​



[^12]: 
[^14]: 
[^15]: 
[^19]: 
[^20]: 
[^26]: 
[^29]: 





以下内容摘自[嵌入式Linux设备驱动程序的设计与研究](http://xueshu.baidu.com/s?wd=paperuri%3A%28866d414b8629ae2469f1440d13a31dd0%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http%3A%2F%2Fwenku.baidu.com%2Fview%2F1a823a2dcfc789eb172dc88f.html&ie=utf-8&sc_us=3038571180740317288)

# 第三章 嵌入式Linux下USB设备驱动的设计与研究



# VxWorks中的互斥

​	当共享地址空间进行简单的数据交换时，为了避免竞争，需要对内存进行互锁。实现资源互斥访问的方法很多，不同之处仅仅在于互斥的范围。例如禁止中断、禁止抢占、以及信号量对资源的上锁等情况。

## 1. 中断上锁和响应时间

​	对于互斥而言使用最强有力的办法是==禁止中断==，这种上锁的方法保证了对CPU的单独访问。

```c++
funcA()
{
  int lock = intLock();
  ...//禁止中断的代码临界区
  intUnlock(lock);
}
```

​	但是这种方法涉及到使用中断服务程序的互斥，由于它在上锁期间阻止系统对外部事件的响应，因此对于大部分实时系统而言不能够作为一种通用的互斥方法，一旦要求紧急响应外部事件，此时的终端响应时间将是难以接受的。然而在使用中断服务程序时，有时候又需要中断上锁，在这种情况下应该尽可能的使得中断上锁时间短。

## 2. 抢占上锁和响应时间

​	当不允许其他任务抢占当前执行任务的时候，禁止抢占提供了一种较小限制性的互斥，此时，中断服务程序仍然能够执行。

```c++
funcA()
{
  taskLock();
  ...//禁止中断的代码临界区
  taskUnlock();
}
```

但是使用这种方法可能会造成系统实时性得不到充分的保证。尽管高优先级任务本身没有涉及到临界区，然而该任务只能够在上锁任务离开临界区之后才能够执行。



# VxWorks中的信号量

​	在VxWorks中信号量被高度的优化，并提供了最快速的任务间通信机制。信号量是互斥和任务间同步最主要的手段。对于互斥而言，信号量可以对共享资源进行互锁，并提供比禁止中断和抢占上锁更为精确的互斥程度；而对于同步而言，信号量可以协调外部事件与任务之间的执行。

​	VxWorks操作系统提供了三种类型的wind信号量来解决不同类型的问题：

1. 二进制-----最快最通用的信号量，适用于同步和互斥；
2. 互斥----为了解决内在的互斥问题、优先级继承、删除安全以及递归等问题而最优化的一种特殊二进制信号量；
3. 计数----类似于二进制信号量，但是其跟踪信号量被释放的次数适用于单个资源多个实例需要保护的情况。

## 1. 二进制信号量

​	使用二进制信号量能够满足两种任务的协调需要：互斥和同步。二进制信号量需要的系统开销最小，因此特别适合于高性能的需求。在不需要使用互斥量的高级特性时，二进制信号量仍可用于互斥。二进制信号量可被用作一个标志；资源可用(full)或则不可用(empty)。当任务调用semTake()函数提取二进制信号量时，其结果依赖于被调用时信号量时可用的(full)还是不可用的(empty)；如图2-6所示。当任务调用semGive()函数释放二进制信号量时，其结果依赖于被调用信号量是可用的(full)还是不可用的(empty);如图2-7所示。

![image.png](https://upload-images.jianshu.io/upload_images/6128001-c4f29516d0df82c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1 互斥

​	二进制信号量能够有效的对共享资源的访问进行互锁。与禁止中断和抢占上锁不同，二进制信号量仅仅限制了相关资源的互斥范围。使用该技术时需要创建信号量来保护资源，信号量在最初创建时状态为可用(full).

```c++
SEM_ID semMutex;
semMutex = semCreate(SEM_Q_PRIORITY，SEM_FULL)；
semTake(semMutex,WAIT_FOREVER);
...//临界区，任何时候仅单个任务可以访问。
semGive(semMutex);
```

当任务访问资源时，首先要获取信号量，只要任务持有信号量，其他所有需要访问该资源的任务将会被阻塞。当该任务结束资源访问时释放信号量，允许其他任务访问资源。因此，对资源的所有访问需要互斥时，可以使用函数semTake()和semGive()来实现。

### 1.2 同步

​	当信号量用于任务同步时，信号量可以用作是任务等待的一个状态或者是事件。任务或者是中断服务程序通过释放信号量来表明事件的发生。调用semTake()函数提取信号量的其他任务处于等待状态，这些等待任务被阻塞，直至事件发生，并释放信号量。注意信号量在互斥和同步时状态次序不同。对于互斥，信号量初始时为可用(full),每一个任务先提取信号量，然后再释放，但是对于同步，信号量初始时为不可用(empty),每一个任务都需要等待提取被其他任务释放的信号量。



## 2. 互斥信号量

​	互斥信号量是一种用于解决内在互斥问题的特殊的二进制信号量，包括优先级倒置、删除安全以及资源的递归访问。互斥信号量的基本行为与二进制信号量一致，不同之处如下：

- 它仅用于互斥；
- 他仅能由提取它(即调用semTake())的任务释放；
- 不能够在中断服务程序中释放；
- semFlush()函数操作非法；



### 2.1 优先级倒置

`semId = semMCreate(SEM_Q_PRIORITY | SEM_INVERSION_SAFE);`

### 2.2 删除安全

​	互斥的另外一个问题涉及到任务的删除，一个受到信号量保护的临界区域内经常需要保护执行任务避免被意外的删除。删除一个在临界区执行的任务可能会导致意想不到的后果。资源可能会处于破坏状态，同时受保护的信号量不再可用，直接终止对该资源的所有访问。

### 2.3 递归资源访问

![image.png](https://upload-images.jianshu.io/upload_images/6128001-4626283a3f98a45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	互斥信号量能够递归获取，这意味着持有信号量的任务在最终释放其之前能够多次地提取。递归非常适用于一组需要互相调用的子程序同时又需要进行资源互斥访问的情况。由于系统保持跟踪当前那个任务持有的互斥信号量，因此这是能够实现的。

​	在释放信号量之前，递归获取的互斥信号量被释放和提取的次数应该相等。这通过一个计数器跟踪实现，每调用semTake()计数器加一，没调用semGive()计数器减一。



## 3. 计数器信号量

​	计数器信号量也是实现任务间同步和互斥的另外一种手段。计数器信号量与二进制信号量相似，它也是跟踪信号量被释放的次数。每释放一个信号量，计数器加一；每提取一个信号量，计数器减一，当计数器为零时，试图提取信号量的任务将会被阻塞，与二进制信号量一样，如果信号量被释放的时候存在被阻塞的任务，那么被阻塞的任务将会被解除阻塞。与二进制信号量不同的是，如果信号量被释放时不存在阻塞的任务，那么计数器将会加一。这意味着一个被释放两次的信号量，可以被无阻塞的提取两次。

​	计数信号量适用于保护多份复制的资源。例如，可以使用一个初始值为5的计数器信号量来协调五个磁带驱动器的工作；或者是使用初始值为256的计数器信号量来实现一个有256个入口的环形缓冲器。计数器信号量的初始值以参数形式用于semCCreate()中。





# VxWorks 文件系统

​	VxWorks操作系统中的I/O系统可以提供简单、统一、与任何设备无关的接口，它包括基本I/O系统和缓冲I/O系统。

​	在VxWorks中和linux中类似，也把一切当成文件来看。==系统中由驱动程序负责控制各种设备。通常，对I/O系统的操作并不需要深入的了解各种设备和驱动程序的运行方式。但是VxWorks操作系统当中的I/O系统对控制各种指定的设备具有很强的灵活性。驱动程序既可以运行于传统的方式之下，又可以在特定的应用程序中采用不同的方式。==

​	虽然所有的I/O操作都指向已命名的文件，但是它也分为两种不同的类型：基本操作和缓冲操作。这两种类型的操作区别在于数据缓冲的方式和调用I/O的方式。



​	VxWorks中的基本I/O接口在标准C语言库中与I/O原语兼容。包括create()、open()、close()、delete()、read()、write()、ioctl().



​	VxWorks操作系统中的I/O设备库包含有一个和UNIX和Windows操作系统中的stdio包相兼容的缓冲型I/O设备包，并且完全支持ANSI C语言。虽然VxWorks中的I/O操作效率较高，但是系统仍然需要花费一些与每一个底层函数调用有关的额外开销。

​	==第一种情况是为了实现某一个功能，I/O系统先调用与设备无关的功能函数(如read()、write()等)，然后再调用与驱动程序相关的底层函数。==

​	==第二种情况是大多数驱动程序都会采用互斥或者是队列机制来避免发生因同事调用同一个驱动程序而导致多个用户程序互相影响的情况。==



# VxWorks操作系统中的设备

## 1.串行I/O设备(包括终端和伪终端设备)

​	VxWorks操作系统提供了多种终端和伪终端设备驱动程序(tty和pty驱动)。tty用于驱动实际的终端设备，pty驱动程序用于模拟终端设备。这些伪终端设备在诸如远程登入等应用中很有用。

​	VxWorks操作系统中的I/O设备是从一个缓冲型的串行字节流设备。每一个设备都有一个环形缓冲区用于输入和输出操作。从一个tty型设备中读取数据实际是从输入环形缓冲区中提取数个字节数据；向一个tty设备中写入数据实际上是向输出环形缓冲中加入数个字节数据。在操作系统初始化的过程中创建设备时，指定每一个缓冲区的大小。



2. 管道设备：由pipeDrv文件负责管理管道设备，管道设备使用核心信息队列进行实际信息传输操作。
3. 伪存储设备
4. 网络文件系统(NFS)设备
5. 非NFS网络设备
6. CBIO接口：核心缓冲区块存取输入/输出(CBIO)组件“INCLUDE_CBIO_MAIN”提供了针对多种文件系统(dosFs和rawFs等)的接口，用户在使用这些文件系统时需要在系统内核中包含该组件
7. 块存取设备：块存取设备是由一系列可以独立访问的数据块组织起来的设备。最普通的块存取设备就是磁盘。在VxWorks中“块”表示在设备中可寻址的最小单位，对于大多数磁盘设备，与VxWorks操作系统中“块”相对应的术语是“扇区”。



# 与MS-DOS兼容的文件系统：dosFs文件系统

dosFs文件系统是一种与MS-DOS文件系统兼容的文件系统，它能够满足实时应用的多种要求。其主要特点如下：

- 支持层次化的文件和目录结构，能够在一个磁盘上建立一定数目的文件并进行有效的管理；
- 可以将每一个文件指定为连续存储或者非连续存储
- 广泛兼容各种可存储和可检索媒体(如软盘、硬盘)；
- 可以从dosFs文件系统中启动VxWorks操作系统；
- 支持VFAT和VXLONGS的目录机构；
- 支持FAT12、FAT16和FAT32文件分配表格式。



# 中断处理与定时机制

## 1. 看门狗定时机制

​	VxWorks中包括一个看门狗定时器机制，它允许任何C函数与一个特定的时间延时器联系。看门狗定时器应该作为系统时钟中断服务程序的一部分来维护。

​	被看门狗定时器调用的函数通常作为系统时钟中断级的中断服务代码来执行。但是如果内核由于某种原因不能够立即执行函数(例如一个优先中断或者是内核状态)，函数将放在tExcTask工作队列当中，tExcTask工作队列中的函数以tExcTask(通常是0)优先级来执行。

​	下表中的函数由wdLib提供

|     调用     |       功能描述       |
| :--------: | :--------------: |
| wdCreate() |  分配并初始化一个看门狗定时器  |
| wdDelete() |  终止并释放一个看门狗定时器   |
| wdStart()  |    启动一个看门狗定时器    |
| wdCancel() | 取消当前的一个计数的看门狗定时器 |

看门狗定时器由wdCreate()函数创建；由wdStart()函数启动，函数参数为：延迟tick数、需要调用的C程序以及传递给该函数的参数。一旦指定的tick结束，函数将会使用指定的参数进行调用。在定时器结束计算之前的任何时间内，调用wdCancel()函数会取消看门狗定时器的执行。

## 2. 中断服务程序

​	



## 3. POSIX时钟和计时器

​	实时系统扩展(1003.1b)的POSIX标准为内核设备提供了一套接口，为了提高应用的可移植性，VxWorks内核“wind”包括了POSIX接口，以及专门用于VxWorks设计的接口。

​	POSIX标准提供了一种可以识别多个虚拟时钟的方法，但是只有系统的实时时钟是必须的，VxWorks系统中不支持虚拟时钟。

​	POSIX计时器提供了在未来某一个时刻任务对其自身发送信号的函数；这些函数用于创建、设置和删除一个计时器。当计时器的执行完成之后，向任务发送默认的信号SIGALRM。如果要执行一个在计时器结束后执行的信号处理程序，可以调用函数sigaction()。

```C++
#include "VxWorks.h"
#include "time.h"
int createTimer(void)
{
  timer_t timerId;
  if(timer_create(CLOCK_REALTIME,NULL,&timerId) == ERROR){
    printf("create FAILED\n");
    return (ERROR);
  }
  return (OK);
}
```

nanosleep()作为POSIX的一个附加功能，与wind中的taskDelay()类似，用来指定一个以秒或纳秒为单位的睡眠或延迟时间，只不过taskDelay()的单位为tick。两者精度相同，都是由系统时钟速率决定的，只是单位不同而已。



# POSIX与Wind的比较

**1. POSIX和Wind调度方法比较**

- POSIX基于进程调度，Wind基于任务调度
- POSIX使用了FIFO调度术语，VxWorks使用基于优先级的抢占式调度。两者仅仅是表达不同，都使用了相同的基于优先级的策略。
- POSIX在进程到进程的基础上应用调度算法;Wind的调度算法应用于整个系统，即所有任务既可以使用轮转，也可以使用基于优先级调度。

**2. POSIX和Wind信号量比较**

POSIX信号量属于计数信号量，即他们会跟踪信号量被释放的次数。除了下列Wind信号量提供的附加特征外，Wind信号量机制与POSIX中信号量机制类似；而且下列特性起了重要的作时，Wind信号量性能更优越。

- 优先级继承
- 任务删除安全
- 对于单任务多次获取信号量的能力
- 互斥信号量的所有权
- 信号量超时
- 队列机制选择



# VxWorks中创建应用程序的两种方式

在RTOS当中内存的管理有两种模式：分时模式和保护模式。

## 1. 可下载的应用程序

​	可下载应用程序是一个可以重定位的目标模块组合，这些目标模块可以下载并且动态的链接到VxWorks，从shell或者debugger启动。











# 编写驱动程序

​	在设计驱动程序时一般的顺序应该是从上到下，但是在执行以及对驱动程序进行测试的时候，一般顺序应该是从下往下。

## 1. 从上至下设计

​	从上至下的设计步骤意味着在开始正式编码之前，要进行开发计划并且对可行性进行证明。

**1.1 模板文件**

​	开发驱动程序可以从模板文件或者现有的驱动程序开始。建议使用模板文件开始设计驱动程序，若使用现有的文件通常会引入其他驱动程序代码的很多问题。WindRiver为所有类别的驱动程序提供了模板文件。

**1.2 模块描述**

​	将芯片资料手册中对该芯片的介绍性文字拷贝到模块的描述部分，然后再加上一段文字描述这个驱动是如何工作的，驱动程序对芯片哪一些部分进行了控制，以及驱动程序所支持的操作模式等内容。

**1.3 设备结构**

​	从定义每一个设备的基本数据结构和每一个驱动程序的基本数据结构开始，这些结构定义了驱动程序和每一个设备的状态。像结构体一样，只用一个简单的打印命令，调试器就可以显示出它们的全部状态。

**1.4 宏定义**

​	证明所有用来为不同应用所定制的驱动程序的宏，比如访问芯片宏、访问存储器宏等。告诉用户这些宏的作用是什么，以及它们的默认值是如何定义的。

**1.5 子程序声明**

​	声明用户以及BSP编写者使用这个驱动器可能会需要的所有的子程序。尽可能的使得硬件设计和软件设计一致。

**1.6 设计功能函数**

​	为所有计划编写的函数建立标志和声明，先使它们的内容是空的，直到已经确实准备好编写其中的代码。在注释块中写上对子程序的描述，注释块中的注释比代码部分中的注释要重要的多。



## 2. 从下至上测试

​	在完成对驱动程序的计划，以及初步形成了由函数和数据结构构成的骨架之后，就可以开始准备执行和测试了。

**2.1 编写代码**

​	从设备初始化开始，编写代码来接受一个设备的数据结构并为以后的使用而对它进行初始化。为所有其他低级别的驱动程序函数添加内容。可以进行一次测试编译，来核实是否所有必须的程序都已被声明。检查目标模型中的符号来确认只有所有额外部程序未被执行，在编写代码时要注意以下两方面的问题：

- 避免在驱动程序中使用printf()：即使目的是为了调试，也要避免在驱动程序中使用printf(),可以使用logMsg()来代替。在驱动程序和I/O系统之间可能会有系统的交互作用，这可能会使printf()导致系统瘫痪。
- 调用intConnect()：不要从sysHwInit内部调用intConnect(),或者任何其他的调用malloc()的程序，因为内存分配库还没有被初始化，系统将会瘫痪。

**2.2 测试、调试、重编译**

​	一般的测试、调试和重编译是一个循环的过程。个人的不同选择和偏好影响着这一阶段，一些人一次只对一个程序进行编码和测试。

**2.3 一次完成一层**

​	对代码的每一层重复的进行编写、测试、调试、重新编译的循环工作。对每一层进行全面的测试可以提高工程的可信度。企图一次编写全部的代码是难以做到的。

**2.4 性能测试**

​	应该进行一系列的基准程序的测试，来证实这个设备可以满足一般的客户需求。仅能够提供5MB/s网络吞吐量的带宽SCSI设备，是不能够很好的满足客户的要求的。工程设计师有必要编写一个完整的性能测试基准程序作为整个项目的一部分。





# 驱动程序的轮询和中断处理

​	设备驱动通常会采用两种方式来获取硬件事件的发生或者状态的改变：

1. 轮询(polling)方式：周期性查询硬件时间的发生。实际上是通过读取设备的状态寄存器来获取设备状态的改变或事件的发生,然后再进行相应的处理。
2. 中断处理方式：当事件发生或状态改变时，硬件产生中断，然后执行相应的中断服务程序。

采用轮询方式时，如果一个系统有多个外部设备，那么CPU只能够轮流的对每一个外部设备进行查询，而这些外部设备的速度往往并不相同。这时CPU显然不能很好满足各个外部设备随机性的状态改变或事件发生。所以，这种方式的实时性比较差。

为提高实时性，通常采用中断处理方式来通知系统外部设备的事件发生或状态改变。因为在中断处理方式下，外部设备具有申请CPU服务的主动权，当设备的事件发生或状态改变时，便可以向CPU发出中断请求，使CPU暂停当前的工作而处理外部设备的请求。在这种方式下，CPU不必花费大量的时间查询外部设备的工作状态，显然提高了系统的实时性能。

## 1. 轮询

​	当使用不支持中断方式的设备时，可以通过轮询的方式对设备进行管理。而轮询方式可以采用下面的几种实现方式：

- 驱动程序任务在系统空闲时进行设备轮询
- 驱动程序任务周期性的进行设备轮询
- 驱动程序通过看门狗定时器进行设备轮询
- 驱动程序通过辅助时钟进行设备轮询

## 2. 中断

​	在微处理器的中断机制中，包含两类中断源，它是通过外部设备接口向CPU中断请求引脚“INTR”和“NMI”发出中断请求信号引起中断的，这类中断称为硬中断(或称为外部中断)。另外一类中断是内部中断(软中断)，内部中断是通过CPU执行中断指令产生的，或者是CPU在执行程序时遇到了一些异常情况产生的，像除法错误，溢出中断等都是产生内部中断的中断源。

​	中断管理在VxWorks中是一个重要的组成部分，因为系统是以中断的方式响应外部事件的发生。为了快速响应中断，中断服务程序ISR运行在特定的空间，不同于其它任何任务。因此与任务不同的是，中断处理没有任务的上下文切换。

​	以下是一些VxWorks常用的注册和卸载设备以及设备驱动程序的函数：

|       函数        |      描述      |
| :-------------: | :----------: |
| IosDrvInstall() |    注册设备驱动    |
| IosDrvRemove()  |    卸载设备驱动    |
|  IosDrvShow()   | 显示系统中所有的设备驱动 |
|   IosDevAdd()   |    注册一个设备    |
| IosDevDelete()  |    卸载一个设备    |
|  IosDevFind()   |    查找一个设备    |
|  IosDevShow()   |  显示系统中的所有设备  |



中断处理操作中，应注意下面一些问题：

- 中断服务程序(ISR)的安装；
- 中断服务程序可以进行什么操作，不可以进行什么操作；
- 中断服务程序的调试。

### 2.1 中断服务程序

​	中断服务程序是用户自定义的一个程序，只有当中断产生时它才执行，该程序拥有独立于任务的上下文。在中断服务程序中，不能够执行过多的I/O操作，不可以获取信号量，不可以分配内存，不可以申请任务控制块。像printf()、malloc()、semTake()、taskIdSelf()函数都不能使用，但是可以使用semGive()、logMsg()、msgQSend()以及bcopy()。

​	用户在使用中断服务程序之前，必须要采用一定的方法，将中断服务程序的入口地址放置在中断向量表上与中断类型号相应的位置中。当中断到来的时候，CPU会自动地取出中断向量表中的相应的内容送入IP寄存器和CS寄存器，从而改变程序的执行方向，转入中断服务程序的执行。

### 2.2 处理中断

​	事实中的中断处理并不是简单的执行C语言函数，它需要保存当前系统寄存器的状态以及正在执行的代码，然后装载中断堆栈，最后调用连接在中断向量上的中断服务程序。中断处理完成之后，从中断服务程序函数返回时，系统需要恢复寄存器和堆栈，并退出中断。这个中断处理过程如下：

1. 当设备产生IRQ(中断请求)时，中断当前任务并取中断类型号；
2. 在中断应答期间，系统决定哪个设备需要服务(计算中断向量地址)；
3. 为设备调用适当的函数(系统注册的设备中断服务程序)；
4. 在VxWorks定义的中断包裹函数里，保存有寄存器值以及调用用户定义的中断服务程序；
5. 中断处理结束之后，从中断服务程序返回并恢复寄存器的值；
6. 若执行中断服务程序之后，没有高优先级的任务运行，则恢复被中断任务的执行。



### 2.3 中断优先级

​	系统中存在多个设备用中断和CPU进行数据传输时，就有一个中断优先级处理的问题。通常在嵌入式系统当中对中断优先级采用以下的三种方法来解决：

1. 软件查询法：当硬件系统无法确定中断处理优先级时，可以通过软件来决定硬件设备的中断优先级。这种方法的优点是节省硬件，不需要判断优先级的硬件排队电路，而是使用程序的优先级来确定设备中断的优先级。这种方法的缺点是设备发出中断请求信号到CPU转入相应的服务程序入口的时间较长。
2. 简单的硬件方法(菊花链)：在每个外设对应的接口上连接一个逻辑电路，这些逻辑电路构成一个称为菊花链的结构。由菊花链来控制中断回答信号的通路。有了菊花链之后，各个外设接口就不会竞争中断回答信号，因为菊花链已经从硬件的角度根据设备在链中的位置决定了它们的优先级，越靠近CPU的设备，优先级越高。
3. 专用硬件方法：在嵌入式中，解决中断优先级管理的常用方法是采用可编程的中断控制器。可编程中断控制器中的中断类型寄存器、屏蔽寄存器都是可编程的，而且优先级排列也是按指令来设置的，所以可编程控制器使用起来很灵活方便。



### 2.4 中断号与中断向量的转换

​	嵌入式系统给每种中断都安排了一个中断类型号(中断号)。每种类型的中断都应该由相应的中断处理程序来处理，而中断向量表用来存放中断服务程序的入口地址。

​	例如在PC系统中，存储器的低1.5KB字节，即地址从0 ~ 5FFH为系统所占用，其中最低的1KB字节，地址从0 ~ 3FFH存放中断向量表。中断向量表中的256项中断向量对应256种中断类型，每项占四个字节(如下表所示),所以每类中断向量的地址可以由中断类型号乘以4来计算处理。

![image.png](https://upload-images.jianshu.io/upload_images/6128001-85291b258982e499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在VxWorks中，中断向量号与中断向量地址通过函数INUM_TO_IVEC(intNum)来转换。如下：

```C++
UINT32 uiIntVec；
BYTE irqNum = 0x9；
uiIntVec = (UINT32)(INUM_TO_IVEC(irqNum));
```

​	采用中断向量的方法大大加快了中断处理速度，因为计算机可以直接通过中断向量表跳转到相应的中断服务程序，而不需要CPU去逐个检查和确定中断原因。

​	





# 驱动设计中需要考虑的问题

## 1. 任务同步问题

​	当应用任务访问设备时，如果无论系统设备状态是否改变都对设备进行轮询操作，这种设计必然会增加系统的开销，降低系统整体性能。实际上可以采取同步设计解决这类问题。

### 1.1 应用任务与设备驱动的同步

​	任务间的同步设计如下图所示的应用任务与设备驱动任务同步设计

![image.png](https://upload-images.jianshu.io/upload_images/6128001-95736a0cde455185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这种设计的具体操作过程如下：

1. 应用任务(任务A)通过调用semTake()函数，因为等待信号量而处于阻塞状态，直到设备发生一个事件。
2. 当前驱动程序的轮询设备任务探测到这个事件时，调用semGive()函数释放信号量。
3. 应用任务(任务A)从semTake()中返回。

在系统设备中所发生的"事件"主要指如下的信息：

- 设备某一个状态的改变
- 设备接收到数据
- 设备处于可写状态
- 错误状态



### 1.2 驱动程序任务与设备中断服务程序的同步

​	在设备访问的同步问题上，可以采用应用任务与驱动程序任务之间的同步操作。同时，也可以采用驱动程序任务与设备中断服务程序的同步设计来实现同步操作。如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-4f7642216ae3d7c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

过程如下：

1. 驱动程序任务执行semTake()操作，当没有获得信号量时任务处于阻塞状态。
2. 当设备接收到数据时，产生中断。
3. 中断服务程序调用semGive()函数，释放信号量。
4. 驱动程序任务获得信号量并从semTake()中返回。



## 2. 数据缓冲问题

### 2.1 设备驱动任务与应用任务的数据缓冲

​	任务间的数据缓冲如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-107375f8c5897bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

任务之间通过一个共享缓冲区进行数据的发送和接收。这种设计在总体上提高了系统的性能。对这种设计的描述如下：

#### **2.1.1 接收数据**

数据的接收主要经过如下的操作：

1. 设备驱动程序中的轮询任务的数据存放操作。当设备上有数据到来时，轮询任务读取数据并把它存放到共享内存、环形缓冲区、链表、管道或消息队列中。
2. 应用任务的数据读取操作。协同操作任务(应用任务)从共享缓冲区中读取设备轮询任务所存放的数据。

#### **2.1.2 数据发送**

数据的发送处理和数据的接收处理相反，操作过程如下：

1. 应用任务层数据的发送。这个处理过程中，首先的操作是查看共享缓冲区是否有空间存放要发送的数据。如果有，则把要发送的数据写到缓冲区中。反之，应用任务通常因为等待缓冲区而被阻塞。
2. 设备驱动层数据的发送。轮询任务查看设备状态，当设备的发送寄存器或内存为空时，轮询任务从共享缓冲区中把数据"拷贝"给设备。

#### **2.1.3 管道或消息队列的采用**

​	在共享缓冲的问题上，系统通常采用管道或者和是消息队列作为数据发送和接受的中转站。因为它们本身具有一些很明显的优势。

1. 同步优势：管道或消息队列提供任务间的同步操作。当管道或者是消息队列中无数据时，则任务处于悬置状态，一旦有数据任务马航处于就绪状态
2. 防止优先级反转：管道或消息队列具有优先级继承功能，采用优先级继承方法，解决了任务因为等待贡献资源而发生优先级反转问题。

#### 2.1.4 数据缓冲注意事项

如果采用共享内存、环形缓冲区或者链表，驱动程序必须注意以下事项：

1. 如果有必要的话，确保临界资源(如共享内存)互斥现象。
2. 自身提供任务的同步操作。





# VxWorks中USB相关内容

## 1. 简介

​	通用串行总线（USB）为主机和设备提供了一个多功能通道，以低至中速进行通信。目前USB在低速（1.5 Mbps）和中速（12 Mbps）数据传输速率下提供以下类型的服务：

- 控制转移
- 批量转移
- 中断传输
- 等时传输

USB还包含电源管理和动态链接和移除设备的规定。这种灵活性使USB可以同时使用多种不同类型的设备，每一种设备都需要自己的设备驱动程序支持。希望这些设备驱动彼此独立并独立于底层USB主机控制器接口的实现。Wind River的USB主机驱动程序堆栈满足了这些要求，提供了一整套服务来操作USB以及一些预置USB类驱动程序，以处理特定类型的USB设备。

​	在Wind River的VxWorks中USB驱动程序堆栈的开发符合的是**通用串行总线规范1.1版**，在VxWorks中USB主机驱动程序堆栈体系结构如下图所示：

![image.png](https://upload-images.jianshu.io/upload_images/6128001-59141b5ec2e1a49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最底层的是USB主机控制器(USB HC),其作用是在主机系统控制每一个USB硬件。目前，市场上主要有两种USB主机控制器系列，它们支持因特尔最初推出的通用主机控制器接口(UHCI),以及支持Microsoft、Compaq、National Semiconductor的开放主机控制器接口（OHCI）。许多硬件制造商围绕这些规格中的一个或另一个建立了USB HC。	

​	对于每一种类型的主机控制器，都有一个与硬件相关的USB主控制器驱动程序(HCD)。在Wind River中提供了两种预先建立好的驱动：

- 用于UHCI HC的usbHcdUhciLib
- 用于OHCI HC的usbHcdOhciLib

USB主机驱动程序(USBD)和HCD之间的接口允许每一个HCD控制一个或者多个潜在的HC。此外，wind River的USBD能够同时连接到多个USB HCD。这些设计功能允许你构建一系列复杂的USB系统

​	USBD是HCD上方与硬件无关的模块。USBD管理连接到主机上的每一个USB设备，并提供更高层与USB通信的路径，USBD负责自动处理USB电源管理和USB带宽管理。另外，对于Wind River架构而言，USBD管理USB集线器是独一无二的。集线器的功能对于USB的正确操作至关重要，因此Wind River的USBD的设计者认为集线器的功能应该由USBD透明的处理。这意味着USBD还可以处理USB集线器和设备的动态链接和移除。

​	处于USBD上层的是USB客户端模块。USB类驱动程序是客户端模块的典型示例。USB类驱动程序负责管理可以连接到USB的各种类型的设备；他们依靠USBD为各个设备提供通信路径。应用程序，诊断程序和测试程序是依赖于USBD与USB设备通信的客户端模块的其他示例。例如，Wind River提供了测试应用程序/模块usbTool，它可以让你对USB和USB设备进行交互式控制。

​	下图说明了wind river 的USB主机驱动程序堆栈的模块之间的功能关系。

![主机模块路线图](https://upload-images.jianshu.io/upload_images/6128001-edf0a8b6fae5609a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	在系统中随时可能会发生USB设备的热插拔，因此，必须要编写USBD极其客户端在运行时能够识别USB设备的出现和消失。正是因为如此，主机控制器的出现和消失也可以灵活的处理。当新的主机控制器连接到系统时，USBD会自动识别连接到它的设备并通知感兴趣的客户端。同样，当主控制器从系统中移除时，USBD会自动通知感兴趣的客户端，连接到该主控制器的设备已经消失。这里的关键是USBD客户端(如USB类驱动程序)从不会假定客户端首次初始化时存在特定的设备，并且这些驱动程序随时可以接受在其他的时间连接到系统的设备。

​	

要使用VxWorks提供的USBD库，必须要现将其初始化，USBD的初始化是一个两步的过程，

​	首先要至少一次调用USBD的入口点usbdInitialize()。该函数初始化内部的USBD数据结构，反过来，调用USB驱动程序堆栈的其他模块的初始化入口点。在给定的系统中，可以调用**usbdInitialize（）**一次（可能在引导序列期间）或多次调用它（如在每个USBD客户机的初始化期间）。USBD认为递增针对每个成功调用使用计数**usbdInitialize（）**和递减用于向每个相应的呼叫**usbdShutdown（）**。USBD仅在使用次数从零变为1时才真正初始化，并且当使用次数返回到零时它仅真正“关闭”。

​	其次是使用USBD的usbdHcdAttach()例程将至少一个HCD附加到USBD。通常，在VxWorks启动序列期间，HCD与USBD的连接发生。但是，USBD允许HCD在运行时连接和分离。这种灵活性使得USBD可以支持USB主机控制器可以在不重启系统的情况下实现热插拔。

​	HCD的连接和分离必须由USBD来决定。通常USBD客户端(如USB类驱动程序)不负责将HCD连接到USBD。



**注册客户端模块**

​	打算利用USBD与USB设备通信的客户端模块除了调用usbdInitialize()之外。还必须要通过调用usbdClientRegister()函数向USBD注册。当客户端向USBD注册的时候，USBD将会分配每个客户端的数据结构，之后用于跟踪该客户端发出的所有请求。在客户端注册期间，USBD还会为每一个祖册客户端创建一个回调任务。成功祖册新客户端之后，USBD将会返回一个句柄USBD_CLIENT_HANDLE,该句柄在进行后续USBD调用时必须由该客户端使用。

​	当不需要再使用USBD时，它必须要调用usbdClientUnregister()以释放其每个客户端数据和回调任务。客户发出的任何未完成的USB请求都会在此时被取消。



**客户端回调任务**

​	USB操作是对时间敏感的。例如USB中断传输和同步传输为了正确的工作必须依赖于时间服务。对于存在几个不同的USBD客户端的主机系统，一个客户端可能总是会干扰需要服务时间敏感USB通信的其他客户端的及时执行。Wind River USBD引入了每个客户端的回调任务来管理这个问题。

​	许多USB事件可能导致USBD客户端回调。例如，只要USBD完成USB IRP的执行，就会调用客户端的IRP回调例程。同样，只要USBD识别动态加载事件，就会调用一个或多个客户端的动态加载回调例程。USBD不是立即调用这些回调例程，而是将回调调度由相应的USBD客户端的回调任务执行。通常，每个客户端的回调任务是“休眠”（处于阻塞状态）的。当USBD为特定客户端安排回调时，相应的客户端回调任务将“唤醒”（取消阻止）并执行实际的回调。这种方法允许USBD在客户端自己获得CPU控制权之前处理所有未完成的USB事件。

​	每个客户端的回调任务继承最初称为**usbdClientRegister（）**的任务的VxWorks任务优先级。这可确保回调按每个客户端预期的任务优先级进行处理，并允许您编写客户端以利用任务优先级作为确保对时间敏感的USB通信进行适当调度的手段。

​	由于每个客户端都有自己的回调任务，因此客户在回调期间可以执行的工作量具有更大的灵活性。例如，在回调期间，执行代码可以被阻止而不会影响USBD或其他USBD客户端的性能。

​	客户端回调任务具有VxWorks任务名称**tUsbdCln**。











